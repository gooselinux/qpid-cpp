From 11ed7634097ca3a3e52141509496105ad65290be Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Fri, 21 May 2010 17:31:29 +0000
Subject: [PATCH 001/129] Fix broker core dump during start-up caused by un-initialized mAgent pointer.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@947081 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit ffc5afc35bbc8854e1956d120f79072373f29432)
---
 qpid/cpp/src/qpid/cluster/Cluster.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Cluster.cpp b/qpid/cpp/src/qpid/cluster/Cluster.cpp
index 7332102..099c3ef 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.cpp
+++ b/qpid/cpp/src/qpid/cluster/Cluster.cpp
@@ -247,6 +247,7 @@ Cluster::Cluster(const ClusterSettings& set, broker::Broker& b) :
     name(settings.name),
     self(cpg.self()),
     clusterId(true),
+    mAgent(0),
     expiryPolicy(new ExpiryPolicy(mcast, self, broker.getTimer())),
     mcast(cpg, poller, boost::bind(&Cluster::leave, this)),
     dispatcher(cpg, poller, boost::bind(&Cluster::leave, this)),
-- 
1.7.1.1

From a15f49f58cdb1ee2906f03bb487cf40c43498238 Mon Sep 17 00:00:00 2001
From: Kenneth Anthony Giusti <kgiusti@apache.org>
Date: Thu, 20 May 2010 21:42:40 +0000
Subject: [PATCH 002/129] Bug 593828 - QMF: python console needs ability to filter unsolicited events.
 QMF: provide event filter api for python console

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@946801 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit b806ee99fb0224069ba628bc0c506e02bb227de2)
---
 qpid/cpp/src/qpid/management/ManagementAgent.cpp |   46 ++++++++++++++++-----
 qpid/cpp/src/qpid/management/ManagementAgent.h   |    2 +
 2 files changed, 37 insertions(+), 11 deletions(-)

diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.cpp b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
index 92f9d79..d4649a7 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
@@ -52,6 +52,25 @@ using namespace std;
 namespace _qmf = qmf::org::apache::qpid::broker;
 
 
+namespace {
+    const string defaultVendorName("vendor");
+    const string defaultProductName("product");
+
+    // Create a valid binding key substring by
+    // replacing all '.' chars with '_'
+    const string keyifyNameStr(const string& name)
+    {
+        string n2 = name;
+
+        size_t pos = n2.find('.');
+        while (pos != n2.npos) {
+            n2.replace(pos, 1, "_");
+            pos = n2.find('.', pos);
+        }
+        return n2;
+    }
+}
+
 
 static Variant::Map mapEncodeSchemaId(const string& pname,
                                       const string& cname,
@@ -81,6 +100,7 @@ ManagementAgent::ManagementAgent (const bool qmfV1, const bool qmfV2) :
     threadPoolSize(1), interval(10), broker(0), timer(0),
     startTime(sys::now()),
     suppressed(false), disallowAllV1Methods(false),
+    vendorNameKey(defaultVendorName), productNameKey(defaultProductName),
     qmf1Support(qmfV1), qmf2Support(qmfV2)
 {
     nextObjectId   = 1;
@@ -89,6 +109,8 @@ ManagementAgent::ManagementAgent (const bool qmfV1, const bool qmfV2) :
     nextRemoteBank = 10;
     nextRequestSequence = 1;
     clientWasAdded = false;
+    attrMap["_vendor"] = defaultVendorName;
+    attrMap["_product"] = defaultProductName;
 }
 
 ManagementAgent::~ManagementAgent ()
@@ -196,6 +218,9 @@ void ManagementAgent::setName(const string& vendor, const string& product, const
    name_address = vendor + ":" + product + ":" + inst;
    attrMap["_instance"] = inst;
    attrMap["_name"] = name_address;
+
+   vendorNameKey = keyifyNameStr(vendor);
+   productNameKey = keyifyNameStr(product);
 }
 
 
@@ -318,6 +343,10 @@ ObjectId ManagementAgent::addObject(ManagementObject* object,
 
 void ManagementAgent::raiseEvent(const ManagementEvent& event, severity_t severity)
 {
+    static const std::string severityStr[] = {
+        "emerg", "alert", "crit", "error", "warn",
+        "note", "info", "debug"
+    };
     sys::Mutex::ScopedLock lock (userLock);
     uint8_t sev = (severity == SEV_DEFAULT) ? event.getSeverity() : (uint8_t) severity;
 
@@ -362,7 +391,11 @@ void ManagementAgent::raiseEvent(const ManagementEvent& event, severity_t severi
         headers["qmf.agent"] = name_address;
 
         stringstream key;
-        key << "agent.ind.event." << sev << "." << name_address << "." << event.getEventName();
+        key << "agent.ind.event." << vendorNameKey
+            << "." << productNameKey
+            << "." << severityStr[sev]
+            << "." << keyifyNameStr(event.getPackageName())
+            << "." << keyifyNameStr(event.getEventName());
 
         string content;
         MapCodec::encode(map_, content);
@@ -803,16 +836,7 @@ void ManagementAgent::periodicProcessing (void)
     if (qmf2Support) {
         std::stringstream addr_key;
 
-        addr_key << "agent.ind.heartbeat";
-
-        // append .<vendor>.<product> to address key if present.
-        Variant::Map::const_iterator v;
-        if ((v = attrMap.find("_vendor")) != attrMap.end()){
-            addr_key << "." << v->second.getString();
-            if ((v = attrMap.find("_product")) != attrMap.end()) {
-                addr_key << "." << v->second.getString();
-            }
-        }
+        addr_key << "agent.ind.heartbeat." << vendorNameKey << "." << productNameKey;
 
         Variant::Map map;
         Variant::Map headers;
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.h b/qpid/cpp/src/qpid/management/ManagementAgent.h
index a87cc91..8129c1e 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.h
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.h
@@ -284,6 +284,8 @@ private:
     // Agent name and address
     qpid::types::Variant::Map attrMap;
     std::string       name_address;
+    std::string vendorNameKey;  // "." --> "_"
+    std::string productNameKey; // "." --> "_"
 
     // supported management protocol
     bool qmf1Support;
-- 
1.7.1.1

From d3a710d15dcfa2d14750c783de70776bb50a856d Mon Sep 17 00:00:00 2001
From: Kenneth Anthony Giusti <kgiusti@apache.org>
Date: Fri, 21 May 2010 17:39:51 +0000
Subject: [PATCH 003/129] Bug 593831 - QMF: c++ console needs ability to filter unsolicited events.

QMF: add bindEvent api to allow filtering of unsolicted events.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@947084 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 5afdc67935d07852c7c166741401ec4a77604d9b)
---
 qpid/cpp/bindings/qmf/python/qmf.py            |   15 +++++++++++-
 qpid/cpp/bindings/qmf/ruby/qmf.rb              |   15 ++++++++++++
 qpid/cpp/include/qmf/engine/Console.h          |    3 ++
 qpid/cpp/include/qpid/console/SessionManager.h |   14 +++++++++++
 qpid/cpp/src/qmf/engine/ConsoleImpl.cpp        |   30 ++++++++++++++++++++++++
 qpid/cpp/src/qmf/engine/ConsoleImpl.h          |    2 +
 qpid/cpp/src/qpid/console/SessionManager.cpp   |   27 +++++++++++++++++++++
 7 files changed, 105 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/bindings/qmf/python/qmf.py b/qpid/cpp/bindings/qmf/python/qmf.py
index 37442b9..06d3070 100644
--- a/qpid/cpp/bindings/qmf/python/qmf.py
+++ b/qpid/cpp/bindings/qmf/python/qmf.py
@@ -1166,9 +1166,22 @@ class Console(Thread):
             if "class" in kwargs:
                 self.impl.bindClass(package, kwargs["class"])
             else:
-                self.impl.bindClass(package)
+                self.impl.bindClass(package, "*")
         else:
             raise Exception("Argument error: invalid arguments, use 'key' or 'package'[,'class']")
+
+
+    def bind_event(self, kwargs = {}):
+        if "key" in kwargs:
+            self.impl.bindEvent(kwargs["key"])
+        elif "package" in kwargs:
+            package = kwargs["package"]
+            if "event" in kwargs:
+                self.impl.bindEvent(package, kwargs["event"])
+            else:
+                self.impl.bindEvent(package, "*")
+        else:
+            raise Exception("Argument error: invalid arguments, use 'key' or 'package'[,'event']")
     
     
     def agents(self, broker=None):
diff --git a/qpid/cpp/bindings/qmf/ruby/qmf.rb b/qpid/cpp/bindings/qmf/ruby/qmf.rb
index e50d23a..34d3255 100644
--- a/qpid/cpp/bindings/qmf/ruby/qmf.rb
+++ b/qpid/cpp/bindings/qmf/ruby/qmf.rb
@@ -1087,6 +1087,21 @@ module Qmf
       end
     end
 
+    def bind_event(kwargs = {})
+      if kwargs.include?(:key)
+        @impl.bindEvent(kwargs[:key])
+      elsif kwargs.include?(:package)
+        package = kwargs[:package]
+        if kwargs.include?(:event)
+          @impl.bindEvent(package, kwargs[:event])
+        else
+          @impl.bindEvent(package, "*")
+        end
+      else
+        raise ArgumentError, "Invalid arguments, use :key or :package[,:event]"
+      end
+    end
+
     def agents(broker = nil)
       blist = []
       if broker
diff --git a/qpid/cpp/include/qmf/engine/Console.h b/qpid/cpp/include/qmf/engine/Console.h
index 03b3993..bd40c63 100644
--- a/qpid/cpp/include/qmf/engine/Console.h
+++ b/qpid/cpp/include/qmf/engine/Console.h
@@ -217,6 +217,9 @@ namespace engine {
         void bindClass(const SchemaClassKey* key);
         void bindClass(const char* packageName, const char* className);
 
+        void bindEvent(const SchemaClassKey *key);
+        void bindEvent(const char* packageName, const char* eventName);
+
         /*
         void startSync(const Query& query, void* context, SyncQuery& sync);
         void touchSync(SyncQuery& sync);
diff --git a/qpid/cpp/include/qpid/console/SessionManager.h b/qpid/cpp/include/qpid/console/SessionManager.h
index f27037a..b46af54 100644
--- a/qpid/cpp/include/qpid/console/SessionManager.h
+++ b/qpid/cpp/include/qpid/console/SessionManager.h
@@ -138,6 +138,20 @@ class SessionManager
     QPID_CONSOLE_EXTERN void bindClass(const std::string& packageName,
                                        const std::string& className);
 
+    /** Request events from a particular package.
+     *
+     * Note that this method is only meaningful if a ConsoleListener was provided at session
+     * creation and if the 'userBindings' flag was set to true.
+     *
+     * @param classKey Class key of event of interest
+     * @param packageName Name of package of event of interest.
+     * @param eventName Name of event of interest. Default=All events defined by package.
+     */
+    QPID_CONSOLE_EXTERN void bindEvent(const ClassKey& classKey);
+    QPID_CONSOLE_EXTERN void bindEvent(const std::string& packageName,
+                                       const std::string& eventName="");
+
+
     /** Get a list of qmf agents known to the session manager.
      *
      *@param agents Vector of Agent objects returned by the session manager.
diff --git a/qpid/cpp/src/qmf/engine/ConsoleImpl.cpp b/qpid/cpp/src/qmf/engine/ConsoleImpl.cpp
index 1b66d9e..4a5da31 100644
--- a/qpid/cpp/src/qmf/engine/ConsoleImpl.cpp
+++ b/qpid/cpp/src/qmf/engine/ConsoleImpl.cpp
@@ -259,6 +259,32 @@ void ConsoleImpl::bindClass(const char* packageName, const char* className)
         (*iter)->addBinding(QMF_EXCHANGE, key.str());
 }
 
+
+void ConsoleImpl::bindEvent(const SchemaClassKey* classKey)
+{
+    bindEvent(classKey->getPackageName(), classKey->getClassName());
+}
+
+void ConsoleImpl::bindEvent(const char* packageName, const char* eventName)
+{
+    if (!settings.userBindings) throw qpid::Exception("Console not configured for userBindings.");
+    if (settings.rcvEvents) throw qpid::Exception("Console already configured to receive all events.");
+
+    stringstream key;
+    key << "console.event.*.*." << packageName;
+    if (eventName && *eventName) {
+        key << "." << eventName << ".#";
+    } else {
+        key << ".#";
+    }
+
+    Mutex::ScopedLock _lock(lock);
+    bindingList.push_back(pair<string, string>(string(), key.str()));
+    for (vector<BrokerProxyImpl*>::iterator iter = brokerList.begin();
+         iter != brokerList.end(); iter++)
+        (*iter)->addBinding(QMF_EXCHANGE, key.str());
+}
+
 /*
 void ConsoleImpl::startSync(const Query& query, void* context, SyncQuery& sync)
 {
@@ -421,6 +447,10 @@ const SchemaEventClass* Console::getEventClass(const SchemaClassKey* key) const
 void Console::bindPackage(const char* packageName) { impl->bindPackage(packageName); }
 void Console::bindClass(const SchemaClassKey* key) { impl->bindClass(key); }
 void Console::bindClass(const char* packageName, const char* className) { impl->bindClass(packageName, className); }
+
+void Console::bindEvent(const SchemaClassKey *key) { impl->bindEvent(key); }
+void Console::bindEvent(const char* packageName, const char* eventName) { impl->bindEvent(packageName, eventName); }
+
 //void Console::startSync(const Query& query, void* context, SyncQuery& sync) { impl->startSync(query, context, sync); }
 //void Console::touchSync(SyncQuery& sync) { impl->touchSync(sync); }
 //void Console::endSync(SyncQuery& sync) { impl->endSync(sync); }
diff --git a/qpid/cpp/src/qmf/engine/ConsoleImpl.h b/qpid/cpp/src/qmf/engine/ConsoleImpl.h
index ace47ec..0c27fda 100644
--- a/qpid/cpp/src/qmf/engine/ConsoleImpl.h
+++ b/qpid/cpp/src/qmf/engine/ConsoleImpl.h
@@ -94,6 +94,8 @@ namespace engine {
         void bindPackage(const char* packageName);
         void bindClass(const SchemaClassKey* key);
         void bindClass(const char* packageName, const char* className);
+        void bindEvent(const SchemaClassKey* key);
+        void bindEvent(const char* packageName, const char* eventName);
 
         /*
         void startSync(const Query& query, void* context, SyncQuery& sync);
diff --git a/qpid/cpp/src/qpid/console/SessionManager.cpp b/qpid/cpp/src/qpid/console/SessionManager.cpp
index 0285c5f..4f39095 100644
--- a/qpid/cpp/src/qpid/console/SessionManager.cpp
+++ b/qpid/cpp/src/qpid/console/SessionManager.cpp
@@ -138,6 +138,33 @@ void SessionManager::bindClass(const std::string& packageName, const std::string
         (*iter)->addBinding(key.str());
 }
 
+
+void SessionManager::bindEvent(const ClassKey& classKey)
+{
+    bindEvent(classKey.getPackageName(), classKey.getClassName());
+}
+
+
+void SessionManager::bindEvent(const std::string& packageName, const std::string& eventName)
+{
+    if (!settings.userBindings) throw Exception("Session not configured for userBindings.");
+    if (settings.rcvEvents) throw Exception("Session already configured to receive all events.");
+
+    stringstream key;
+    key << "console.event.*.*." << packageName;
+    if (eventName.length()) {
+        key << "." << eventName << ".#";
+    } else {
+        key << ".#";
+    }
+
+    bindingKeyList.push_back(key.str());
+    for (vector<Broker*>::iterator iter = brokers.begin();
+         iter != brokers.end(); iter++)
+        (*iter)->addBinding(key.str());
+}
+
+
 void SessionManager::getAgents(Agent::Vector& agents, Broker* broker)
 {
     agents.clear();
-- 
1.7.1.1

From 648ab87be54d30af2ec14b7b8eb7bd77735f5ffa Mon Sep 17 00:00:00 2001
From: Kim van der Riet <kpvdr@apache.org>
Date: Mon, 24 May 2010 15:48:18 +0000
Subject: [PATCH 004/129] Changed the names of tests which are installed in /usr/bin/ to be prefixed with "qpid-". This will make these generic names easier to associate with qpid. (BZ577353)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@947678 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/tests/CMakeLists.txt                  |   56 +-
 qpid/cpp/src/tests/Makefile.am                     |   60 +-
 qpid/cpp/src/tests/client_test.cpp                 |  139 ----
 qpid/cpp/src/tests/cluster_authentication_soak.cpp |   22 +-
 qpid/cpp/src/tests/cluster_tests.py                |    2 +-
 qpid/cpp/src/tests/latencytest.cpp                 |  469 -------------
 qpid/cpp/src/tests/perftest.cpp                    |  741 --------------------
 qpid/cpp/src/tests/qpid-client-test.cpp            |  139 ++++
 qpid/cpp/src/tests/qpid-latency-test.cpp           |  469 +++++++++++++
 qpid/cpp/src/tests/qpid-perftest.cpp               |  741 ++++++++++++++++++++
 qpid/cpp/src/tests/qpid-topic-listener.cpp         |  209 ++++++
 qpid/cpp/src/tests/qpid-topic-publisher.cpp        |  230 ++++++
 qpid/cpp/src/tests/qpid-txtest.cpp                 |  340 +++++++++
 qpid/cpp/src/tests/quick_perftest                  |    2 +-
 qpid/cpp/src/tests/quick_txtest                    |    2 +-
 qpid/cpp/src/tests/run_perftest                    |    6 +-
 qpid/cpp/src/tests/ssl_test                        |    2 +-
 qpid/cpp/src/tests/topic_listener.cpp              |  209 ------
 qpid/cpp/src/tests/topic_publisher.cpp             |  230 ------
 qpid/cpp/src/tests/topictest                       |    4 +-
 qpid/cpp/src/tests/txtest.cpp                      |  340 ---------
 21 files changed, 2206 insertions(+), 2206 deletions(-)
 delete mode 100644 qpid/cpp/src/tests/client_test.cpp
 delete mode 100644 qpid/cpp/src/tests/latencytest.cpp
 delete mode 100644 qpid/cpp/src/tests/perftest.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-client-test.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-latency-test.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-perftest.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-topic-listener.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-topic-publisher.cpp
 create mode 100644 qpid/cpp/src/tests/qpid-txtest.cpp
 delete mode 100644 qpid/cpp/src/tests/topic_listener.cpp
 delete mode 100644 qpid/cpp/src/tests/topic_publisher.cpp
 delete mode 100644 qpid/cpp/src/tests/txtest.cpp

diff --git a/qpid/cpp/src/tests/CMakeLists.txt b/qpid/cpp/src/tests/CMakeLists.txt
index c645815..47714ac 100644
--- a/qpid/cpp/src/tests/CMakeLists.txt
+++ b/qpid/cpp/src/tests/CMakeLists.txt
@@ -182,40 +182,40 @@ endif (BUILD_CLUSTER)
 #
 # Other test programs
 #
-add_executable (perftest perftest.cpp ${platform_test_additions})
-target_link_libraries (perftest qpidclient)
-#perftest_SOURCES=perftest.cpp test_tools.h TestOptions.h ConnectionOptions.h
-remember_location(perftest)
+add_executable (qpid-perftest qpid-perftest.cpp ${platform_test_additions})
+target_link_libraries (qpid-perftest qpidclient)
+#qpid_perftest_SOURCES=qpid-perftest.cpp test_tools.h TestOptions.h ConnectionOptions.h
+remember_location(qpid-perftest)
 
-add_executable (txtest txtest.cpp ${platform_test_additions})
-target_link_libraries (txtest qpidclient)
-#txtest_SOURCES=txtest.cpp  TestOptions.h ConnectionOptions.h
-remember_location(txtest)
+add_executable (qpid-txtest qpid-txtest.cpp ${platform_test_additions})
+target_link_libraries (qpid-txtest qpidclient)
+#qpid_txtest_SOURCES=qpid-txtest.cpp  TestOptions.h ConnectionOptions.h
+remember_location(qpid-txtest)
 
-add_executable (latencytest latencytest.cpp ${platform_test_additions})
-target_link_libraries (latencytest qpidclient)
-#latencytest_SOURCES=latencytest.cpp TestOptions.h ConnectionOptions.h
-remember_location(latencytest)
+add_executable (qpid-latency-test qpid-latency-test.cpp ${platform_test_additions})
+target_link_libraries (qpid-latency-test qpidclient)
+#qpid_latencytest_SOURCES=qpid-latency-test.cpp TestOptions.h ConnectionOptions.h
+remember_location(qpid-latency-test)
 
 add_executable (echotest echotest.cpp ${platform_test_additions})
 target_link_libraries (echotest qpidclient)
 #echotest_SOURCES=echotest.cpp TestOptions.h ConnectionOptions.h
 remember_location(echotest)
 
-add_executable (client_test client_test.cpp ${platform_test_additions})
-target_link_libraries (client_test qpidclient)
-#client_test_SOURCES=client_test.cpp TestOptions.h ConnectionOptions.h
-remember_location(client_test)
+add_executable (qpid-client-test qpid-client-test.cpp ${platform_test_additions})
+target_link_libraries (qpid-client-test qpidclient)
+#qpid_client_test_SOURCES=qpid-client-test.cpp TestOptions.h ConnectionOptions.h
+remember_location(qpid-client-test)
 
-add_executable (topic_listener topic_listener.cpp ${platform_test_additions})
-target_link_libraries (topic_listener qpidclient)
-#topic_listener_SOURCES=topic_listener.cpp TestOptions.h ConnectionOptions.h
-remember_location(topic_listener)
+add_executable (qpid-topic-listener qpid-topic-listener.cpp ${platform_test_additions})
+target_link_libraries (qpid-topic-listener qpidclient)
+#qpid_topic_listener_SOURCES=qpid-topic-listener.cpp TestOptions.h ConnectionOptions.h
+remember_location(qpid-topic-listener)
 
-add_executable (topic_publisher topic_publisher.cpp ${platform_test_additions})
-target_link_libraries (topic_publisher qpidclient)
-#topic_publisher_SOURCES=topic_publisher.cpp TestOptions.h ConnectionOptions.h
-remember_location(topic_publisher)
+add_executable (qpid-topic-publisher qpid-topic-publisher.cpp ${platform_test_additions})
+target_link_libraries (qpid-topic-publisher qpidclient)
+#qpid_topic_publisher_SOURCES=qpid-topic-publisher.cpp TestOptions.h ConnectionOptions.h
+remember_location(qpid-topic-publisher)
 
 add_executable (publish publish.cpp ${platform_test_additions})
 target_link_libraries (publish qpidclient)
@@ -272,8 +272,8 @@ add_executable (qpid_send qpid_send.cpp Statistics.cpp ${platform_test_additions
 target_link_libraries (qpid_send qpidmessaging)
 remember_location(qpid_send)
 
-# perftest and latencytest are generally useful so install them
-install (TARGETS perftest latencytest RUNTIME
+# qpid-perftest and qpid-latency-test are generally useful so install them
+install (TARGETS qpid-perftest qpid-latency-test RUNTIME
          DESTINATION ${QPID_INSTALL_BINDIR})
 
 if (CMAKE_SYSTEM_NAME STREQUAL Windows)
@@ -286,8 +286,8 @@ set(test_wrap ${shell} ${CMAKE_CURRENT_SOURCE_DIR}/run_test${test_script_suffix}
 
 add_test (unit_test ${test_wrap} ${unit_test_LOCATION})
 add_test (start_broker ${shell} ${CMAKE_CURRENT_SOURCE_DIR}/start_broker${test_script_suffix})
-add_test (client_test ${test_wrap} ${client_test_LOCATION})
-add_test (quick_perftest ${test_wrap} ${perftest_LOCATION} --summary --count 100)
+add_test (qpid-client-test ${test_wrap} ${client_test_LOCATION})
+add_test (quick_perftest ${test_wrap} ${qpid-perftest_LOCATION} --summary --count 100)
 add_test (quick_topictest ${test_wrap} ${CMAKE_CURRENT_SOURCE_DIR}/quick_topictest${test_script_suffix})
 add_test (quick_txtest ${test_wrap} ${txtest_LOCATION} --queues 4 --tx-count 10 --quiet)
 if (PYTHON_EXECUTABLE)
diff --git a/qpid/cpp/src/tests/Makefile.am b/qpid/cpp/src/tests/Makefile.am
index 235e6fe..92e4e85 100644
--- a/qpid/cpp/src/tests/Makefile.am
+++ b/qpid/cpp/src/tests/Makefile.am
@@ -184,35 +184,35 @@ qpid_send_SOURCES = \
   Statistics.cpp
 qpid_send_LDADD = $(lib_messaging)
 
-qpidtest_PROGRAMS+=perftest
-perftest_SOURCES=perftest.cpp test_tools.h TestOptions.h ConnectionOptions.h
-perftest_INCLUDES=$(PUBLIC_INCLUDES)
-perftest_LDADD=$(lib_client) 
-
-qpidtest_PROGRAMS+=txtest
-txtest_INCLUDES=$(PUBLIC_INCLUDES)
-txtest_SOURCES=txtest.cpp  TestOptions.h ConnectionOptions.h
-txtest_LDADD=$(lib_client) 
-
-qpidtest_PROGRAMS+=latencytest
-latencytest_INCLUDES=$(PUBLIC_INCLUDES)
-latencytest_SOURCES=latencytest.cpp TestOptions.h ConnectionOptions.h
-latencytest_LDADD=$(lib_client) 
-
-qpidtest_PROGRAMS+=client_test
-client_test_INCLUDES=$(PUBLIC_INCLUDES)
-client_test_SOURCES=client_test.cpp TestOptions.h ConnectionOptions.h
-client_test_LDADD=$(lib_client) 
-
-qpidtest_PROGRAMS+=topic_listener
-topic_listener_INCLUDES=$(PUBLIC_INCLUDES)
-topic_listener_SOURCES=topic_listener.cpp TestOptions.h ConnectionOptions.h
-topic_listener_LDADD=$(lib_client) 
-
-qpidtest_PROGRAMS+=topic_publisher
-topic_publisher_INCLUDES=$(PUBLIC_INCLUDES)
-topic_publisher_SOURCES=topic_publisher.cpp TestOptions.h ConnectionOptions.h
-topic_publisher_LDADD=$(lib_client) 
+qpidtest_PROGRAMS+=qpid-perftest
+qpid_perftest_SOURCES=qpid-perftest.cpp test_tools.h TestOptions.h ConnectionOptions.h
+qpid_perftest_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_perftest_LDADD=$(lib_client) 
+
+qpidtest_PROGRAMS+=qpid-txtest
+qpid_txtest_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_txtest_SOURCES=qpid-txtest.cpp  TestOptions.h ConnectionOptions.h
+qpid_txtest_LDADD=$(lib_client) 
+
+qpidtest_PROGRAMS+=qpid-latency-test
+qpid_latency_test_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_latency_test_SOURCES=qpid-latency-test.cpp TestOptions.h ConnectionOptions.h
+qpid_latency_test_LDADD=$(lib_client) 
+
+qpidtest_PROGRAMS+=qpid-client-test
+qpid_client_test_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_client_test_SOURCES=qpid-client-test.cpp TestOptions.h ConnectionOptions.h
+qpid_client_test_LDADD=$(lib_client) 
+
+qpidtest_PROGRAMS+=qpid-topic-listener
+qpid_topic_listener_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_topic_listener_SOURCES=qpid-topic-listener.cpp TestOptions.h ConnectionOptions.h
+qpid_topic_listener_LDADD=$(lib_client) 
+
+qpidtest_PROGRAMS+=qpid-topic-publisher
+qpid_topic_publisher_INCLUDES=$(PUBLIC_INCLUDES)
+qpid_topic_publisher_SOURCES=qpid-topic-publisher.cpp TestOptions.h ConnectionOptions.h
+qpid_topic_publisher_LDADD=$(lib_client) 
 
 qpidtest_PROGRAMS+=qpid_ping
 qpid_ping_INCLUDES=$(PUBLIC_INCLUDES)
@@ -313,7 +313,7 @@ TESTS_ENVIRONMENT = \
     QPID_DATA_DIR= \
     $(srcdir)/run_test 
 
-system_tests = client_test quick_perftest quick_topictest run_header_test quick_txtest
+system_tests = qpid-client-test quick_perftest quick_topictest run_header_test quick_txtest
 TESTS += start_broker $(system_tests) python_tests stop_broker run_federation_tests run_acl_tests run_cli_tests replication_test
 
 EXTRA_DIST +=								\
diff --git a/qpid/cpp/src/tests/client_test.cpp b/qpid/cpp/src/tests/client_test.cpp
deleted file mode 100644
index 2f5e8e5..0000000
--- a/qpid/cpp/src/tests/client_test.cpp
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-/**
- * This file provides a simple test (and example) of basic
- * functionality including declaring an exchange and a queue, binding
- * these together, publishing a message and receiving that message
- * asynchronously.
- */
-
-#include <iostream>
-
-#include "TestOptions.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/Message.h"
-#include "qpid/client/Session.h"
-#include "qpid/client/SubscriptionManager.h"
-
-
-using namespace qpid;
-using namespace qpid::client;
-using namespace qpid::framing;
-using std::string;
-
-namespace qpid {
-namespace tests {
-
-struct Args : public TestOptions {
-    uint msgSize;
-    bool verbose;
-
-    Args() : TestOptions("Simple test of Qpid c++ client; sends and receives a single message."), msgSize(26)
-    {
-        addOptions()
-            ("size", optValue(msgSize, "N"), "message size")
-            ("verbose", optValue(verbose), "print out some status messages");
-    }
-};
-
-const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
-
-std::string generateData(uint size)
-{
-    if (size < chars.length()) {
-        return chars.substr(0, size);
-    }
-    std::string data;
-    for (uint i = 0; i < (size / chars.length()); i++) {
-        data += chars;
-    }
-    data += chars.substr(0, size % chars.length());
-    return data;
-}
-
-void print(const std::string& text, const Message& msg)
-{
-    std::cout << text;
-    if (msg.getData().size() > 16) {
-        std::cout << msg.getData().substr(0, 16) << "...";
-    } else {
-        std::cout << msg.getData();
-    }
-    std::cout << std::endl;
-}
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-int main(int argc, char** argv)
-{
-    try {
-        Args opts;
-        opts.parse(argc, argv);
-
-        //Connect to the broker:
-        Connection connection;
-        opts.open(connection);
-	if (opts.verbose) std::cout << "Opened connection." << std::endl;
-
-        //Create and open a session on the connection through which
-        //most functionality is exposed:
-        Session session = connection.newSession();
-	if (opts.verbose) std::cout << "Opened session." << std::endl;
-
-
-        //'declare' the exchange and the queue, which will create them
-        //as they don't exist
-	session.exchangeDeclare(arg::exchange="MyExchange", arg::type="direct");
-	if (opts.verbose) std::cout << "Declared exchange." << std::endl;
-	session.queueDeclare(arg::queue="MyQueue", arg::autoDelete=true, arg::exclusive=true);
-	if (opts.verbose) std::cout << "Declared queue." << std::endl;
-
-        //now bind the queue to the exchange
-	session.exchangeBind(arg::exchange="MyExchange", arg::queue="MyQueue", arg::bindingKey="MyKey");
-	if (opts.verbose) std::cout << "Bound queue to exchange." << std::endl;
-
-        //create and send a message to the exchange using the routing
-        //key we bound our queue with:
-	Message msgOut(generateData(opts.msgSize));
-        msgOut.getDeliveryProperties().setRoutingKey("MyKey");
-        session.messageTransfer(arg::destination="MyExchange", arg::content=msgOut, arg::acceptMode=1);
-	if (opts.verbose) print("Published message: ", msgOut);
-
-        // Using the SubscriptionManager, get the message from the queue.
-        SubscriptionManager subs(session);
-        Message msgIn = subs.get("MyQueue");
-        if (msgIn.getData() == msgOut.getData())
-            if (opts.verbose) std::cout << "Received the exepected message." << std::endl;
-
-        //close the session & connection
-	session.close();
-	if (opts.verbose) std::cout << "Closed session." << std::endl;
-	connection.close();
-	if (opts.verbose) std::cout << "Closed connection." << std::endl;
-        return 0;
-    } catch(const std::exception& e) {
-	std::cout << e.what() << std::endl;
-    }
-    return 1;
-}
diff --git a/qpid/cpp/src/tests/cluster_authentication_soak.cpp b/qpid/cpp/src/tests/cluster_authentication_soak.cpp
index 985c3aa..ccf4d27 100644
--- a/qpid/cpp/src/tests/cluster_authentication_soak.cpp
+++ b/qpid/cpp/src/tests/cluster_authentication_soak.cpp
@@ -104,10 +104,10 @@ runPerftest ( ) {
     stringstream portSs;
     portSs << newbiePort;
 
-    char const *  path = "./perftest";
+    char const *  path = "./qpid-perftest";
 
     vector<char const *> argv;
-    argv.push_back ( "./perftest" );
+    argv.push_back ( "./qpid-perftest" );
     argv.push_back ( "-p" );
     argv.push_back ( portSs.str().c_str() );
     argv.push_back ( "--username" );
@@ -129,7 +129,7 @@ runPerftest ( ) {
 
         execv ( path, const_cast<char * const *>(&argv[0]) );
         // The exec failed: we are still in parent process.
-        perror ( "error running perftest: " ); 
+        perror ( "error running qpid-perftest: " );
         return false;
     }
     else {
@@ -146,19 +146,19 @@ runPerftest ( ) {
           if ( returned_pid == pid ) {
               int exit_status = WEXITSTATUS(status);
               if ( exit_status ) {
-                cerr << "Perftest failed. exit_status was: " << exit_status;
+                cerr << "qpid-perftest failed. exit_status was: " << exit_status;
                 return false;
               }
               else {
-                return true; // perftest succeeded.
+                return true; // qpid-perftest succeeded.
               }
           }
-          else  {  // perftest has not yet completed. 
+          else  {  // qpid-perftest has not yet completed.
               gettimeofday ( & currentTime, 0 );
               timersub ( & currentTime, & startTime, & duration );
               if ( duration.tv_sec > 60 ) {
                 kill ( pid, 9 );
-                cerr << "Perftest pid " << pid << " hanging: killed.\n";
+                cerr << "qpid-perftest pid " << pid << " hanging: killed.\n";
                 return false;
               }
           }
@@ -214,7 +214,7 @@ main ( int argc, char ** argv )
 
     sleep ( 3 );
 
-    /* Run all perftest iterations, and only then check for brokers 
+    /* Run all qpid-perftest iterations, and only then check for brokers
      * still being up.  If you just want a quick check for the failure 
      * mode in which a single iteration would kill all brokers except 
      * the client-connected one, just run it with the iterations arg
@@ -222,14 +222,14 @@ main ( int argc, char ** argv )
     */
     for ( int iteration = 0; iteration < n_iterations; ++ iteration ) {
         if ( ! runPerftest ( ) ) {
-            cerr << "Perftest " << iteration << " failed.\n";
+            cerr << "qpid-perftest " << iteration << " failed.\n";
             return 1;
         }
         if ( ! ( iteration % 10 ) ) {
-            cerr << "perftest " << iteration << " complete. -------------- \n";
+            cerr << "qpid-perftest " << iteration << " complete. -------------- \n";
         }
     }
-    cerr << "\nperftest " << n_iterations << " iterations complete. -------------- \n\n";
+    cerr << "\nqpid-perftest " << n_iterations << " iterations complete. -------------- \n\n";
 
     if ( ! allBrokersAreAlive ( brokers ) ) {
         cerr << "not all brokers are alive.\n";
diff --git a/qpid/cpp/src/tests/cluster_tests.py b/qpid/cpp/src/tests/cluster_tests.py
index 893fb99..f36cde9 100755
--- a/qpid/cpp/src/tests/cluster_tests.py
+++ b/qpid/cpp/src/tests/cluster_tests.py
@@ -211,7 +211,7 @@ class LongTests(BrokerTest):
             """Start ordinary clients for a broker. Start one client per broker.
             Round-robin on a colllection of different clients."""
             cmds=[
-                ["perftest", "--count", 50000,
+                ["qpid-perftest", "--count", 50000,
                  "--base-name", str(qpid.datatypes.uuid4()), "--port", broker.port()],
                 ["qpid-queue-stats", "-a", "localhost:%s" %(broker.port())],
                 ["testagent", "localhost", str(broker.port())] ]
diff --git a/qpid/cpp/src/tests/latencytest.cpp b/qpid/cpp/src/tests/latencytest.cpp
deleted file mode 100644
index 20eb456..0000000
--- a/qpid/cpp/src/tests/latencytest.cpp
+++ /dev/null
@@ -1,469 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-
-#include <algorithm>
-#include <limits>
-#include <iostream>
-#include <memory>
-#include <sstream>
-#include <vector>
-
-#include "TestOptions.h"
-#include "qpid/sys/Thread.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/Message.h"
-#include "qpid/client/AsyncSession.h"
-#include "qpid/client/SubscriptionManager.h"
-#include "qpid/sys/Time.h"
-
-using namespace qpid;
-using namespace qpid::client;
-using namespace qpid::sys;
-using std::string;
-
-namespace qpid {
-namespace tests {
-
-typedef std::vector<std::string> StringSet;
-
-struct Args : public qpid::TestOptions {
-    uint size;
-    uint count;
-    uint rate;
-    bool sync;
-    uint reportFrequency;
-    uint timeLimit;
-    uint concurrentConnections;
-    uint prefetch;
-    uint ack;
-    bool cumulative;
-    bool csv;
-    bool durable;
-    string base;
-    bool singleConnect;
-
-    Args() : size(256), count(1000), rate(0), reportFrequency(1000),
-	     timeLimit(0), concurrentConnections(1),
-             prefetch(100), ack(0),
-             durable(false), base("latency-test"), singleConnect(false)
-
-    {
-        addOptions()
-
-            ("size", optValue(size, "N"), "message size")
-            ("concurrentTests", optValue(concurrentConnections, "N"), "number of concurrent test setups, will create another publisher,\
- subcriber, queue, and connections")
-            ("single-connection", optValue(singleConnect, "yes|no"), "Use one connection for multiple sessions.")
-            ("count", optValue(count, "N"), "number of messages to send")
-            ("rate", optValue(rate, "N"), "target message rate (causes count to be ignored)")
-            ("sync", optValue(sync), "send messages synchronously")
-            ("report-frequency", optValue(reportFrequency, "N"),
-             "number of milliseconds to wait between reports (ignored unless rate specified)")
-            ("time-limit", optValue(timeLimit, "N"),
-             "test duration, in seconds")
-            ("prefetch", optValue(prefetch, "N"), "prefetch count (0 implies no flow control, and no acking)")
-            ("ack", optValue(ack, "N"), "Ack frequency in messages (defaults to half the prefetch value)")
-            ("durable", optValue(durable, "yes|no"), "use durable messages")
-            ("csv", optValue(csv), "print stats in csv format (rate,min,max,avg)")
-            ("cumulative", optValue(cumulative), "cumulative stats in csv format")
-            ("queue-base-name", optValue(base, "<name>"), "base name for queues");
-    }
-};
-
-const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
-
-Args opts;
-double c_min, c_avg, c_max;
-Connection globalConnection;
-
-uint64_t current_time()
-{
-    Duration t(EPOCH, now());
-    return t;
-}
-
-struct Stats
-{
-    Mutex lock;
-    uint count;
-    double minLatency;
-    double maxLatency;
-    double totalLatency;
-
-    Stats();
-    void update(double l);
-    void print();
-    void reset();
-};
-
-class Client : public Runnable
-{
-protected:
-    Connection* connection;
-    Connection localConnection;
-    AsyncSession session;
-    Thread thread;
-    string queue;
-
-public:
-    Client(const string& q);
-    virtual ~Client();
-
-    void start();
-    void join();
-    void run();
-    virtual void test() = 0;
-};
-
-class Receiver : public Client, public MessageListener
-{
-    SubscriptionManager mgr;
-    uint count;
-    Stats& stats;
-
-public:
-    Receiver(const string& queue, Stats& stats);
-    void test();
-    void received(Message& msg);
-    Stats getStats();
-    uint getCount() { return count; }
-    void stop() {  mgr.stop(); mgr.cancel(queue); }
-};
-
-
-class Sender : public Client
-{
-    string generateData(uint size);
-    void sendByRate();
-    void sendByCount();
-    Receiver& receiver;
-    const string data;
-
-public:
-    Sender(const string& queue, Receiver& receiver);
-    void test();
-};
-
-
-class Test
-{
-    const string queue;
-    Stats stats;
-    Receiver receiver;
-    Sender sender;
-    AbsTime begin;
-
-public:
-    Test(const string& q) : queue(q), receiver(queue, stats), sender(queue, receiver), begin(now()) {}
-    void start();
-    void join();
-    void report();
-};
-
-
-Client::Client(const string& q) : queue(q)
-{
-    if (opts.singleConnect){
-        connection = &globalConnection;
-        if (!globalConnection.isOpen()) opts.open(globalConnection);
-    }else{
-        connection = &localConnection;
-        opts.open(localConnection);
-    }
-    session = connection->newSession();
-}
-
-void Client::start()
-{
-    thread = Thread(this);
-}
-
-void Client::join()
-{
-    thread.join();
-}
-
-void Client::run()
-{
-    try{
-        test();
-    } catch(const std::exception& e) {
-        std::cout << "Error in receiver: " << e.what() << std::endl;
-    }
-}
-
-Client::~Client()
-{
-    try{
-        session.close();
-        connection->close();
-    } catch(const std::exception& e) {
-        std::cout << "Error in receiver: " << e.what() << std::endl;
-    }
-}
-
-Receiver::Receiver(const string& q, Stats& s) : Client(q), mgr(session), count(0), stats(s)
-{
-    session.queueDeclare(arg::queue=queue, arg::durable=opts.durable, arg::autoDelete=true);
-    uint msgCount = session.queueQuery(arg::queue=queue).get().getMessageCount();
-    if (msgCount) {
-        std::cout << "Warning: found " << msgCount << " msgs on " << queue << ". Purging..." << std::endl;
-        session.queuePurge(arg::queue=queue);
-        session.sync();
-    }
-    SubscriptionSettings settings;
-    if (opts.prefetch) {
-        settings.autoAck = (opts.ack ? opts.ack : (opts.prefetch / 2));
-        settings.flowControl = FlowControl::messageWindow(opts.prefetch);
-    } else {
-        settings.acceptMode = ACCEPT_MODE_NONE;
-        settings.flowControl = FlowControl::unlimited();
-    }
-    mgr.subscribe(*this, queue, settings);
-}
-
-void Receiver::test()
-{
-    mgr.run();
-    mgr.cancel(queue);
-}
-
-void Receiver::received(Message& msg)
-{
-    ++count;
-    uint64_t receivedAt = current_time();
-    uint64_t sentAt = msg.getDeliveryProperties().getTimestamp();
-
-    stats.update(((double) (receivedAt - sentAt)) / TIME_MSEC);
-
-    if (!opts.rate && count >= opts.count) {
-        mgr.stop();
-    }
-}
-
-void Stats::update(double latency)
-{
-    Mutex::ScopedLock l(lock);
-    count++;
-    minLatency = std::min(minLatency, latency);
-    maxLatency = std::max(maxLatency, latency);
-    totalLatency += latency;
-}
-
-Stats::Stats() : count(0), minLatency(std::numeric_limits<double>::max()), maxLatency(0), totalLatency(0) {}
-
-void Stats::print()
-{
-    static bool already_have_stats = false;
-    uint value;
-
-    if (opts.rate)
-        value = opts.rate;
-    else
-        value = opts.count;
-    Mutex::ScopedLock l(lock);
-    double aux_avg = (totalLatency / count);
-    if (!opts.cumulative) {
-        if (!opts.csv) {
-            if (count) {
-                std::cout << "Latency(ms): min=" << minLatency << ", max=" <<
-	                 maxLatency << ", avg=" << aux_avg;
-            } else {
-                std::cout << "Stalled: no samples for interval";
-            }
-        } else {
-            if (count) {
-          	    std::cout << value << "," << minLatency << "," << maxLatency <<
-    				     "," << aux_avg;
-            } else {
-          	    std::cout << value << "," << minLatency << "," << maxLatency <<
-    				     ", Stalled";
-            }
-        }
-    } else {
-       if (count) {
-            if (already_have_stats) {
-                c_avg = (c_min + aux_avg) / 2;
-                if (c_min > minLatency) c_min = minLatency;
-                if (c_max < maxLatency) c_max = maxLatency;
-            } else {
-                c_avg = aux_avg;
-                c_min = minLatency;
-                c_max = maxLatency;
-                already_have_stats = true;
-            }
-  	        std::cout << value << "," << c_min << "," << c_max <<
-    				     "," << c_avg;
-        } else {
-            std::cout << "Stalled: no samples for interval";
-        }
-    }
-}
-
-void Stats::reset()
-{
-    Mutex::ScopedLock l(lock);
-    count = 0;
-    totalLatency = maxLatency = 0;
-    minLatency = std::numeric_limits<double>::max();
-}
-
-Sender::Sender(const string& q, Receiver& receiver) : Client(q), receiver(receiver), data(generateData(opts.size)) {}
-
-void Sender::test()
-{
-    if (opts.rate) sendByRate();
-    else sendByCount();
-}
-
-void Sender::sendByCount()
-{
-    Message msg(data, queue);
-    if (opts.durable) {
-        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
-    }
-
-    for (uint i = 0; i < opts.count; i++) {
-        uint64_t sentAt(current_time());
-        msg.getDeliveryProperties().setTimestamp(sentAt);
-        async(session).messageTransfer(arg::content=msg, arg::acceptMode=1);
-        if (opts.sync) session.sync();
-    }
-    session.sync();
-}
-
-void Sender::sendByRate()
-{
-    Message msg(data, queue);
-    if (opts.durable) {
-        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
-    }
-    uint64_t interval = TIME_SEC/opts.rate;
-    int64_t timeLimit = opts.timeLimit * TIME_SEC;
-    uint64_t sent = 0, missedRate = 0;
-    AbsTime start = now();
-    while (true) {
-        AbsTime sentAt=now();
-        msg.getDeliveryProperties().setTimestamp(Duration(EPOCH, sentAt));
-        async(session).messageTransfer(arg::content=msg, arg::acceptMode=1);
-        if (opts.sync) session.sync();
-        ++sent;
-        AbsTime waitTill(start, sent*interval);
-        Duration delay(sentAt, waitTill);
-        if (delay < 0)
-            ++missedRate;
-        else
-            sys::usleep(delay / TIME_USEC);
-        if (timeLimit != 0 && Duration(start, now()) > timeLimit) {
-            session.sync();
-            receiver.stop();
-            break;
-        }
-    }
-}
-
-string Sender::generateData(uint size)
-{
-    if (size < chars.length()) {
-        return chars.substr(0, size);
-    }
-    std::string data;
-    for (uint i = 0; i < (size / chars.length()); i++) {
-        data += chars;
-    }
-    data += chars.substr(0, size % chars.length());
-    return data;
-}
-
-
-void Test::start()
-{
-    receiver.start();
-    begin = AbsTime(now());
-    sender.start();
-}
-
-void Test::join()
-{
-    sender.join();
-    receiver.join();
-    AbsTime end = now();
-    Duration time(begin, end);
-    double msecs(time / TIME_MSEC);
-    if (!opts.csv) {
-        std::cout << "Sent " << receiver.getCount() << " msgs through " << queue
-                  << " in " << msecs << "ms (" << (receiver.getCount() * 1000 / msecs) << " msgs/s) ";
-    }
-    stats.print();
-    std::cout << std::endl;
-}
-
-void Test::report()
-{
-    stats.print();
-    std::cout << std::endl;
-    stats.reset();
-}
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-int main(int argc, char** argv)
-{
-    try {
-        opts.parse(argc, argv);
-        if (opts.cumulative)
-            opts.csv = true;
-
-        Connection localConnection;
-        AsyncSession session;
-
-        boost::ptr_vector<Test> tests(opts.concurrentConnections);
-        for (uint i = 0; i < opts.concurrentConnections; i++) {
-            std::ostringstream out;
-            out << opts.base << "-" << (i+1);
-            tests.push_back(new Test(out.str()));
-        }
-        for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
-            i->start();
-        }
-        if (opts.rate && !opts.timeLimit) {
-            while (true) {
-                qpid::sys::usleep(opts.reportFrequency * 1000);
-                //print latency report:
-                for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
-                    i->report();
-                }
-            }
-        } else {
-            for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
-                i->join();
-            }
-        }
-
-        return 0;
-    } catch(const std::exception& e) {
-	std::cout << e.what() << std::endl;
-    }
-    return 1;
-}
diff --git a/qpid/cpp/src/tests/perftest.cpp b/qpid/cpp/src/tests/perftest.cpp
deleted file mode 100644
index 88d9fd1..0000000
--- a/qpid/cpp/src/tests/perftest.cpp
+++ /dev/null
@@ -1,741 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-#include "TestOptions.h"
-
-#include "qpid/client/AsyncSession.h"
-#include "qpid/client/SubscriptionManager.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/Completion.h"
-#include "qpid/client/Message.h"
-#include "qpid/framing/FieldTable.h"
-#include "qpid/sys/Time.h"
-#include "qpid/sys/Thread.h"
-
-#include <boost/lexical_cast.hpp>
-#include <boost/bind.hpp>
-#include <boost/function.hpp>
-#include <boost/ptr_container/ptr_vector.hpp>
-
-#include <iostream>
-#include <sstream>
-#include <numeric>
-#include <algorithm>
-#include <math.h>
-
-
-using namespace std;
-using namespace qpid;
-using namespace client;
-using namespace sys;
-using boost::lexical_cast;
-using boost::bind;
-
-namespace qpid {
-namespace tests {
-
-enum Mode { SHARED, FANOUT, TOPIC };
-const char* modeNames[] = { "shared", "fanout", "topic" };
-
-// istream/ostream ops so Options can read/display Mode.
-istream& operator>>(istream& in, Mode& mode) {
-    string s;
-    in >> s;
-    int i = find(modeNames, modeNames+3, s) - modeNames;
-    if (i >= 3)  throw Exception("Invalid mode: "+s);
-    mode = Mode(i);
-    return in;
-}
-
-ostream& operator<<(ostream& out, Mode mode) {
-    return out << modeNames[mode];
-}
-
-
-struct Opts : public TestOptions {
-
-    // Actions
-    bool setup, control, publish, subscribe;
-
-    // Queue policy
-    uint32_t queueMaxCount;
-    uint64_t queueMaxSize;
-    std::string baseName;
-    bool queueDurable;
-
-    // Publisher
-    size_t pubs;
-    size_t count ;
-    size_t size;
-    bool confirm;
-    bool durable;
-    bool uniqueData;
-    bool syncPub;
-
-    // Subscriber
-    size_t subs;
-    size_t ack;
-
-    // General
-    size_t qt;
-    bool singleConnect;
-    size_t iterations;
-    Mode mode;
-    bool summary;
-    uint32_t intervalSub;
-    uint32_t intervalPub;
-    size_t tx;
-    size_t txPub;
-    size_t txSub;
-    bool commitAsync;
-
-    static const std::string helpText;
-
-    Opts() :
-        TestOptions(helpText),
-        setup(false), control(false), publish(false), subscribe(false), baseName("perftest"),
-        pubs(1), count(500000), size(1024), confirm(true), durable(false), uniqueData(false), syncPub(false),
-        subs(1), ack(0),
-        qt(1),singleConnect(false), iterations(1), mode(SHARED), summary(false),
-        intervalSub(0), intervalPub(0), tx(0), txPub(0), txSub(0), commitAsync(false)
-    {
-        addOptions()
-            ("setup", optValue(setup), "Create shared queues.")
-            ("control", optValue(control), "Run test, print report.")
-            ("publish", optValue(publish), "Publish messages.")
-            ("subscribe", optValue(subscribe), "Subscribe for messages.")
-
-            ("mode", optValue(mode, "shared|fanout|topic"), "Test mode."
-             "\nshared: --qt queues, --npubs publishers and --nsubs subscribers per queue.\n"
-             "\nfanout: --npubs publishers, --nsubs subscribers, fanout exchange."
-             "\ntopic: --qt topics, --npubs publishers and --nsubs subscribers per topic.\n")
-
-            ("npubs", optValue(pubs, "N"), "Create N publishers.")
-            ("count", optValue(count, "N"), "Each publisher sends N messages.")
-            ("size", optValue(size, "BYTES"), "Size of messages in bytes.")
-            ("pub-confirm", optValue(confirm, "yes|no"), "Publisher use confirm-mode.")
-            ("durable", optValue(durable, "yes|no"), "Publish messages as durable.")
-            ("unique-data", optValue(uniqueData, "yes|no"), "Make data for each message unique.")
-            ("sync-publish", optValue(syncPub, "yes|no"), "Wait for confirmation of each message before sending the next one.")
-
-            ("nsubs", optValue(subs, "N"), "Create N subscribers.")
-            ("sub-ack", optValue(ack, "N"), "N>0: Subscriber acks batches of N.\n"
-             "N==0: Subscriber uses unconfirmed mode")
-
-            ("qt", optValue(qt, "N"), "Create N queues or topics.")
-            ("single-connection", optValue(singleConnect, "yes|no"), "Use one connection for multiple sessions.")
-
-            ("iterations", optValue(iterations, "N"), "Desired number of iterations of the test.")
-            ("summary,s", optValue(summary), "Summary output: pubs/sec subs/sec transfers/sec Mbytes/sec")
-
-            ("queue-max-count", optValue(queueMaxCount, "N"), "queue policy: count to trigger 'flow to disk'")
-            ("queue-max-size", optValue(queueMaxSize, "N"), "queue policy: accumulated size to trigger 'flow to disk'")
-            ("base-name", optValue(baseName, "NAME"), "base name used for queues or topics")
-            ("queue-durable", optValue(queueDurable, "N"), "Make queue durable (implied if durable set)")
-
-            ("interval_sub", optValue(intervalSub, "ms"), ">=0 delay between msg consume")
-            ("interval_pub", optValue(intervalPub, "ms"), ">=0 delay between msg publish")
-
-            ("tx", optValue(tx, "N"), "if non-zero, the transaction batch size for publishing and consuming")
-            ("pub-tx", optValue(txPub, "N"), "if non-zero, the transaction batch size for publishing")
-            ("async-commit", optValue(commitAsync, "yes|no"), "Don't wait for completion of commit")
-            ("sub-tx", optValue(txSub, "N"), "if non-zero, the transaction batch size for consuming");
-    }
-
-    // Computed values
-    size_t totalPubs;
-    size_t totalSubs;
-    size_t transfers;
-    size_t subQuota;
-
-    void parse(int argc, char** argv) {
-        TestOptions::parse(argc, argv);
-        switch (mode) {
-          case SHARED:
-            if (count % subs) {
-                count += subs - (count % subs);
-                cout << "WARNING: Adjusted --count to " << count
-                     << " the nearest multiple of --nsubs" << endl;
-            }
-            totalPubs = pubs*qt;
-            totalSubs = subs*qt;
-            subQuota = (pubs*count)/subs;
-            break;
-          case FANOUT:
-            if (qt != 1) cerr << "WARNING: Fanout mode, ignoring --qt="
-                              << qt << endl;
-            qt=1;
-            totalPubs = pubs;
-            totalSubs = subs;
-            subQuota = totalPubs*count;
-            break;
-          case TOPIC:
-            totalPubs = pubs*qt;
-            totalSubs = subs*qt;
-            subQuota = pubs*count;
-            break;
-        }
-        transfers=(totalPubs*count) + (totalSubs*subQuota);
-        if (tx) {
-            if (txPub) {
-                cerr << "WARNING: Using overriden tx value for publishers: " << txPub << std::endl;
-            } else {
-                txPub = tx;
-            }
-            if (txSub) {
-                cerr << "WARNING: Using overriden tx value for subscribers: " << txSub << std::endl;
-            } else {
-                txSub = tx;
-            }
-        }
-    }
-};
-
-const std::string Opts::helpText=
-"There are two ways to use perftest: single process or multi-process.\n\n"
-"If none of the --setup, --publish, --subscribe or --control options\n"
-"are given perftest will run a single-process test.\n"
-"For a  multi-process test first run:\n"
-"  perftest --setup <other options>\n"
-"and wait for it to complete. The remaining process should run concurrently::\n"
-"Run --npubs times: perftest --publish <other options>\n"
-"Run --nsubs times: perftest --subscribe <other options>\n"
-"Run once:          perftest --control <other options>\n"
-"Note the <other options> must be identical for all processes.\n";
-
-Opts opts;
-Connection globalConnection;
-
-std::string fqn(const std::string& name)
-{
-    ostringstream fqn;
-    fqn << opts.baseName << "_" << name;
-    return fqn.str();
-}
-
-struct Client : public Runnable {
-    Connection* connection;
-    Connection localConnection;
-    AsyncSession session;
-    Thread thread;
-
-    Client() {
-        if (opts.singleConnect){
-            connection = &globalConnection;
-            if (!globalConnection.isOpen()) opts.open(globalConnection);
-        }else{
-            connection = &localConnection;
-            opts.open(localConnection);
-        }
-        session = connection->newSession();
-    }
-
-    ~Client() {
-        try {
-            if (connection->isOpen()) {
-                session.close();
-                connection->close();
-            }
-        } catch (const std::exception& e) {
-            std::cerr << "Error in shutdown: " << e.what() << std::endl;
-        }
-    }
-};
-
-struct Setup : public Client {
-
-    void queueInit(string name, bool durable=false, const framing::FieldTable& settings=framing::FieldTable()) {
-        session.queueDeclare(arg::queue=name, arg::durable=durable, arg::arguments=settings);
-        session.queuePurge(arg::queue=name);
-        session.sync();
-    }
-
-    void run() {
-        queueInit(fqn("pub_start"));
-        queueInit(fqn("pub_done"));
-        queueInit(fqn("sub_ready"));
-        queueInit(fqn("sub_done"));
-        if (opts.iterations > 1) queueInit(fqn("sub_iteration"));
-        if (opts.mode==SHARED) {
-            framing::FieldTable settings;//queue policy settings
-            settings.setInt("qpid.max_count", opts.queueMaxCount);
-            settings.setInt("qpid.max_size", opts.queueMaxSize);
-            for (size_t i = 0; i < opts.qt; ++i) {
-                ostringstream qname;
-                qname << opts.baseName << i;
-                queueInit(qname.str(), opts.durable || opts.queueDurable, settings);
-            }
-        }
-    }
-};
-
-void expect(string actual, string expect) {
-    if (expect != actual)
-        throw Exception("Expecting "+expect+" but received "+actual);
-
-}
-
-double secs(Duration d) { return double(d)/TIME_SEC; }
-double secs(AbsTime start, AbsTime finish) {
-    return secs(Duration(start,finish));
-}
-
-
-// Collect rates & print stats.
-class Stats {
-    vector<double> values;
-    double sum;
-
-  public:
-    Stats() : sum(0) {}
-
-    // Functor to collect rates.
-    void operator()(const string& data) {
-        try {
-            double d=lexical_cast<double>(data);
-            values.push_back(d);
-            sum += d;
-        } catch (const std::exception&) {
-            throw Exception("Bad report: "+data);
-        }
-    }
-
-    double mean() const {
-        return sum/values.size();
-    }
-
-    double stdev() const {
-        if (values.size() <= 1) return 0;
-        double avg = mean();
-        double ssq = 0;
-        for (vector<double>::const_iterator i = values.begin();
-             i != values.end(); ++i) {
-            double x=*i;
-            x -= avg;
-            ssq += x*x;
-        }
-        return sqrt(ssq/(values.size()-1));
-    }
-
-    ostream& print(ostream& out) {
-        ostream_iterator<double> o(out, "\n");
-        copy(values.begin(), values.end(), o);
-        out << "Average: " << mean();
-        if (values.size() > 1)
-            out << " (std.dev. " << stdev() << ")";
-        return out << endl;
-    }
-};
-
-
-// Manage control queues, collect and print reports.
-struct Controller : public Client {
-
-   SubscriptionManager subs;
-
-    Controller() : subs(session) {}
-
-    /** Process messages from queue by applying a functor. */
-    void process(size_t n, string queue,
-                 boost::function<void (const string&)> msgFn)
-    {
-        if (!opts.summary)
-            cout << "Processing " << n << " messages from "
-                 << queue << " " << flush;
-        LocalQueue lq;
-        subs.setFlowControl(n, SubscriptionManager::UNLIMITED, false);
-        subs.subscribe(lq, queue);
-        for (size_t i = 0; i < n; ++i) {
-            if (!opts.summary) cout << "." << flush;
-            msgFn(lq.pop().getData());
-        }
-        if (!opts.summary) cout << " done." << endl;
-    }
-
-    void process(size_t n, LocalQueue lq, string queue,
-                 boost::function<void (const string&)> msgFn)
-    {
-        session.messageFlow(queue, 0, n);
-        if (!opts.summary)
-            cout << "Processing " << n << " messages from "
-                 << queue << " " << flush;
-        for (size_t i = 0; i < n; ++i) {
-            if (!opts.summary) cout << "." << flush;
-            msgFn(lq.pop().getData());
-        }
-        if (!opts.summary) cout << " done." << endl;
-    }
-
-    void send(size_t n, string queue, string data) {
-        if (!opts.summary)
-            cout << "Sending " << data << " " << n << " times to " << queue
-                 << endl;
-        Message msg(data, queue);
-        for (size_t i = 0; i < n; ++i)
-            session.messageTransfer(arg::content=msg, arg::acceptMode=1);
-    }
-
-    void run() {                // Controller
-        try {
-            // Wait for subscribers to be ready.
-            process(opts.totalSubs, fqn("sub_ready"), bind(expect, _1, "ready"));
-
-            LocalQueue pubDone;
-            LocalQueue subDone;
-            subs.setFlowControl(0, SubscriptionManager::UNLIMITED, false);
-            subs.subscribe(pubDone, fqn("pub_done"));
-            subs.subscribe(subDone, fqn("sub_done"));
-
-            double txrateTotal(0);
-            double mbytesTotal(0);
-            double pubRateTotal(0);
-            double subRateTotal(0);
-
-            for (size_t j = 0; j < opts.iterations; ++j) {
-                AbsTime start=now();
-                send(opts.totalPubs, fqn("pub_start"), "start"); // Start publishers
-                if (j) {
-		    send(opts.totalPubs, fqn("sub_iteration"), "next"); // Start subscribers on next iteration
-                }
-
-                Stats pubRates;
-                Stats subRates;
-
-                process(opts.totalPubs, pubDone, fqn("pub_done"), boost::ref(pubRates));
-                process(opts.totalSubs, subDone, fqn("sub_done"), boost::ref(subRates));
-
-                AbsTime end=now();
-
-                double time=secs(start, end);
-                double txrate=opts.transfers/time;
-                double mbytes=(txrate*opts.size)/(1024*1024);
-
-                if (!opts.summary) {
-                    cout << endl << "Total " << opts.transfers << " transfers of "
-                         << opts.size << " bytes in "
-                         << time << " seconds." << endl;
-                    cout << endl << "Publish transfers/sec:    " << endl;
-                    pubRates.print(cout);
-                    cout << endl << "Subscribe transfers/sec:  " << endl;
-                    subRates.print(cout);
-                    cout << endl
-                         << "Total transfers/sec:      " << txrate << endl
-                         << "Total Mbytes/sec: " << mbytes << endl;
-                }
-                else {
-                    cout << pubRates.mean() << "\t"
-                         << subRates.mean() << "\t"
-                         << txrate << "\t"
-                         << mbytes << endl;
-                }
-
-                txrateTotal += txrate;
-                mbytesTotal += mbytes;
-                pubRateTotal += pubRates.mean();
-                subRateTotal += subRates.mean();
-            }
-            if (opts.iterations > 1) {
-                cout << "Averages: "<< endl
-                     << (pubRateTotal / opts.iterations) << "\t"
-                     << (subRateTotal / opts.iterations) << "\t"
-                     << (txrateTotal / opts.iterations) << "\t"
-                     << (mbytesTotal / opts.iterations) << endl;
-            }
-        }
-        catch (const std::exception& e) {
-            cout << "Controller exception: " << e.what() << endl;
-        }
-    }
-};
-
-
-struct PublishThread : public Client {
-    string destination;
-    string routingKey;
-
-    PublishThread() {};
-
-    PublishThread(string key, string dest=string()) {
-        destination=dest;
-        routingKey=key;
-    }
-
-    void run() {                // Publisher
-        try {
-            string data;
-            size_t offset(0);
-            if (opts.uniqueData) {
-                offset = 5;
-                data += "data:";//marker (requested for latency testing tool scripts)
-                data += string(sizeof(size_t), 'X');//space for seq no
-                data += session.getId().str();
-                if (opts.size > data.size()) {
-                    data += string(opts.size - data.size(), 'X');
-                } else if(opts.size < data.size()) {
-                    cout << "WARNING: Increased --size to " << data.size()
-                         << " to honour --unique-data" << endl;
-                }
-            } else {
-                size_t msgSize=max(opts.size, sizeof(size_t));
-                data = string(msgSize, 'X');
-            }
-
-            Message msg(data, routingKey);
-            if (opts.durable)
-                msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
-
-
-            if (opts.txPub){
-                session.txSelect();
-            }
-            SubscriptionManager subs(session);
-            LocalQueue lq;
-            subs.setFlowControl(1, SubscriptionManager::UNLIMITED, true);
-            subs.subscribe(lq, fqn("pub_start"));
-
-            for (size_t j = 0; j < opts.iterations; ++j) {
-                expect(lq.pop().getData(), "start");
-                AbsTime start=now();
-                for (size_t i=0; i<opts.count; i++) {
-                    // Stamp the iteration into the message data, avoid
-                    // any heap allocation.
-                    const_cast<std::string&>(msg.getData()).replace(offset, sizeof(size_t),
-                                          reinterpret_cast<const char*>(&i), sizeof(size_t));
-                    if (opts.syncPub) {
-                        sync(session).messageTransfer(
-                            arg::destination=destination,
-                            arg::content=msg,
-                            arg::acceptMode=1);
-                    } else {
-                        session.messageTransfer(
-                            arg::destination=destination,
-                            arg::content=msg,
-                            arg::acceptMode=1);
-                    }
-                    if (opts.txPub && ((i+1) % opts.txPub == 0)){
-                        if (opts.commitAsync){
-                            session.txCommit();
-                        } else {
-                            sync(session).txCommit();
-                        }
-                    }
-                    if (opts.intervalPub)
-                        qpid::sys::usleep(opts.intervalPub*1000);
-                }
-                if (opts.confirm) session.sync();
-                AbsTime end=now();
-                double time=secs(start,end);
-
-                // Send result to controller.
-                Message report(lexical_cast<string>(opts.count/time), fqn("pub_done"));
-                session.messageTransfer(arg::content=report, arg::acceptMode=1);
-                if (opts.txPub){
-                    sync(session).txCommit();
-                }
-            }
-            session.close();
-        }
-        catch (const std::exception& e) {
-            cout << "PublishThread exception: " << e.what() << endl;
-        }
-    }
-};
-
-struct SubscribeThread : public Client {
-
-    string queue;
-
-    SubscribeThread() {}
-
-    SubscribeThread(string q) { queue = q; }
-
-    SubscribeThread(string key, string ex) {
-        queue=session.getId().str(); // Unique name.
-        session.queueDeclare(arg::queue=queue,
-                             arg::exclusive=true,
-                             arg::autoDelete=true,
-                             arg::durable=opts.durable);
-        session.exchangeBind(arg::queue=queue,
-                             arg::exchange=ex,
-                             arg::bindingKey=key);
-    }
-
-    void verify(bool cond, const char* test, uint32_t expect, uint32_t actual) {
-        if (!cond) {
-            Message error(
-                QPID_MSG("Sequence error: expected  n" << test << expect << " but got " << actual),
-                "sub_done");
-            session.messageTransfer(arg::content=error, arg::acceptMode=1);
-            throw Exception(error.getData());
-        }
-    }
-
-    void run() {                // Subscribe
-        try {
-            if (opts.txSub) sync(session).txSelect();
-            SubscriptionManager subs(session);
-            SubscriptionSettings settings;
-            settings.autoAck = opts.txSub ? opts.txSub : opts.ack;
-            settings.acceptMode = (opts.txSub || opts.ack ? ACCEPT_MODE_EXPLICIT : ACCEPT_MODE_NONE);
-            settings.flowControl = FlowControl::messageCredit(opts.subQuota);
-            LocalQueue lq;
-            Subscription subscription = subs.subscribe(lq, queue, settings);
-            // Notify controller we are ready.
-            session.messageTransfer(arg::content=Message("ready", fqn("sub_ready")), arg::acceptMode=1);
-            if (opts.txSub) {
-                if (opts.commitAsync) session.txCommit();
-                else sync(session).txCommit();
-            }
-
-            LocalQueue iterationControl;
-            if (opts.iterations > 1) {
-                subs.subscribe(iterationControl, fqn("sub_iteration"), SubscriptionSettings(FlowControl::messageCredit(0)));
-            }
-
-            for (size_t j = 0; j < opts.iterations; ++j) {
-                if (j > 0) {
-                    //need to wait here until all subs are done
-                    session.messageFlow(fqn("sub_iteration"), 0, 1);
-                    iterationControl.pop();
-
-                    //need to allocate some more credit for subscription
-                    session.messageFlow(queue, 0, opts.subQuota);
-                }
-                Message msg;
-                AbsTime start=now();
-                size_t expect=0;
-                for (size_t i = 0; i < opts.subQuota; ++i) {
-                    msg=lq.pop();
-                    if (opts.txSub && ((i+1) % opts.txSub == 0)) {
-                        if (opts.commitAsync) session.txCommit();
-                        else sync(session).txCommit();
-                    }
-                    if (opts.intervalSub)
-                        qpid::sys::usleep(opts.intervalSub*1000);
-                    // TODO aconway 2007-11-23: check message order for.
-                    // multiple publishers. Need an array of counters,
-                    // one per publisher and a publisher ID in the
-                    // message. Careful not to introduce a lot of overhead
-                    // here, e.g. no std::map, std::string etc.
-                    //
-                    // For now verify order only for a single publisher.
-                    size_t offset = opts.uniqueData ? 5 /*marker is 'data:'*/ : 0;
-                    size_t n = *reinterpret_cast<const size_t*>(msg.getData().data() + offset);
-                    if (opts.pubs == 1) {
-                        if (opts.subs == 1 || opts.mode == FANOUT) verify(n==expect, "==", expect, n);
-                        else verify(n>=expect, ">=", expect, n);
-                        expect = n+1;
-                    }
-                }
-                if (opts.txSub || opts.ack)
-                    subscription.accept(subscription.getUnaccepted());
-                if (opts.txSub) {
-                    if (opts.commitAsync) session.txCommit();
-                    else sync(session).txCommit();
-                }
-                AbsTime end=now();
-
-                // Report to publisher.
-                Message result(lexical_cast<string>(opts.subQuota/secs(start,end)),
-                               fqn("sub_done"));
-                session.messageTransfer(arg::content=result, arg::acceptMode=1);
-                if (opts.txSub) sync(session).txCommit();
-            }
-            session.close();
-        }
-        catch (const std::exception& e) {
-            cout << "SubscribeThread exception: " << e.what() << endl;
-        }
-    }
-};
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-int main(int argc, char** argv) {
-    int exitCode = 0;
-    boost::ptr_vector<Client> subs(opts.subs);
-    boost::ptr_vector<Client> pubs(opts.pubs);
-
-    try {
-        opts.parse(argc, argv);
-
-        string exchange;
-        switch (opts.mode) {
-            case FANOUT: exchange="amq.fanout"; break;
-            case TOPIC: exchange="amq.topic"; break;
-            case SHARED: break;
-        }
-
-        bool singleProcess=
-            (!opts.setup && !opts.control && !opts.publish && !opts.subscribe);
-        if (singleProcess)
-            opts.setup = opts.control = opts.publish = opts.subscribe = true;
-
-        if (opts.setup) Setup().run();          // Set up queues
-
-        // Start pubs/subs for each queue/topic.
-        for (size_t i = 0; i < opts.qt; ++i) {
-            ostringstream key;
-            key << opts.baseName << i; // Queue or topic name.
-            if (opts.publish) {
-                size_t n = singleProcess ? opts.pubs : 1;
-                for (size_t j = 0; j < n; ++j)  {
-                    pubs.push_back(new PublishThread(key.str(), exchange));
-                    pubs.back().thread=Thread(pubs.back());
-                }
-            }
-            if (opts.subscribe) {
-                size_t n = singleProcess ? opts.subs : 1;
-                for (size_t j = 0; j < n; ++j)  {
-                    if (opts.mode==SHARED)
-                        subs.push_back(new SubscribeThread(key.str()));
-                    else
-                        subs.push_back(new SubscribeThread(key.str(),exchange));
-                    subs.back().thread=Thread(subs.back());
-                }
-            }
-        }
-
-        if (opts.control) Controller().run();
-    }
-    catch (const std::exception& e) {
-        cout << endl << e.what() << endl;
-        exitCode = 1;
-    }
-
-    // Wait for started threads.
-    if (opts.publish) {
-        for (boost::ptr_vector<Client>::iterator i=pubs.begin();
-             i != pubs.end();
-             ++i)
-            i->thread.join();
-    }
-
-    if (opts.subscribe) {
-        for (boost::ptr_vector<Client>::iterator i=subs.begin();
-             i != subs.end();
-             ++i)
-            i->thread.join();
-    }
-    return exitCode;
-}
diff --git a/qpid/cpp/src/tests/qpid-client-test.cpp b/qpid/cpp/src/tests/qpid-client-test.cpp
new file mode 100644
index 0000000..2f5e8e5
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-client-test.cpp
@@ -0,0 +1,139 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+/**
+ * This file provides a simple test (and example) of basic
+ * functionality including declaring an exchange and a queue, binding
+ * these together, publishing a message and receiving that message
+ * asynchronously.
+ */
+
+#include <iostream>
+
+#include "TestOptions.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/Message.h"
+#include "qpid/client/Session.h"
+#include "qpid/client/SubscriptionManager.h"
+
+
+using namespace qpid;
+using namespace qpid::client;
+using namespace qpid::framing;
+using std::string;
+
+namespace qpid {
+namespace tests {
+
+struct Args : public TestOptions {
+    uint msgSize;
+    bool verbose;
+
+    Args() : TestOptions("Simple test of Qpid c++ client; sends and receives a single message."), msgSize(26)
+    {
+        addOptions()
+            ("size", optValue(msgSize, "N"), "message size")
+            ("verbose", optValue(verbose), "print out some status messages");
+    }
+};
+
+const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
+
+std::string generateData(uint size)
+{
+    if (size < chars.length()) {
+        return chars.substr(0, size);
+    }
+    std::string data;
+    for (uint i = 0; i < (size / chars.length()); i++) {
+        data += chars;
+    }
+    data += chars.substr(0, size % chars.length());
+    return data;
+}
+
+void print(const std::string& text, const Message& msg)
+{
+    std::cout << text;
+    if (msg.getData().size() > 16) {
+        std::cout << msg.getData().substr(0, 16) << "...";
+    } else {
+        std::cout << msg.getData();
+    }
+    std::cout << std::endl;
+}
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+int main(int argc, char** argv)
+{
+    try {
+        Args opts;
+        opts.parse(argc, argv);
+
+        //Connect to the broker:
+        Connection connection;
+        opts.open(connection);
+	if (opts.verbose) std::cout << "Opened connection." << std::endl;
+
+        //Create and open a session on the connection through which
+        //most functionality is exposed:
+        Session session = connection.newSession();
+	if (opts.verbose) std::cout << "Opened session." << std::endl;
+
+
+        //'declare' the exchange and the queue, which will create them
+        //as they don't exist
+	session.exchangeDeclare(arg::exchange="MyExchange", arg::type="direct");
+	if (opts.verbose) std::cout << "Declared exchange." << std::endl;
+	session.queueDeclare(arg::queue="MyQueue", arg::autoDelete=true, arg::exclusive=true);
+	if (opts.verbose) std::cout << "Declared queue." << std::endl;
+
+        //now bind the queue to the exchange
+	session.exchangeBind(arg::exchange="MyExchange", arg::queue="MyQueue", arg::bindingKey="MyKey");
+	if (opts.verbose) std::cout << "Bound queue to exchange." << std::endl;
+
+        //create and send a message to the exchange using the routing
+        //key we bound our queue with:
+	Message msgOut(generateData(opts.msgSize));
+        msgOut.getDeliveryProperties().setRoutingKey("MyKey");
+        session.messageTransfer(arg::destination="MyExchange", arg::content=msgOut, arg::acceptMode=1);
+	if (opts.verbose) print("Published message: ", msgOut);
+
+        // Using the SubscriptionManager, get the message from the queue.
+        SubscriptionManager subs(session);
+        Message msgIn = subs.get("MyQueue");
+        if (msgIn.getData() == msgOut.getData())
+            if (opts.verbose) std::cout << "Received the exepected message." << std::endl;
+
+        //close the session & connection
+	session.close();
+	if (opts.verbose) std::cout << "Closed session." << std::endl;
+	connection.close();
+	if (opts.verbose) std::cout << "Closed connection." << std::endl;
+        return 0;
+    } catch(const std::exception& e) {
+	std::cout << e.what() << std::endl;
+    }
+    return 1;
+}
diff --git a/qpid/cpp/src/tests/qpid-latency-test.cpp b/qpid/cpp/src/tests/qpid-latency-test.cpp
new file mode 100644
index 0000000..20eb456
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-latency-test.cpp
@@ -0,0 +1,469 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+
+#include <algorithm>
+#include <limits>
+#include <iostream>
+#include <memory>
+#include <sstream>
+#include <vector>
+
+#include "TestOptions.h"
+#include "qpid/sys/Thread.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/Message.h"
+#include "qpid/client/AsyncSession.h"
+#include "qpid/client/SubscriptionManager.h"
+#include "qpid/sys/Time.h"
+
+using namespace qpid;
+using namespace qpid::client;
+using namespace qpid::sys;
+using std::string;
+
+namespace qpid {
+namespace tests {
+
+typedef std::vector<std::string> StringSet;
+
+struct Args : public qpid::TestOptions {
+    uint size;
+    uint count;
+    uint rate;
+    bool sync;
+    uint reportFrequency;
+    uint timeLimit;
+    uint concurrentConnections;
+    uint prefetch;
+    uint ack;
+    bool cumulative;
+    bool csv;
+    bool durable;
+    string base;
+    bool singleConnect;
+
+    Args() : size(256), count(1000), rate(0), reportFrequency(1000),
+	     timeLimit(0), concurrentConnections(1),
+             prefetch(100), ack(0),
+             durable(false), base("latency-test"), singleConnect(false)
+
+    {
+        addOptions()
+
+            ("size", optValue(size, "N"), "message size")
+            ("concurrentTests", optValue(concurrentConnections, "N"), "number of concurrent test setups, will create another publisher,\
+ subcriber, queue, and connections")
+            ("single-connection", optValue(singleConnect, "yes|no"), "Use one connection for multiple sessions.")
+            ("count", optValue(count, "N"), "number of messages to send")
+            ("rate", optValue(rate, "N"), "target message rate (causes count to be ignored)")
+            ("sync", optValue(sync), "send messages synchronously")
+            ("report-frequency", optValue(reportFrequency, "N"),
+             "number of milliseconds to wait between reports (ignored unless rate specified)")
+            ("time-limit", optValue(timeLimit, "N"),
+             "test duration, in seconds")
+            ("prefetch", optValue(prefetch, "N"), "prefetch count (0 implies no flow control, and no acking)")
+            ("ack", optValue(ack, "N"), "Ack frequency in messages (defaults to half the prefetch value)")
+            ("durable", optValue(durable, "yes|no"), "use durable messages")
+            ("csv", optValue(csv), "print stats in csv format (rate,min,max,avg)")
+            ("cumulative", optValue(cumulative), "cumulative stats in csv format")
+            ("queue-base-name", optValue(base, "<name>"), "base name for queues");
+    }
+};
+
+const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
+
+Args opts;
+double c_min, c_avg, c_max;
+Connection globalConnection;
+
+uint64_t current_time()
+{
+    Duration t(EPOCH, now());
+    return t;
+}
+
+struct Stats
+{
+    Mutex lock;
+    uint count;
+    double minLatency;
+    double maxLatency;
+    double totalLatency;
+
+    Stats();
+    void update(double l);
+    void print();
+    void reset();
+};
+
+class Client : public Runnable
+{
+protected:
+    Connection* connection;
+    Connection localConnection;
+    AsyncSession session;
+    Thread thread;
+    string queue;
+
+public:
+    Client(const string& q);
+    virtual ~Client();
+
+    void start();
+    void join();
+    void run();
+    virtual void test() = 0;
+};
+
+class Receiver : public Client, public MessageListener
+{
+    SubscriptionManager mgr;
+    uint count;
+    Stats& stats;
+
+public:
+    Receiver(const string& queue, Stats& stats);
+    void test();
+    void received(Message& msg);
+    Stats getStats();
+    uint getCount() { return count; }
+    void stop() {  mgr.stop(); mgr.cancel(queue); }
+};
+
+
+class Sender : public Client
+{
+    string generateData(uint size);
+    void sendByRate();
+    void sendByCount();
+    Receiver& receiver;
+    const string data;
+
+public:
+    Sender(const string& queue, Receiver& receiver);
+    void test();
+};
+
+
+class Test
+{
+    const string queue;
+    Stats stats;
+    Receiver receiver;
+    Sender sender;
+    AbsTime begin;
+
+public:
+    Test(const string& q) : queue(q), receiver(queue, stats), sender(queue, receiver), begin(now()) {}
+    void start();
+    void join();
+    void report();
+};
+
+
+Client::Client(const string& q) : queue(q)
+{
+    if (opts.singleConnect){
+        connection = &globalConnection;
+        if (!globalConnection.isOpen()) opts.open(globalConnection);
+    }else{
+        connection = &localConnection;
+        opts.open(localConnection);
+    }
+    session = connection->newSession();
+}
+
+void Client::start()
+{
+    thread = Thread(this);
+}
+
+void Client::join()
+{
+    thread.join();
+}
+
+void Client::run()
+{
+    try{
+        test();
+    } catch(const std::exception& e) {
+        std::cout << "Error in receiver: " << e.what() << std::endl;
+    }
+}
+
+Client::~Client()
+{
+    try{
+        session.close();
+        connection->close();
+    } catch(const std::exception& e) {
+        std::cout << "Error in receiver: " << e.what() << std::endl;
+    }
+}
+
+Receiver::Receiver(const string& q, Stats& s) : Client(q), mgr(session), count(0), stats(s)
+{
+    session.queueDeclare(arg::queue=queue, arg::durable=opts.durable, arg::autoDelete=true);
+    uint msgCount = session.queueQuery(arg::queue=queue).get().getMessageCount();
+    if (msgCount) {
+        std::cout << "Warning: found " << msgCount << " msgs on " << queue << ". Purging..." << std::endl;
+        session.queuePurge(arg::queue=queue);
+        session.sync();
+    }
+    SubscriptionSettings settings;
+    if (opts.prefetch) {
+        settings.autoAck = (opts.ack ? opts.ack : (opts.prefetch / 2));
+        settings.flowControl = FlowControl::messageWindow(opts.prefetch);
+    } else {
+        settings.acceptMode = ACCEPT_MODE_NONE;
+        settings.flowControl = FlowControl::unlimited();
+    }
+    mgr.subscribe(*this, queue, settings);
+}
+
+void Receiver::test()
+{
+    mgr.run();
+    mgr.cancel(queue);
+}
+
+void Receiver::received(Message& msg)
+{
+    ++count;
+    uint64_t receivedAt = current_time();
+    uint64_t sentAt = msg.getDeliveryProperties().getTimestamp();
+
+    stats.update(((double) (receivedAt - sentAt)) / TIME_MSEC);
+
+    if (!opts.rate && count >= opts.count) {
+        mgr.stop();
+    }
+}
+
+void Stats::update(double latency)
+{
+    Mutex::ScopedLock l(lock);
+    count++;
+    minLatency = std::min(minLatency, latency);
+    maxLatency = std::max(maxLatency, latency);
+    totalLatency += latency;
+}
+
+Stats::Stats() : count(0), minLatency(std::numeric_limits<double>::max()), maxLatency(0), totalLatency(0) {}
+
+void Stats::print()
+{
+    static bool already_have_stats = false;
+    uint value;
+
+    if (opts.rate)
+        value = opts.rate;
+    else
+        value = opts.count;
+    Mutex::ScopedLock l(lock);
+    double aux_avg = (totalLatency / count);
+    if (!opts.cumulative) {
+        if (!opts.csv) {
+            if (count) {
+                std::cout << "Latency(ms): min=" << minLatency << ", max=" <<
+	                 maxLatency << ", avg=" << aux_avg;
+            } else {
+                std::cout << "Stalled: no samples for interval";
+            }
+        } else {
+            if (count) {
+          	    std::cout << value << "," << minLatency << "," << maxLatency <<
+    				     "," << aux_avg;
+            } else {
+          	    std::cout << value << "," << minLatency << "," << maxLatency <<
+    				     ", Stalled";
+            }
+        }
+    } else {
+       if (count) {
+            if (already_have_stats) {
+                c_avg = (c_min + aux_avg) / 2;
+                if (c_min > minLatency) c_min = minLatency;
+                if (c_max < maxLatency) c_max = maxLatency;
+            } else {
+                c_avg = aux_avg;
+                c_min = minLatency;
+                c_max = maxLatency;
+                already_have_stats = true;
+            }
+  	        std::cout << value << "," << c_min << "," << c_max <<
+    				     "," << c_avg;
+        } else {
+            std::cout << "Stalled: no samples for interval";
+        }
+    }
+}
+
+void Stats::reset()
+{
+    Mutex::ScopedLock l(lock);
+    count = 0;
+    totalLatency = maxLatency = 0;
+    minLatency = std::numeric_limits<double>::max();
+}
+
+Sender::Sender(const string& q, Receiver& receiver) : Client(q), receiver(receiver), data(generateData(opts.size)) {}
+
+void Sender::test()
+{
+    if (opts.rate) sendByRate();
+    else sendByCount();
+}
+
+void Sender::sendByCount()
+{
+    Message msg(data, queue);
+    if (opts.durable) {
+        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
+    }
+
+    for (uint i = 0; i < opts.count; i++) {
+        uint64_t sentAt(current_time());
+        msg.getDeliveryProperties().setTimestamp(sentAt);
+        async(session).messageTransfer(arg::content=msg, arg::acceptMode=1);
+        if (opts.sync) session.sync();
+    }
+    session.sync();
+}
+
+void Sender::sendByRate()
+{
+    Message msg(data, queue);
+    if (opts.durable) {
+        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
+    }
+    uint64_t interval = TIME_SEC/opts.rate;
+    int64_t timeLimit = opts.timeLimit * TIME_SEC;
+    uint64_t sent = 0, missedRate = 0;
+    AbsTime start = now();
+    while (true) {
+        AbsTime sentAt=now();
+        msg.getDeliveryProperties().setTimestamp(Duration(EPOCH, sentAt));
+        async(session).messageTransfer(arg::content=msg, arg::acceptMode=1);
+        if (opts.sync) session.sync();
+        ++sent;
+        AbsTime waitTill(start, sent*interval);
+        Duration delay(sentAt, waitTill);
+        if (delay < 0)
+            ++missedRate;
+        else
+            sys::usleep(delay / TIME_USEC);
+        if (timeLimit != 0 && Duration(start, now()) > timeLimit) {
+            session.sync();
+            receiver.stop();
+            break;
+        }
+    }
+}
+
+string Sender::generateData(uint size)
+{
+    if (size < chars.length()) {
+        return chars.substr(0, size);
+    }
+    std::string data;
+    for (uint i = 0; i < (size / chars.length()); i++) {
+        data += chars;
+    }
+    data += chars.substr(0, size % chars.length());
+    return data;
+}
+
+
+void Test::start()
+{
+    receiver.start();
+    begin = AbsTime(now());
+    sender.start();
+}
+
+void Test::join()
+{
+    sender.join();
+    receiver.join();
+    AbsTime end = now();
+    Duration time(begin, end);
+    double msecs(time / TIME_MSEC);
+    if (!opts.csv) {
+        std::cout << "Sent " << receiver.getCount() << " msgs through " << queue
+                  << " in " << msecs << "ms (" << (receiver.getCount() * 1000 / msecs) << " msgs/s) ";
+    }
+    stats.print();
+    std::cout << std::endl;
+}
+
+void Test::report()
+{
+    stats.print();
+    std::cout << std::endl;
+    stats.reset();
+}
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+int main(int argc, char** argv)
+{
+    try {
+        opts.parse(argc, argv);
+        if (opts.cumulative)
+            opts.csv = true;
+
+        Connection localConnection;
+        AsyncSession session;
+
+        boost::ptr_vector<Test> tests(opts.concurrentConnections);
+        for (uint i = 0; i < opts.concurrentConnections; i++) {
+            std::ostringstream out;
+            out << opts.base << "-" << (i+1);
+            tests.push_back(new Test(out.str()));
+        }
+        for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
+            i->start();
+        }
+        if (opts.rate && !opts.timeLimit) {
+            while (true) {
+                qpid::sys::usleep(opts.reportFrequency * 1000);
+                //print latency report:
+                for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
+                    i->report();
+                }
+            }
+        } else {
+            for (boost::ptr_vector<Test>::iterator i = tests.begin(); i != tests.end(); i++) {
+                i->join();
+            }
+        }
+
+        return 0;
+    } catch(const std::exception& e) {
+	std::cout << e.what() << std::endl;
+    }
+    return 1;
+}
diff --git a/qpid/cpp/src/tests/qpid-perftest.cpp b/qpid/cpp/src/tests/qpid-perftest.cpp
new file mode 100644
index 0000000..7058851
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-perftest.cpp
@@ -0,0 +1,741 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+#include "TestOptions.h"
+
+#include "qpid/client/AsyncSession.h"
+#include "qpid/client/SubscriptionManager.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/Completion.h"
+#include "qpid/client/Message.h"
+#include "qpid/framing/FieldTable.h"
+#include "qpid/sys/Time.h"
+#include "qpid/sys/Thread.h"
+
+#include <boost/lexical_cast.hpp>
+#include <boost/bind.hpp>
+#include <boost/function.hpp>
+#include <boost/ptr_container/ptr_vector.hpp>
+
+#include <iostream>
+#include <sstream>
+#include <numeric>
+#include <algorithm>
+#include <math.h>
+
+
+using namespace std;
+using namespace qpid;
+using namespace client;
+using namespace sys;
+using boost::lexical_cast;
+using boost::bind;
+
+namespace qpid {
+namespace tests {
+
+enum Mode { SHARED, FANOUT, TOPIC };
+const char* modeNames[] = { "shared", "fanout", "topic" };
+
+// istream/ostream ops so Options can read/display Mode.
+istream& operator>>(istream& in, Mode& mode) {
+    string s;
+    in >> s;
+    int i = find(modeNames, modeNames+3, s) - modeNames;
+    if (i >= 3)  throw Exception("Invalid mode: "+s);
+    mode = Mode(i);
+    return in;
+}
+
+ostream& operator<<(ostream& out, Mode mode) {
+    return out << modeNames[mode];
+}
+
+
+struct Opts : public TestOptions {
+
+    // Actions
+    bool setup, control, publish, subscribe;
+
+    // Queue policy
+    uint32_t queueMaxCount;
+    uint64_t queueMaxSize;
+    std::string baseName;
+    bool queueDurable;
+
+    // Publisher
+    size_t pubs;
+    size_t count ;
+    size_t size;
+    bool confirm;
+    bool durable;
+    bool uniqueData;
+    bool syncPub;
+
+    // Subscriber
+    size_t subs;
+    size_t ack;
+
+    // General
+    size_t qt;
+    bool singleConnect;
+    size_t iterations;
+    Mode mode;
+    bool summary;
+    uint32_t intervalSub;
+    uint32_t intervalPub;
+    size_t tx;
+    size_t txPub;
+    size_t txSub;
+    bool commitAsync;
+
+    static const std::string helpText;
+
+    Opts() :
+        TestOptions(helpText),
+        setup(false), control(false), publish(false), subscribe(false), baseName("qpid-perftest"),
+        pubs(1), count(500000), size(1024), confirm(true), durable(false), uniqueData(false), syncPub(false),
+        subs(1), ack(0),
+        qt(1),singleConnect(false), iterations(1), mode(SHARED), summary(false),
+        intervalSub(0), intervalPub(0), tx(0), txPub(0), txSub(0), commitAsync(false)
+    {
+        addOptions()
+            ("setup", optValue(setup), "Create shared queues.")
+            ("control", optValue(control), "Run test, print report.")
+            ("publish", optValue(publish), "Publish messages.")
+            ("subscribe", optValue(subscribe), "Subscribe for messages.")
+
+            ("mode", optValue(mode, "shared|fanout|topic"), "Test mode."
+             "\nshared: --qt queues, --npubs publishers and --nsubs subscribers per queue.\n"
+             "\nfanout: --npubs publishers, --nsubs subscribers, fanout exchange."
+             "\ntopic: --qt topics, --npubs publishers and --nsubs subscribers per topic.\n")
+
+            ("npubs", optValue(pubs, "N"), "Create N publishers.")
+            ("count", optValue(count, "N"), "Each publisher sends N messages.")
+            ("size", optValue(size, "BYTES"), "Size of messages in bytes.")
+            ("pub-confirm", optValue(confirm, "yes|no"), "Publisher use confirm-mode.")
+            ("durable", optValue(durable, "yes|no"), "Publish messages as durable.")
+            ("unique-data", optValue(uniqueData, "yes|no"), "Make data for each message unique.")
+            ("sync-publish", optValue(syncPub, "yes|no"), "Wait for confirmation of each message before sending the next one.")
+
+            ("nsubs", optValue(subs, "N"), "Create N subscribers.")
+            ("sub-ack", optValue(ack, "N"), "N>0: Subscriber acks batches of N.\n"
+             "N==0: Subscriber uses unconfirmed mode")
+
+            ("qt", optValue(qt, "N"), "Create N queues or topics.")
+            ("single-connection", optValue(singleConnect, "yes|no"), "Use one connection for multiple sessions.")
+
+            ("iterations", optValue(iterations, "N"), "Desired number of iterations of the test.")
+            ("summary,s", optValue(summary), "Summary output: pubs/sec subs/sec transfers/sec Mbytes/sec")
+
+            ("queue-max-count", optValue(queueMaxCount, "N"), "queue policy: count to trigger 'flow to disk'")
+            ("queue-max-size", optValue(queueMaxSize, "N"), "queue policy: accumulated size to trigger 'flow to disk'")
+            ("base-name", optValue(baseName, "NAME"), "base name used for queues or topics")
+            ("queue-durable", optValue(queueDurable, "N"), "Make queue durable (implied if durable set)")
+
+            ("interval_sub", optValue(intervalSub, "ms"), ">=0 delay between msg consume")
+            ("interval_pub", optValue(intervalPub, "ms"), ">=0 delay between msg publish")
+
+            ("tx", optValue(tx, "N"), "if non-zero, the transaction batch size for publishing and consuming")
+            ("pub-tx", optValue(txPub, "N"), "if non-zero, the transaction batch size for publishing")
+            ("async-commit", optValue(commitAsync, "yes|no"), "Don't wait for completion of commit")
+            ("sub-tx", optValue(txSub, "N"), "if non-zero, the transaction batch size for consuming");
+    }
+
+    // Computed values
+    size_t totalPubs;
+    size_t totalSubs;
+    size_t transfers;
+    size_t subQuota;
+
+    void parse(int argc, char** argv) {
+        TestOptions::parse(argc, argv);
+        switch (mode) {
+          case SHARED:
+            if (count % subs) {
+                count += subs - (count % subs);
+                cout << "WARNING: Adjusted --count to " << count
+                     << " the nearest multiple of --nsubs" << endl;
+            }
+            totalPubs = pubs*qt;
+            totalSubs = subs*qt;
+            subQuota = (pubs*count)/subs;
+            break;
+          case FANOUT:
+            if (qt != 1) cerr << "WARNING: Fanout mode, ignoring --qt="
+                              << qt << endl;
+            qt=1;
+            totalPubs = pubs;
+            totalSubs = subs;
+            subQuota = totalPubs*count;
+            break;
+          case TOPIC:
+            totalPubs = pubs*qt;
+            totalSubs = subs*qt;
+            subQuota = pubs*count;
+            break;
+        }
+        transfers=(totalPubs*count) + (totalSubs*subQuota);
+        if (tx) {
+            if (txPub) {
+                cerr << "WARNING: Using overriden tx value for publishers: " << txPub << std::endl;
+            } else {
+                txPub = tx;
+            }
+            if (txSub) {
+                cerr << "WARNING: Using overriden tx value for subscribers: " << txSub << std::endl;
+            } else {
+                txSub = tx;
+            }
+        }
+    }
+};
+
+const std::string Opts::helpText=
+"There are two ways to use qpid-perftest: single process or multi-process.\n\n"
+"If none of the --setup, --publish, --subscribe or --control options\n"
+"are given qpid-perftest will run a single-process test.\n"
+"For a  multi-process test first run:\n"
+"  qpid-perftest --setup <other options>\n"
+"and wait for it to complete. The remaining process should run concurrently::\n"
+"Run --npubs times: pqid-perftest --publish <other options>\n"
+"Run --nsubs times: qpid-perftest --subscribe <other options>\n"
+"Run once:          qpid-perftest --control <other options>\n"
+"Note the <other options> must be identical for all processes.\n";
+
+Opts opts;
+Connection globalConnection;
+
+std::string fqn(const std::string& name)
+{
+    ostringstream fqn;
+    fqn << opts.baseName << "_" << name;
+    return fqn.str();
+}
+
+struct Client : public Runnable {
+    Connection* connection;
+    Connection localConnection;
+    AsyncSession session;
+    Thread thread;
+
+    Client() {
+        if (opts.singleConnect){
+            connection = &globalConnection;
+            if (!globalConnection.isOpen()) opts.open(globalConnection);
+        }else{
+            connection = &localConnection;
+            opts.open(localConnection);
+        }
+        session = connection->newSession();
+    }
+
+    ~Client() {
+        try {
+            if (connection->isOpen()) {
+                session.close();
+                connection->close();
+            }
+        } catch (const std::exception& e) {
+            std::cerr << "Error in shutdown: " << e.what() << std::endl;
+        }
+    }
+};
+
+struct Setup : public Client {
+
+    void queueInit(string name, bool durable=false, const framing::FieldTable& settings=framing::FieldTable()) {
+        session.queueDeclare(arg::queue=name, arg::durable=durable, arg::arguments=settings);
+        session.queuePurge(arg::queue=name);
+        session.sync();
+    }
+
+    void run() {
+        queueInit(fqn("pub_start"));
+        queueInit(fqn("pub_done"));
+        queueInit(fqn("sub_ready"));
+        queueInit(fqn("sub_done"));
+        if (opts.iterations > 1) queueInit(fqn("sub_iteration"));
+        if (opts.mode==SHARED) {
+            framing::FieldTable settings;//queue policy settings
+            settings.setInt("qpid.max_count", opts.queueMaxCount);
+            settings.setInt("qpid.max_size", opts.queueMaxSize);
+            for (size_t i = 0; i < opts.qt; ++i) {
+                ostringstream qname;
+                qname << opts.baseName << i;
+                queueInit(qname.str(), opts.durable || opts.queueDurable, settings);
+            }
+        }
+    }
+};
+
+void expect(string actual, string expect) {
+    if (expect != actual)
+        throw Exception("Expecting "+expect+" but received "+actual);
+
+}
+
+double secs(Duration d) { return double(d)/TIME_SEC; }
+double secs(AbsTime start, AbsTime finish) {
+    return secs(Duration(start,finish));
+}
+
+
+// Collect rates & print stats.
+class Stats {
+    vector<double> values;
+    double sum;
+
+  public:
+    Stats() : sum(0) {}
+
+    // Functor to collect rates.
+    void operator()(const string& data) {
+        try {
+            double d=lexical_cast<double>(data);
+            values.push_back(d);
+            sum += d;
+        } catch (const std::exception&) {
+            throw Exception("Bad report: "+data);
+        }
+    }
+
+    double mean() const {
+        return sum/values.size();
+    }
+
+    double stdev() const {
+        if (values.size() <= 1) return 0;
+        double avg = mean();
+        double ssq = 0;
+        for (vector<double>::const_iterator i = values.begin();
+             i != values.end(); ++i) {
+            double x=*i;
+            x -= avg;
+            ssq += x*x;
+        }
+        return sqrt(ssq/(values.size()-1));
+    }
+
+    ostream& print(ostream& out) {
+        ostream_iterator<double> o(out, "\n");
+        copy(values.begin(), values.end(), o);
+        out << "Average: " << mean();
+        if (values.size() > 1)
+            out << " (std.dev. " << stdev() << ")";
+        return out << endl;
+    }
+};
+
+
+// Manage control queues, collect and print reports.
+struct Controller : public Client {
+
+   SubscriptionManager subs;
+
+    Controller() : subs(session) {}
+
+    /** Process messages from queue by applying a functor. */
+    void process(size_t n, string queue,
+                 boost::function<void (const string&)> msgFn)
+    {
+        if (!opts.summary)
+            cout << "Processing " << n << " messages from "
+                 << queue << " " << flush;
+        LocalQueue lq;
+        subs.setFlowControl(n, SubscriptionManager::UNLIMITED, false);
+        subs.subscribe(lq, queue);
+        for (size_t i = 0; i < n; ++i) {
+            if (!opts.summary) cout << "." << flush;
+            msgFn(lq.pop().getData());
+        }
+        if (!opts.summary) cout << " done." << endl;
+    }
+
+    void process(size_t n, LocalQueue lq, string queue,
+                 boost::function<void (const string&)> msgFn)
+    {
+        session.messageFlow(queue, 0, n);
+        if (!opts.summary)
+            cout << "Processing " << n << " messages from "
+                 << queue << " " << flush;
+        for (size_t i = 0; i < n; ++i) {
+            if (!opts.summary) cout << "." << flush;
+            msgFn(lq.pop().getData());
+        }
+        if (!opts.summary) cout << " done." << endl;
+    }
+
+    void send(size_t n, string queue, string data) {
+        if (!opts.summary)
+            cout << "Sending " << data << " " << n << " times to " << queue
+                 << endl;
+        Message msg(data, queue);
+        for (size_t i = 0; i < n; ++i)
+            session.messageTransfer(arg::content=msg, arg::acceptMode=1);
+    }
+
+    void run() {                // Controller
+        try {
+            // Wait for subscribers to be ready.
+            process(opts.totalSubs, fqn("sub_ready"), bind(expect, _1, "ready"));
+
+            LocalQueue pubDone;
+            LocalQueue subDone;
+            subs.setFlowControl(0, SubscriptionManager::UNLIMITED, false);
+            subs.subscribe(pubDone, fqn("pub_done"));
+            subs.subscribe(subDone, fqn("sub_done"));
+
+            double txrateTotal(0);
+            double mbytesTotal(0);
+            double pubRateTotal(0);
+            double subRateTotal(0);
+
+            for (size_t j = 0; j < opts.iterations; ++j) {
+                AbsTime start=now();
+                send(opts.totalPubs, fqn("pub_start"), "start"); // Start publishers
+                if (j) {
+		    send(opts.totalPubs, fqn("sub_iteration"), "next"); // Start subscribers on next iteration
+                }
+
+                Stats pubRates;
+                Stats subRates;
+
+                process(opts.totalPubs, pubDone, fqn("pub_done"), boost::ref(pubRates));
+                process(opts.totalSubs, subDone, fqn("sub_done"), boost::ref(subRates));
+
+                AbsTime end=now();
+
+                double time=secs(start, end);
+                double txrate=opts.transfers/time;
+                double mbytes=(txrate*opts.size)/(1024*1024);
+
+                if (!opts.summary) {
+                    cout << endl << "Total " << opts.transfers << " transfers of "
+                         << opts.size << " bytes in "
+                         << time << " seconds." << endl;
+                    cout << endl << "Publish transfers/sec:    " << endl;
+                    pubRates.print(cout);
+                    cout << endl << "Subscribe transfers/sec:  " << endl;
+                    subRates.print(cout);
+                    cout << endl
+                         << "Total transfers/sec:      " << txrate << endl
+                         << "Total Mbytes/sec: " << mbytes << endl;
+                }
+                else {
+                    cout << pubRates.mean() << "\t"
+                         << subRates.mean() << "\t"
+                         << txrate << "\t"
+                         << mbytes << endl;
+                }
+
+                txrateTotal += txrate;
+                mbytesTotal += mbytes;
+                pubRateTotal += pubRates.mean();
+                subRateTotal += subRates.mean();
+            }
+            if (opts.iterations > 1) {
+                cout << "Averages: "<< endl
+                     << (pubRateTotal / opts.iterations) << "\t"
+                     << (subRateTotal / opts.iterations) << "\t"
+                     << (txrateTotal / opts.iterations) << "\t"
+                     << (mbytesTotal / opts.iterations) << endl;
+            }
+        }
+        catch (const std::exception& e) {
+            cout << "Controller exception: " << e.what() << endl;
+        }
+    }
+};
+
+
+struct PublishThread : public Client {
+    string destination;
+    string routingKey;
+
+    PublishThread() {};
+
+    PublishThread(string key, string dest=string()) {
+        destination=dest;
+        routingKey=key;
+    }
+
+    void run() {                // Publisher
+        try {
+            string data;
+            size_t offset(0);
+            if (opts.uniqueData) {
+                offset = 5;
+                data += "data:";//marker (requested for latency testing tool scripts)
+                data += string(sizeof(size_t), 'X');//space for seq no
+                data += session.getId().str();
+                if (opts.size > data.size()) {
+                    data += string(opts.size - data.size(), 'X');
+                } else if(opts.size < data.size()) {
+                    cout << "WARNING: Increased --size to " << data.size()
+                         << " to honour --unique-data" << endl;
+                }
+            } else {
+                size_t msgSize=max(opts.size, sizeof(size_t));
+                data = string(msgSize, 'X');
+            }
+
+            Message msg(data, routingKey);
+            if (opts.durable)
+                msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
+
+
+            if (opts.txPub){
+                session.txSelect();
+            }
+            SubscriptionManager subs(session);
+            LocalQueue lq;
+            subs.setFlowControl(1, SubscriptionManager::UNLIMITED, true);
+            subs.subscribe(lq, fqn("pub_start"));
+
+            for (size_t j = 0; j < opts.iterations; ++j) {
+                expect(lq.pop().getData(), "start");
+                AbsTime start=now();
+                for (size_t i=0; i<opts.count; i++) {
+                    // Stamp the iteration into the message data, avoid
+                    // any heap allocation.
+                    const_cast<std::string&>(msg.getData()).replace(offset, sizeof(size_t),
+                                          reinterpret_cast<const char*>(&i), sizeof(size_t));
+                    if (opts.syncPub) {
+                        sync(session).messageTransfer(
+                            arg::destination=destination,
+                            arg::content=msg,
+                            arg::acceptMode=1);
+                    } else {
+                        session.messageTransfer(
+                            arg::destination=destination,
+                            arg::content=msg,
+                            arg::acceptMode=1);
+                    }
+                    if (opts.txPub && ((i+1) % opts.txPub == 0)){
+                        if (opts.commitAsync){
+                            session.txCommit();
+                        } else {
+                            sync(session).txCommit();
+                        }
+                    }
+                    if (opts.intervalPub)
+                        qpid::sys::usleep(opts.intervalPub*1000);
+                }
+                if (opts.confirm) session.sync();
+                AbsTime end=now();
+                double time=secs(start,end);
+
+                // Send result to controller.
+                Message report(lexical_cast<string>(opts.count/time), fqn("pub_done"));
+                session.messageTransfer(arg::content=report, arg::acceptMode=1);
+                if (opts.txPub){
+                    sync(session).txCommit();
+                }
+            }
+            session.close();
+        }
+        catch (const std::exception& e) {
+            cout << "PublishThread exception: " << e.what() << endl;
+        }
+    }
+};
+
+struct SubscribeThread : public Client {
+
+    string queue;
+
+    SubscribeThread() {}
+
+    SubscribeThread(string q) { queue = q; }
+
+    SubscribeThread(string key, string ex) {
+        queue=session.getId().str(); // Unique name.
+        session.queueDeclare(arg::queue=queue,
+                             arg::exclusive=true,
+                             arg::autoDelete=true,
+                             arg::durable=opts.durable);
+        session.exchangeBind(arg::queue=queue,
+                             arg::exchange=ex,
+                             arg::bindingKey=key);
+    }
+
+    void verify(bool cond, const char* test, uint32_t expect, uint32_t actual) {
+        if (!cond) {
+            Message error(
+                QPID_MSG("Sequence error: expected  n" << test << expect << " but got " << actual),
+                "sub_done");
+            session.messageTransfer(arg::content=error, arg::acceptMode=1);
+            throw Exception(error.getData());
+        }
+    }
+
+    void run() {                // Subscribe
+        try {
+            if (opts.txSub) sync(session).txSelect();
+            SubscriptionManager subs(session);
+            SubscriptionSettings settings;
+            settings.autoAck = opts.txSub ? opts.txSub : opts.ack;
+            settings.acceptMode = (opts.txSub || opts.ack ? ACCEPT_MODE_EXPLICIT : ACCEPT_MODE_NONE);
+            settings.flowControl = FlowControl::messageCredit(opts.subQuota);
+            LocalQueue lq;
+            Subscription subscription = subs.subscribe(lq, queue, settings);
+            // Notify controller we are ready.
+            session.messageTransfer(arg::content=Message("ready", fqn("sub_ready")), arg::acceptMode=1);
+            if (opts.txSub) {
+                if (opts.commitAsync) session.txCommit();
+                else sync(session).txCommit();
+            }
+
+            LocalQueue iterationControl;
+            if (opts.iterations > 1) {
+                subs.subscribe(iterationControl, fqn("sub_iteration"), SubscriptionSettings(FlowControl::messageCredit(0)));
+            }
+
+            for (size_t j = 0; j < opts.iterations; ++j) {
+                if (j > 0) {
+                    //need to wait here until all subs are done
+                    session.messageFlow(fqn("sub_iteration"), 0, 1);
+                    iterationControl.pop();
+
+                    //need to allocate some more credit for subscription
+                    session.messageFlow(queue, 0, opts.subQuota);
+                }
+                Message msg;
+                AbsTime start=now();
+                size_t expect=0;
+                for (size_t i = 0; i < opts.subQuota; ++i) {
+                    msg=lq.pop();
+                    if (opts.txSub && ((i+1) % opts.txSub == 0)) {
+                        if (opts.commitAsync) session.txCommit();
+                        else sync(session).txCommit();
+                    }
+                    if (opts.intervalSub)
+                        qpid::sys::usleep(opts.intervalSub*1000);
+                    // TODO aconway 2007-11-23: check message order for.
+                    // multiple publishers. Need an array of counters,
+                    // one per publisher and a publisher ID in the
+                    // message. Careful not to introduce a lot of overhead
+                    // here, e.g. no std::map, std::string etc.
+                    //
+                    // For now verify order only for a single publisher.
+                    size_t offset = opts.uniqueData ? 5 /*marker is 'data:'*/ : 0;
+                    size_t n = *reinterpret_cast<const size_t*>(msg.getData().data() + offset);
+                    if (opts.pubs == 1) {
+                        if (opts.subs == 1 || opts.mode == FANOUT) verify(n==expect, "==", expect, n);
+                        else verify(n>=expect, ">=", expect, n);
+                        expect = n+1;
+                    }
+                }
+                if (opts.txSub || opts.ack)
+                    subscription.accept(subscription.getUnaccepted());
+                if (opts.txSub) {
+                    if (opts.commitAsync) session.txCommit();
+                    else sync(session).txCommit();
+                }
+                AbsTime end=now();
+
+                // Report to publisher.
+                Message result(lexical_cast<string>(opts.subQuota/secs(start,end)),
+                               fqn("sub_done"));
+                session.messageTransfer(arg::content=result, arg::acceptMode=1);
+                if (opts.txSub) sync(session).txCommit();
+            }
+            session.close();
+        }
+        catch (const std::exception& e) {
+            cout << "SubscribeThread exception: " << e.what() << endl;
+        }
+    }
+};
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+int main(int argc, char** argv) {
+    int exitCode = 0;
+    boost::ptr_vector<Client> subs(opts.subs);
+    boost::ptr_vector<Client> pubs(opts.pubs);
+
+    try {
+        opts.parse(argc, argv);
+
+        string exchange;
+        switch (opts.mode) {
+            case FANOUT: exchange="amq.fanout"; break;
+            case TOPIC: exchange="amq.topic"; break;
+            case SHARED: break;
+        }
+
+        bool singleProcess=
+            (!opts.setup && !opts.control && !opts.publish && !opts.subscribe);
+        if (singleProcess)
+            opts.setup = opts.control = opts.publish = opts.subscribe = true;
+
+        if (opts.setup) Setup().run();          // Set up queues
+
+        // Start pubs/subs for each queue/topic.
+        for (size_t i = 0; i < opts.qt; ++i) {
+            ostringstream key;
+            key << opts.baseName << i; // Queue or topic name.
+            if (opts.publish) {
+                size_t n = singleProcess ? opts.pubs : 1;
+                for (size_t j = 0; j < n; ++j)  {
+                    pubs.push_back(new PublishThread(key.str(), exchange));
+                    pubs.back().thread=Thread(pubs.back());
+                }
+            }
+            if (opts.subscribe) {
+                size_t n = singleProcess ? opts.subs : 1;
+                for (size_t j = 0; j < n; ++j)  {
+                    if (opts.mode==SHARED)
+                        subs.push_back(new SubscribeThread(key.str()));
+                    else
+                        subs.push_back(new SubscribeThread(key.str(),exchange));
+                    subs.back().thread=Thread(subs.back());
+                }
+            }
+        }
+
+        if (opts.control) Controller().run();
+    }
+    catch (const std::exception& e) {
+        cout << endl << e.what() << endl;
+        exitCode = 1;
+    }
+
+    // Wait for started threads.
+    if (opts.publish) {
+        for (boost::ptr_vector<Client>::iterator i=pubs.begin();
+             i != pubs.end();
+             ++i)
+            i->thread.join();
+    }
+
+    if (opts.subscribe) {
+        for (boost::ptr_vector<Client>::iterator i=subs.begin();
+             i != subs.end();
+             ++i)
+            i->thread.join();
+    }
+    return exitCode;
+}
diff --git a/qpid/cpp/src/tests/qpid-topic-listener.cpp b/qpid/cpp/src/tests/qpid-topic-listener.cpp
new file mode 100644
index 0000000..c42e76d
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-topic-listener.cpp
@@ -0,0 +1,209 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+/**
+ * This file provides one half of a test and example of a pub-sub
+ * style of interaction. See qpid-topic-publisher.cpp for the other half,
+ * in which the logic for publishing is defined.
+ *
+ * This file contains the listener logic. A listener will subscribe to
+ * a logical 'topic'. It will count the number of messages it receives
+ * and the time elapsed between the first one and the last one. It
+ * recognises two types of 'special' message that tell it to (a) send
+ * a report containing this information, (b) shutdown (i.e. stop
+ * listening).
+ */
+
+#include "TestOptions.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/MessageListener.h"
+#include "qpid/client/Session.h"
+#include "qpid/client/AsyncSession.h"
+#include "qpid/client/SubscriptionManager.h"
+#include "qpid/sys/SystemInfo.h"
+#include "qpid/sys/Time.h"
+#include "qpid/framing/FieldValue.h"
+#include <iostream>
+#include <sstream>
+
+using namespace qpid;
+using namespace qpid::client;
+using namespace qpid::sys;
+using namespace qpid::framing;
+using namespace std;
+
+namespace qpid {
+namespace tests {
+
+/**
+ * A message listener implementation in which the runtime logic is
+ * defined.
+ */
+class Listener : public MessageListener{
+    Session session;
+    SubscriptionManager& mgr;
+    const string responseQueue;
+    const bool transactional;
+    bool init;
+    int count;
+    AbsTime start;
+
+    void shutdown();
+    void report();
+public:
+    Listener(const Session& session, SubscriptionManager& mgr, const string& reponseQueue, bool tx);
+    virtual void received(Message& msg);
+    Subscription subscription;
+};
+
+/**
+ * A utility class for managing the options passed in.
+ */
+struct Args : public qpid::TestOptions {
+    int ack;
+    bool transactional;
+    bool durable;
+    int prefetch;
+    string statusqueue;
+
+    Args() : ack(0), transactional(false), durable(false), prefetch(0) {
+        addOptions()
+            ("ack", optValue(ack, "MODE"), "Ack frequency in messages (defaults to half the prefetch value)")
+            ("transactional", optValue(transactional), "Use transactions")
+            ("durable", optValue(durable), "subscribers should use durable queues")
+            ("prefetch", optValue(prefetch, "N"), "prefetch count (0 implies no flow control, and no acking)")
+            ("status-queue", optValue(statusqueue, "QUEUE-NAME"), "Message queue to put status messages on");
+    }
+};
+
+Listener::Listener(const Session& s, SubscriptionManager& m, const string& _responseq, bool tx) :
+    session(s), mgr(m), responseQueue(_responseq), transactional(tx), init(false), count(0){}
+
+void Listener::received(Message& message){
+    if(!init){
+        start = now();
+        count = 0;
+        init = true;
+        cout << "Batch started." << endl;
+    }
+    string type = message.getHeaders().getAsString("TYPE");
+
+    if(string("TERMINATION_REQUEST") == type){
+        shutdown();
+    }else if(string("REPORT_REQUEST") == type){
+        subscription.accept(subscription.getUnaccepted()); // Accept everything upto this point
+        cout <<"Batch ended, sending report." << endl;
+        //send a report:
+        report();
+        init = false;
+    }else if (++count % 1000 == 0){
+        cout <<"Received " << count << " messages." << endl;
+    }
+}
+
+void Listener::shutdown(){
+    mgr.stop();
+}
+
+void Listener::report(){
+    AbsTime finish = now();
+    Duration time(start, finish);
+    stringstream reportstr;
+    reportstr << "Received " << count << " messages in "
+              << time/TIME_MSEC << " ms.";
+    Message msg(reportstr.str(), responseQueue);
+    msg.getHeaders().setString("TYPE", "REPORT");
+    session.messageTransfer(arg::destination="amq.direct", arg::content=msg, arg::acceptMode=1);
+    if(transactional){
+        sync(session).txCommit();
+    }
+}
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+/**
+ * The main routine creates a Listener instance and sets it up to
+ * consume from a private queue bound to the exchange with the
+ * appropriate topic name.
+ */
+int main(int argc, char** argv){
+    try{
+        Args args;
+        args.parse(argc, argv);
+        if(args.help)
+            cout << args << endl;
+        else {
+            Connection connection;
+            args.open(connection);
+            AsyncSession session = connection.newSession();
+
+            //declare exchange, queue and bind them:
+            session.queueDeclare(arg::queue="response");
+            std::string control = "control_" + session.getId().str();
+            if (args.durable) {
+                session.queueDeclare(arg::queue=control, arg::durable=true);
+            } else {
+                session.queueDeclare(arg::queue=control, arg::exclusive=true, arg::autoDelete=true);
+            }
+            session.exchangeBind(arg::exchange="amq.topic", arg::queue=control, arg::bindingKey="topic_control");
+
+            //set up listener
+            SubscriptionManager mgr(session);
+            Listener listener(session, mgr, "response", args.transactional);
+            SubscriptionSettings settings;
+            if (args.prefetch) {
+                settings.autoAck = (args.ack ? args.ack : (args.prefetch / 2));
+                settings.flowControl = FlowControl::messageCredit(args.prefetch);
+            } else {
+                settings.acceptMode = ACCEPT_MODE_NONE;
+                settings.flowControl = FlowControl::unlimited();
+            }
+            listener.subscription =  mgr.subscribe(listener, control, settings);
+            session.sync();
+
+            if( args.statusqueue.length() > 0 ) {
+                stringstream msg_str;
+                msg_str << "qpid-topic-listener: " << qpid::sys::SystemInfo::getProcessId();
+                session.messageTransfer(arg::content=Message(msg_str.str(), args.statusqueue));
+                cout << "Ready status put on queue '" << args.statusqueue << "'" << endl;
+            }
+
+            if (args.transactional) {
+                session.txSelect();
+            }
+
+            cout << "qpid-topic-listener: listening..." << endl;
+            mgr.run();
+            if (args.durable) {
+                session.queueDelete(arg::queue=control);
+            }
+            session.close();
+            cout << "closing connection" << endl;
+            connection.close();
+        }
+        return 0;
+    } catch (const std::exception& error) {
+        cout << "qpid-topic-listener: " << error.what() << endl;
+    }
+    return 1;
+}
diff --git a/qpid/cpp/src/tests/qpid-topic-publisher.cpp b/qpid/cpp/src/tests/qpid-topic-publisher.cpp
new file mode 100644
index 0000000..f9107b9
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-topic-publisher.cpp
@@ -0,0 +1,230 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+/**
+ * This file provides one half of a test and example of a pub-sub
+ * style of interaction. See qpid-topic-listener.cpp for the other half, in
+ * which the logic for subscribers is defined.
+ *
+ * This file contains the publisher logic. The publisher will send a
+ * number of messages to the exchange with the appropriate routing key
+ * for the logical 'topic'. Once it has done this it will then send a
+ * request that each subscriber report back with the number of message
+ * it has received and the time that elapsed between receiving the
+ * first one and receiving the report request. Once the expected
+ * number of reports are received, it sends out a request that each
+ * subscriber shutdown.
+ */
+
+#include "TestOptions.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/MessageListener.h"
+#include "qpid/client/AsyncSession.h"
+#include "qpid/client/SubscriptionManager.h"
+#include "qpid/sys/Monitor.h"
+#include "qpid/sys/Time.h"
+#include <cstdlib>
+#include <iostream>
+
+using namespace qpid;
+using namespace qpid::client;
+using namespace qpid::sys;
+using namespace std;
+
+namespace qpid {
+namespace tests {
+
+/**
+ * The publishing logic is defined in this class. It implements
+ * message listener and can therfore be used to receive messages sent
+ * back by the subscribers.
+ */
+class Publisher {
+    AsyncSession session;
+    SubscriptionManager mgr;
+    LocalQueue queue;
+    const string controlTopic;
+    const bool transactional;
+    const bool durable;
+
+    string generateData(int size);
+
+public:
+    Publisher(const AsyncSession& session, const string& controlTopic, bool tx, bool durable);
+    int64_t publish(int msgs, int listeners, int size);
+    void terminate();
+};
+
+/**
+ * A utility class for managing the options passed in to the test
+ */
+struct Args : public TestOptions {
+    int messages;
+    int subscribers;
+    bool transactional;
+    bool durable;
+    int batches;
+    int delay;
+    int size;
+    string statusqueue;
+
+    Args() : messages(1000), subscribers(1),
+             transactional(false), durable(false),
+             batches(1), delay(0), size(256)
+    {
+        addOptions()
+            ("messages", optValue(messages, "N"), "how many messages to send")
+            ("subscribers", optValue(subscribers, "N"), "how many subscribers to expect reports from")
+            ("transactional", optValue(transactional), "client should use transactions")
+            ("durable", optValue(durable), "messages should be durable")
+            ("batches", optValue(batches, "N"), "how many batches to run")
+            ("delay", optValue(delay, "SECONDS"), "Causes a delay between each batch")
+            ("size", optValue(size, "BYTES"), "size of the published messages")
+            ("status-queue", optValue(statusqueue, "QUEUE-NAME"), "Message queue to read status messages from");
+    }
+};
+
+Publisher::Publisher(const AsyncSession& _session, const string& _controlTopic, bool tx, bool d) :
+    session(_session), mgr(session), controlTopic(_controlTopic), transactional(tx), durable(d)
+{
+    mgr.subscribe(queue, "response");
+}
+
+int64_t Publisher::publish(int msgs, int listeners, int size){
+    Message msg(generateData(size), controlTopic);
+    if (durable) {
+        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
+    }
+    AbsTime start = now();
+
+    for(int i = 0; i < msgs; i++){
+        session.messageTransfer(arg::content=msg, arg::destination="amq.topic", arg::acceptMode=1);
+    }
+    //send report request
+    Message reportRequest("", controlTopic);
+    reportRequest.getHeaders().setString("TYPE", "REPORT_REQUEST");
+    session.messageTransfer(arg::content=reportRequest, arg::destination="amq.topic", arg::acceptMode=1);
+    if(transactional){
+        sync(session).txCommit();
+    }
+    //wait for a response from each listener (TODO, could log these)
+    for (int i = 0; i < listeners; i++) {
+        Message report = queue.pop();
+    }
+
+    if(transactional){
+        sync(session).txCommit();
+    }
+
+    AbsTime finish = now();
+    return Duration(start, finish);
+}
+
+string Publisher::generateData(int size){
+    string data;
+    for(int i = 0; i < size; i++){
+        data += ('A' + (i / 26));
+    }
+    return data;
+}
+
+void Publisher::terminate(){
+    //send termination request
+    Message terminationRequest("", controlTopic);
+    terminationRequest.getHeaders().setString("TYPE", "TERMINATION_REQUEST");
+    session.messageTransfer(arg::content=terminationRequest, arg::destination="amq.topic", arg::acceptMode=1);
+    if(transactional){
+        session.txCommit();
+    }
+}
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+int main(int argc, char** argv) {
+    try{
+        Args args;
+        args.parse(argc, argv);
+        if(args.help)
+            cout << args << endl;
+        else {
+            Connection connection;
+            args.open(connection);
+            AsyncSession session = connection.newSession();
+
+            // If status-queue is defined, wait for all expected listeners to join in before we start
+            if( args.statusqueue.length() > 0 ) {
+                cout << "Waiting for " << args.subscribers << " listeners..." << endl;
+                SubscriptionManager statusSubs(session);
+                LocalQueue statusQ;
+                statusSubs.subscribe(statusQ, args.statusqueue);
+                for (int i = 0; i < args.subscribers; i++) {
+                    Message m = statusQ.get();
+                    if( m.getData().find("topic_listener: ", 0) == 0 ) {
+                        cout << "Listener " << (i+1) << " of " << args.subscribers
+                            << " is ready (pid " << m.getData().substr(16, m.getData().length() - 16)
+                            << ")" << endl;
+                    } else {
+                        throw Exception(QPID_MSG("Unexpected message received on status queue: " << m.getData()));
+                    }
+                }
+            }
+
+            if (args.transactional) {
+                session.txSelect();
+            }
+            session.queueDeclare(arg::queue="response");
+            session.exchangeBind(arg::exchange="amq.direct", arg::queue="response", arg::bindingKey="response");
+
+            Publisher publisher(session, "topic_control", args.transactional, args.durable);
+
+            int batchSize(args.batches);
+            int64_t max(0);
+            int64_t min(0);
+            int64_t sum(0);
+            for(int i = 0; i < batchSize; i++){
+                if(i > 0 && args.delay) qpid::sys::sleep(args.delay);
+                int64_t msecs =
+                    publisher.publish(args.messages,
+                                      args.subscribers,
+                                      args.size) / TIME_MSEC;
+                if(!max || msecs > max) max = msecs;
+                if(!min || msecs < min) min = msecs;
+                sum += msecs;
+                cout << "Completed " << (i+1) << " of " << batchSize
+                    << " in " << msecs << "ms" << endl;
+            }
+            publisher.terminate();
+            int64_t avg = sum / batchSize;
+            if(batchSize > 1){
+                cout << batchSize << " batches completed. avg=" << avg <<
+                    ", max=" << max << ", min=" << min << endl;
+            }
+            session.close();
+            connection.close();
+        }
+        return 0;
+    }catch(exception& error) {
+        cout << error.what() << endl;
+    }
+    return 1;
+}
diff --git a/qpid/cpp/src/tests/qpid-txtest.cpp b/qpid/cpp/src/tests/qpid-txtest.cpp
new file mode 100644
index 0000000..d0ba2f1
--- /dev/null
+++ b/qpid/cpp/src/tests/qpid-txtest.cpp
@@ -0,0 +1,340 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+#include <algorithm>
+#include <iomanip>
+#include <iostream>
+#include <memory>
+#include <sstream>
+#include <vector>
+
+#include "TestOptions.h"
+#include "qpid/client/Connection.h"
+#include "qpid/client/Message.h"
+#include "qpid/client/AsyncSession.h"
+#include "qpid/client/SubscriptionManager.h"
+#include "qpid/framing/Array.h"
+#include "qpid/framing/Buffer.h"
+#include "qpid/framing/Uuid.h"
+#include "qpid/sys/Thread.h"
+
+using namespace qpid;
+using namespace qpid::client;
+using namespace qpid::sys;
+using std::string;
+
+namespace qpid {
+namespace tests {
+
+typedef std::vector<std::string> StringSet;
+
+struct Args : public qpid::TestOptions {
+    bool init, transfer, check;//actions
+    uint size;
+    bool durable;
+    uint queues;
+    string base;
+    uint msgsPerTx;
+    uint txCount;
+    uint totalMsgCount;
+    bool dtx;
+    bool quiet;
+
+    Args() : init(true), transfer(true), check(true),
+             size(256), durable(true), queues(2),
+             base("tx-test"), msgsPerTx(1), txCount(1), totalMsgCount(10),
+             dtx(false), quiet(false)
+    {
+        addOptions()
+
+            ("init", optValue(init, "yes|no"), "Declare queues and populate one with the initial set of messages.")
+            ("transfer", optValue(transfer, "yes|no"), "'Move' messages from one queue to another using transactions to ensure no message loss.")
+            ("check", optValue(check, "yes|no"), "Check that the initial messages are all still available.")
+            ("size", optValue(size, "N"), "message size")
+            ("durable", optValue(durable, "yes|no"), "use durable messages")
+            ("queues", optValue(queues, "N"), "number of queues")
+            ("queue-base-name", optValue(base, "<name>"), "base name for queues")
+            ("messages-per-tx", optValue(msgsPerTx, "N"), "number of messages transferred per transaction")
+            ("tx-count", optValue(txCount, "N"), "number of transactions per 'agent'")
+            ("total-messages", optValue(totalMsgCount, "N"), "total number of messages in 'circulation'")
+            ("dtx", optValue(dtx, "yes|no"), "use distributed transactions")
+            ("quiet", optValue(quiet), "reduce output from test");
+    }
+};
+
+const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
+
+std::string generateData(uint size)
+{
+    if (size < chars.length()) {
+        return chars.substr(0, size);
+    }
+    std::string data;
+    for (uint i = 0; i < (size / chars.length()); i++) {
+        data += chars;
+    }
+    data += chars.substr(0, size % chars.length());
+    return data;
+}
+
+void generateSet(const std::string& base, uint count, StringSet& collection)
+{
+    for (uint i = 0; i < count; i++) {
+        std::ostringstream out;
+        out << base << "-" << (i+1);
+        collection.push_back(out.str());
+    }
+}
+
+Args opts;
+
+struct Client
+{
+    Connection connection;
+    AsyncSession session;
+
+    Client()
+    {
+        opts.open(connection);
+        session = connection.newSession();
+    }
+
+    ~Client()
+    {
+        try{
+            session.close();
+            connection.close();
+        } catch(const std::exception& e) {
+            std::cout << e.what() << std::endl;
+        }
+    }
+};
+
+struct Transfer : public Client, public Runnable
+{
+    std::string src;
+    std::string dest;
+    Thread thread;
+    framing::Xid xid;
+
+    Transfer(const std::string& to, const std::string& from) : src(to), dest(from), xid(0x4c414e47, "", from) {}
+
+    void run()
+    {
+        try {
+
+            if (opts.dtx) session.dtxSelect();
+            else session.txSelect();
+            SubscriptionManager subs(session);
+
+            LocalQueue lq;
+            SubscriptionSettings settings(FlowControl::messageWindow(opts.msgsPerTx));
+            settings.autoAck = 0; // Disabled
+            Subscription sub = subs.subscribe(lq, src, settings);
+
+            for (uint t = 0; t < opts.txCount; t++) {
+                Message in;
+                Message out("", dest);
+                if (opts.dtx) {
+                    setNewXid(xid);
+                    session.dtxStart(arg::xid=xid);
+                }
+                for (uint m = 0; m < opts.msgsPerTx; m++) {
+                    in = lq.pop();
+                    std::string& data = in.getData();
+                    if (data.size() != opts.size) {
+                        std::ostringstream oss;
+                        oss << "Message size incorrect: size=" << in.getData().size() << "; expected " << opts.size;
+                        throw std::runtime_error(oss.str());
+                    }
+                    out.setData(data);
+                    out.getMessageProperties().setCorrelationId(in.getMessageProperties().getCorrelationId());
+                    out.getDeliveryProperties().setDeliveryMode(in.getDeliveryProperties().getDeliveryMode());
+                    session.messageTransfer(arg::content=out, arg::acceptMode=1);
+                }
+                sub.accept(sub.getUnaccepted());
+                if (opts.dtx) {
+                    session.dtxEnd(arg::xid=xid);
+                    session.dtxPrepare(arg::xid=xid);
+                    session.dtxCommit(arg::xid=xid);
+                } else {
+                    session.txCommit();
+                }
+            }
+        } catch(const std::exception& e) {
+            std::cout << "Transfer interrupted: " << e.what() << std::endl;
+        }
+    }
+
+    void setNewXid(framing::Xid& xid) {
+        framing::Uuid uuid(true);
+        xid.setGlobalId(uuid.str());
+    }
+};
+
+struct Controller : public Client
+{
+    StringSet ids;
+    StringSet queues;
+
+    Controller()
+    {
+        generateSet(opts.base, opts.queues, queues);
+        generateSet("msg", opts.totalMsgCount, ids);
+    }
+
+    void init()
+    {
+        //declare queues
+        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
+            session.queueDeclare(arg::queue=*i, arg::durable=opts.durable);
+            session.sync();
+        }
+
+        Message msg(generateData(opts.size), *queues.begin());
+        if (opts.durable) {
+            msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
+        }
+
+        //publish messages
+        for (StringSet::iterator i = ids.begin(); i != ids.end(); i++) {
+            msg.getMessageProperties().setCorrelationId(*i);
+            session.messageTransfer(arg::content=msg, arg::acceptMode=1);
+        }
+    }
+
+    void transfer()
+    {
+        boost::ptr_vector<Transfer> agents(opts.queues);
+        //launch transfer agents
+        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
+            StringSet::iterator next = i + 1;
+            if (next == queues.end()) next = queues.begin();
+
+            if (!opts.quiet) std::cout << "Transfering from " << *i << " to " << *next << std::endl;
+            agents.push_back(new Transfer(*i, *next));
+            agents.back().thread = Thread(agents.back());
+        }
+
+        for (boost::ptr_vector<Transfer>::iterator i = agents.begin(); i != agents.end(); i++) {
+            i->thread.join();
+        }
+    }
+
+    int check()
+    {
+        SubscriptionManager subs(session);
+
+        // Recover DTX transactions (if any)
+        if (opts.dtx) {
+            std::vector<std::string> inDoubtXids;
+            framing::DtxRecoverResult dtxRes = session.dtxRecover().get();
+            const framing::Array& xidArr = dtxRes.getInDoubt();
+            xidArr.collect(inDoubtXids);
+
+            if (inDoubtXids.size()) {
+                if (!opts.quiet) std::cout << "Recovering DTX in-doubt transaction(s):" << std::endl;
+                framing::StructHelper decoder;
+                framing::Xid xid;
+                // abort even, commit odd transactions
+                for (unsigned i = 0; i < inDoubtXids.size(); i++) {
+                    decoder.decode(xid, inDoubtXids[i]);
+                    if (!opts.quiet) std::cout << (i%2 ? " * aborting " : " * committing ");
+                    xid.print(std::cout);
+                    std::cout << std::endl;
+                    if (i%2) {
+                        session.dtxRollback(arg::xid=xid);
+                    } else {
+                        session.dtxCommit(arg::xid=xid);
+                    }
+                }
+            }
+        }
+
+        StringSet drained;
+        //drain each queue and verify the correct set of messages are available
+        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
+            //subscribe, allocate credit and flushn
+            LocalQueue lq;
+            SubscriptionSettings settings(FlowControl::unlimited(), ACCEPT_MODE_NONE);
+            subs.subscribe(lq, *i, settings);
+            session.messageFlush(arg::destination=*i);
+            session.sync();
+
+            uint count(0);
+            while (!lq.empty()) {
+                Message m = lq.pop();
+                //add correlation ids of received messages to drained
+                drained.push_back(m.getMessageProperties().getCorrelationId());
+                ++count;
+            }
+            if (!opts.quiet) std::cout << "Drained " << count << " messages from " << *i << std::endl;
+        }
+
+        sort(ids.begin(), ids.end());
+        sort(drained.begin(), drained.end());
+
+        //check that drained == ids
+        StringSet missing;
+        set_difference(ids.begin(), ids.end(), drained.begin(), drained.end(), back_inserter(missing));
+
+        StringSet extra;
+        set_difference(drained.begin(), drained.end(), ids.begin(), ids.end(), back_inserter(extra));
+
+        if (missing.empty() && extra.empty()) {
+            std::cout << "All expected messages were retrieved." << std::endl;
+            return 0;
+        } else {
+            if (!missing.empty()) {
+                std::cout << "The following ids were missing:" << std::endl;
+                for (StringSet::iterator i = missing.begin(); i != missing.end(); i++) {
+                    std::cout << "    '" << *i << "'" << std::endl;
+                }
+            }
+            if (!extra.empty()) {
+                std::cout << "The following extra ids were encountered:" << std::endl;
+                for (StringSet::iterator i = extra.begin(); i != extra.end(); i++) {
+                    std::cout << "    '" << *i << "'" << std::endl;
+                }
+            }
+            return 1;
+        }
+    }
+};
+
+}} // namespace qpid::tests
+
+using namespace qpid::tests;
+
+int main(int argc, char** argv)
+{
+    try {
+        opts.parse(argc, argv);
+        Controller controller;
+        if (opts.init) controller.init();
+        if (opts.transfer) controller.transfer();
+        if (opts.check) return controller.check();
+        return 0;
+    } catch(const std::exception& e) {
+	std::cout << e.what() << std::endl;
+    }
+    return 2;
+}
diff --git a/qpid/cpp/src/tests/quick_perftest b/qpid/cpp/src/tests/quick_perftest
index 4f7cf3c..362f9ee 100755
--- a/qpid/cpp/src/tests/quick_perftest
+++ b/qpid/cpp/src/tests/quick_perftest
@@ -19,4 +19,4 @@
 # under the License.
 #
 
-exec `dirname $0`/run_test ./perftest --summary --count 100
+exec `dirname $0`/run_test ./qpid-perftest --summary --count 100
diff --git a/qpid/cpp/src/tests/quick_txtest b/qpid/cpp/src/tests/quick_txtest
index 938e380..c872fce 100755
--- a/qpid/cpp/src/tests/quick_txtest
+++ b/qpid/cpp/src/tests/quick_txtest
@@ -19,4 +19,4 @@
 # under the License.
 #
 
-exec `dirname $0`/run_test ./txtest --queues 4 --tx-count 10 --quiet
+exec `dirname $0`/run_test ./qpid-txtest --queues 4 --tx-count 10 --quiet
diff --git a/qpid/cpp/src/tests/run_perftest b/qpid/cpp/src/tests/run_perftest
index 1a9b934..5ad7c1f 100755
--- a/qpid/cpp/src/tests/run_perftest
+++ b/qpid/cpp/src/tests/run_perftest
@@ -19,10 +19,10 @@
 # under the License.
 #
 
-# Args: count [perftest options...]
-# Run a perftest with count multiplied.
+# Args: count [qpid-perftest options...]
+# Run a qpid-perftest with count multiplied.
 # 
 MULTIPLIER=3
 COUNT=`expr $1 \* $MULTIPLIER`
 shift
-exec `dirname $0`/run_test ./perftest --summary --count $COUNT "$@"
+exec `dirname $0`/run_test ./qpid-perftest --summary --count $COUNT "$@"
diff --git a/qpid/cpp/src/tests/ssl_test b/qpid/cpp/src/tests/ssl_test
index 4863eb9..a03341e 100755
--- a/qpid/cpp/src/tests/ssl_test
+++ b/qpid/cpp/src/tests/ssl_test
@@ -73,7 +73,7 @@ export QPID_SSL_CERT_DB=${CERT_DIR}
 export QPID_SSL_CERT_PASSWORD_FILE=${CERT_PW_FILE}
 
 ## Test connection via connection settings
-./perftest --count ${COUNT} --port ${PORT} -P ssl -b $TEST_HOSTNAME --summary
+./qpid-perftest --count ${COUNT} --port ${PORT} -P ssl -b $TEST_HOSTNAME --summary
 
 ## Test connection with a URL
 URL=amqp:ssl:$TEST_HOSTNAME:$PORT 
diff --git a/qpid/cpp/src/tests/topic_listener.cpp b/qpid/cpp/src/tests/topic_listener.cpp
deleted file mode 100644
index aa8c19d..0000000
--- a/qpid/cpp/src/tests/topic_listener.cpp
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-/**
- * This file provides one half of a test and example of a pub-sub
- * style of interaction. See topic_publisher.cpp for the other half,
- * in which the logic for publishing is defined.
- *
- * This file contains the listener logic. A listener will subscribe to
- * a logical 'topic'. It will count the number of messages it receives
- * and the time elapsed between the first one and the last one. It
- * recognises two types of 'special' message that tell it to (a) send
- * a report containing this information, (b) shutdown (i.e. stop
- * listening).
- */
-
-#include "TestOptions.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/MessageListener.h"
-#include "qpid/client/Session.h"
-#include "qpid/client/AsyncSession.h"
-#include "qpid/client/SubscriptionManager.h"
-#include "qpid/sys/SystemInfo.h"
-#include "qpid/sys/Time.h"
-#include "qpid/framing/FieldValue.h"
-#include <iostream>
-#include <sstream>
-
-using namespace qpid;
-using namespace qpid::client;
-using namespace qpid::sys;
-using namespace qpid::framing;
-using namespace std;
-
-namespace qpid {
-namespace tests {
-
-/**
- * A message listener implementation in which the runtime logic is
- * defined.
- */
-class Listener : public MessageListener{
-    Session session;
-    SubscriptionManager& mgr;
-    const string responseQueue;
-    const bool transactional;
-    bool init;
-    int count;
-    AbsTime start;
-
-    void shutdown();
-    void report();
-public:
-    Listener(const Session& session, SubscriptionManager& mgr, const string& reponseQueue, bool tx);
-    virtual void received(Message& msg);
-    Subscription subscription;
-};
-
-/**
- * A utility class for managing the options passed in.
- */
-struct Args : public qpid::TestOptions {
-    int ack;
-    bool transactional;
-    bool durable;
-    int prefetch;
-    string statusqueue;
-
-    Args() : ack(0), transactional(false), durable(false), prefetch(0) {
-        addOptions()
-            ("ack", optValue(ack, "MODE"), "Ack frequency in messages (defaults to half the prefetch value)")
-            ("transactional", optValue(transactional), "Use transactions")
-            ("durable", optValue(durable), "subscribers should use durable queues")
-            ("prefetch", optValue(prefetch, "N"), "prefetch count (0 implies no flow control, and no acking)")
-            ("status-queue", optValue(statusqueue, "QUEUE-NAME"), "Message queue to put status messages on");
-    }
-};
-
-Listener::Listener(const Session& s, SubscriptionManager& m, const string& _responseq, bool tx) :
-    session(s), mgr(m), responseQueue(_responseq), transactional(tx), init(false), count(0){}
-
-void Listener::received(Message& message){
-    if(!init){
-        start = now();
-        count = 0;
-        init = true;
-        cout << "Batch started." << endl;
-    }
-    string type = message.getHeaders().getAsString("TYPE");
-
-    if(string("TERMINATION_REQUEST") == type){
-        shutdown();
-    }else if(string("REPORT_REQUEST") == type){
-        subscription.accept(subscription.getUnaccepted()); // Accept everything upto this point
-        cout <<"Batch ended, sending report." << endl;
-        //send a report:
-        report();
-        init = false;
-    }else if (++count % 1000 == 0){
-        cout <<"Received " << count << " messages." << endl;
-    }
-}
-
-void Listener::shutdown(){
-    mgr.stop();
-}
-
-void Listener::report(){
-    AbsTime finish = now();
-    Duration time(start, finish);
-    stringstream reportstr;
-    reportstr << "Received " << count << " messages in "
-              << time/TIME_MSEC << " ms.";
-    Message msg(reportstr.str(), responseQueue);
-    msg.getHeaders().setString("TYPE", "REPORT");
-    session.messageTransfer(arg::destination="amq.direct", arg::content=msg, arg::acceptMode=1);
-    if(transactional){
-        sync(session).txCommit();
-    }
-}
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-/**
- * The main routine creates a Listener instance and sets it up to
- * consume from a private queue bound to the exchange with the
- * appropriate topic name.
- */
-int main(int argc, char** argv){
-    try{
-        Args args;
-        args.parse(argc, argv);
-        if(args.help)
-            cout << args << endl;
-        else {
-            Connection connection;
-            args.open(connection);
-            AsyncSession session = connection.newSession();
-
-            //declare exchange, queue and bind them:
-            session.queueDeclare(arg::queue="response");
-            std::string control = "control_" + session.getId().str();
-            if (args.durable) {
-                session.queueDeclare(arg::queue=control, arg::durable=true);
-            } else {
-                session.queueDeclare(arg::queue=control, arg::exclusive=true, arg::autoDelete=true);
-            }
-            session.exchangeBind(arg::exchange="amq.topic", arg::queue=control, arg::bindingKey="topic_control");
-
-            //set up listener
-            SubscriptionManager mgr(session);
-            Listener listener(session, mgr, "response", args.transactional);
-            SubscriptionSettings settings;
-            if (args.prefetch) {
-                settings.autoAck = (args.ack ? args.ack : (args.prefetch / 2));
-                settings.flowControl = FlowControl::messageCredit(args.prefetch);
-            } else {
-                settings.acceptMode = ACCEPT_MODE_NONE;
-                settings.flowControl = FlowControl::unlimited();
-            }
-            listener.subscription =  mgr.subscribe(listener, control, settings);
-            session.sync();
-
-            if( args.statusqueue.length() > 0 ) {
-                stringstream msg_str;
-                msg_str << "topic_listener: " << qpid::sys::SystemInfo::getProcessId();
-                session.messageTransfer(arg::content=Message(msg_str.str(), args.statusqueue));
-                cout << "Ready status put on queue '" << args.statusqueue << "'" << endl;
-            }
-
-            if (args.transactional) {
-                session.txSelect();
-            }
-
-            cout << "topic_listener: listening..." << endl;
-            mgr.run();
-            if (args.durable) {
-                session.queueDelete(arg::queue=control);
-            }
-            session.close();
-            cout << "closing connection" << endl;
-            connection.close();
-        }
-        return 0;
-    } catch (const std::exception& error) {
-        cout << "topic_listener: " << error.what() << endl;
-    }
-    return 1;
-}
diff --git a/qpid/cpp/src/tests/topic_publisher.cpp b/qpid/cpp/src/tests/topic_publisher.cpp
deleted file mode 100644
index 3381132..0000000
--- a/qpid/cpp/src/tests/topic_publisher.cpp
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-/**
- * This file provides one half of a test and example of a pub-sub
- * style of interaction. See topic_listener.cpp for the other half, in
- * which the logic for subscribers is defined.
- *
- * This file contains the publisher logic. The publisher will send a
- * number of messages to the exchange with the appropriate routing key
- * for the logical 'topic'. Once it has done this it will then send a
- * request that each subscriber report back with the number of message
- * it has received and the time that elapsed between receiving the
- * first one and receiving the report request. Once the expected
- * number of reports are received, it sends out a request that each
- * subscriber shutdown.
- */
-
-#include "TestOptions.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/MessageListener.h"
-#include "qpid/client/AsyncSession.h"
-#include "qpid/client/SubscriptionManager.h"
-#include "qpid/sys/Monitor.h"
-#include "qpid/sys/Time.h"
-#include <cstdlib>
-#include <iostream>
-
-using namespace qpid;
-using namespace qpid::client;
-using namespace qpid::sys;
-using namespace std;
-
-namespace qpid {
-namespace tests {
-
-/**
- * The publishing logic is defined in this class. It implements
- * message listener and can therfore be used to receive messages sent
- * back by the subscribers.
- */
-class Publisher {
-    AsyncSession session;
-    SubscriptionManager mgr;
-    LocalQueue queue;
-    const string controlTopic;
-    const bool transactional;
-    const bool durable;
-
-    string generateData(int size);
-
-public:
-    Publisher(const AsyncSession& session, const string& controlTopic, bool tx, bool durable);
-    int64_t publish(int msgs, int listeners, int size);
-    void terminate();
-};
-
-/**
- * A utility class for managing the options passed in to the test
- */
-struct Args : public TestOptions {
-    int messages;
-    int subscribers;
-    bool transactional;
-    bool durable;
-    int batches;
-    int delay;
-    int size;
-    string statusqueue;
-
-    Args() : messages(1000), subscribers(1),
-             transactional(false), durable(false),
-             batches(1), delay(0), size(256)
-    {
-        addOptions()
-            ("messages", optValue(messages, "N"), "how many messages to send")
-            ("subscribers", optValue(subscribers, "N"), "how many subscribers to expect reports from")
-            ("transactional", optValue(transactional), "client should use transactions")
-            ("durable", optValue(durable), "messages should be durable")
-            ("batches", optValue(batches, "N"), "how many batches to run")
-            ("delay", optValue(delay, "SECONDS"), "Causes a delay between each batch")
-            ("size", optValue(size, "BYTES"), "size of the published messages")
-            ("status-queue", optValue(statusqueue, "QUEUE-NAME"), "Message queue to read status messages from");
-    }
-};
-
-Publisher::Publisher(const AsyncSession& _session, const string& _controlTopic, bool tx, bool d) :
-    session(_session), mgr(session), controlTopic(_controlTopic), transactional(tx), durable(d)
-{
-    mgr.subscribe(queue, "response");
-}
-
-int64_t Publisher::publish(int msgs, int listeners, int size){
-    Message msg(generateData(size), controlTopic);
-    if (durable) {
-        msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
-    }
-    AbsTime start = now();
-
-    for(int i = 0; i < msgs; i++){
-        session.messageTransfer(arg::content=msg, arg::destination="amq.topic", arg::acceptMode=1);
-    }
-    //send report request
-    Message reportRequest("", controlTopic);
-    reportRequest.getHeaders().setString("TYPE", "REPORT_REQUEST");
-    session.messageTransfer(arg::content=reportRequest, arg::destination="amq.topic", arg::acceptMode=1);
-    if(transactional){
-        sync(session).txCommit();
-    }
-    //wait for a response from each listener (TODO, could log these)
-    for (int i = 0; i < listeners; i++) {
-        Message report = queue.pop();
-    }
-
-    if(transactional){
-        sync(session).txCommit();
-    }
-
-    AbsTime finish = now();
-    return Duration(start, finish);
-}
-
-string Publisher::generateData(int size){
-    string data;
-    for(int i = 0; i < size; i++){
-        data += ('A' + (i / 26));
-    }
-    return data;
-}
-
-void Publisher::terminate(){
-    //send termination request
-    Message terminationRequest("", controlTopic);
-    terminationRequest.getHeaders().setString("TYPE", "TERMINATION_REQUEST");
-    session.messageTransfer(arg::content=terminationRequest, arg::destination="amq.topic", arg::acceptMode=1);
-    if(transactional){
-        session.txCommit();
-    }
-}
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-int main(int argc, char** argv) {
-    try{
-        Args args;
-        args.parse(argc, argv);
-        if(args.help)
-            cout << args << endl;
-        else {
-            Connection connection;
-            args.open(connection);
-            AsyncSession session = connection.newSession();
-
-            // If status-queue is defined, wait for all expected listeners to join in before we start
-            if( args.statusqueue.length() > 0 ) {
-                cout << "Waiting for " << args.subscribers << " listeners..." << endl;
-                SubscriptionManager statusSubs(session);
-                LocalQueue statusQ;
-                statusSubs.subscribe(statusQ, args.statusqueue);
-                for (int i = 0; i < args.subscribers; i++) {
-                    Message m = statusQ.get();
-                    if( m.getData().find("topic_listener: ", 0) == 0 ) {
-                        cout << "Listener " << (i+1) << " of " << args.subscribers
-                            << " is ready (pid " << m.getData().substr(16, m.getData().length() - 16)
-                            << ")" << endl;
-                    } else {
-                        throw Exception(QPID_MSG("Unexpected message received on status queue: " << m.getData()));
-                    }
-                }
-            }
-
-            if (args.transactional) {
-                session.txSelect();
-            }
-            session.queueDeclare(arg::queue="response");
-            session.exchangeBind(arg::exchange="amq.direct", arg::queue="response", arg::bindingKey="response");
-
-            Publisher publisher(session, "topic_control", args.transactional, args.durable);
-
-            int batchSize(args.batches);
-            int64_t max(0);
-            int64_t min(0);
-            int64_t sum(0);
-            for(int i = 0; i < batchSize; i++){
-                if(i > 0 && args.delay) qpid::sys::sleep(args.delay);
-                int64_t msecs =
-                    publisher.publish(args.messages,
-                                      args.subscribers,
-                                      args.size) / TIME_MSEC;
-                if(!max || msecs > max) max = msecs;
-                if(!min || msecs < min) min = msecs;
-                sum += msecs;
-                cout << "Completed " << (i+1) << " of " << batchSize
-                    << " in " << msecs << "ms" << endl;
-            }
-            publisher.terminate();
-            int64_t avg = sum / batchSize;
-            if(batchSize > 1){
-                cout << batchSize << " batches completed. avg=" << avg <<
-                    ", max=" << max << ", min=" << min << endl;
-            }
-            session.close();
-            connection.close();
-        }
-        return 0;
-    }catch(exception& error) {
-        cout << error.what() << endl;
-    }
-    return 1;
-}
diff --git a/qpid/cpp/src/tests/topictest b/qpid/cpp/src/tests/topictest
index 8fd680e..257c24b 100755
--- a/qpid/cpp/src/tests/topictest
+++ b/qpid/cpp/src/tests/topictest
@@ -46,11 +46,11 @@ done
 subscribe() {
     echo Start subscriber $1
     LOG="subscriber_$1.log"
-    ./topic_listener $TRANSACTIONAL > $LOG 2>&1 && rm -f $LOG 
+    ./qpid-topic-listener $TRANSACTIONAL > $LOG 2>&1 && rm -f $LOG 
 }
 
 publish() {
-    ./topic_publisher --messages $MESSAGES --batches $BATCHES --subscribers $SUBSCRIBERS $HOST $TRANSACTIONAL
+    ./qpid-topic-publisher --messages $MESSAGES --batches $BATCHES --subscribers $SUBSCRIBERS $HOST $TRANSACTIONAL
 }
 
 for ((i=$SUBSCRIBERS ; i--; )); do
diff --git a/qpid/cpp/src/tests/txtest.cpp b/qpid/cpp/src/tests/txtest.cpp
deleted file mode 100644
index d0ba2f1..0000000
--- a/qpid/cpp/src/tests/txtest.cpp
+++ /dev/null
@@ -1,340 +0,0 @@
-/*
- *
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- */
-
-#include <algorithm>
-#include <iomanip>
-#include <iostream>
-#include <memory>
-#include <sstream>
-#include <vector>
-
-#include "TestOptions.h"
-#include "qpid/client/Connection.h"
-#include "qpid/client/Message.h"
-#include "qpid/client/AsyncSession.h"
-#include "qpid/client/SubscriptionManager.h"
-#include "qpid/framing/Array.h"
-#include "qpid/framing/Buffer.h"
-#include "qpid/framing/Uuid.h"
-#include "qpid/sys/Thread.h"
-
-using namespace qpid;
-using namespace qpid::client;
-using namespace qpid::sys;
-using std::string;
-
-namespace qpid {
-namespace tests {
-
-typedef std::vector<std::string> StringSet;
-
-struct Args : public qpid::TestOptions {
-    bool init, transfer, check;//actions
-    uint size;
-    bool durable;
-    uint queues;
-    string base;
-    uint msgsPerTx;
-    uint txCount;
-    uint totalMsgCount;
-    bool dtx;
-    bool quiet;
-
-    Args() : init(true), transfer(true), check(true),
-             size(256), durable(true), queues(2),
-             base("tx-test"), msgsPerTx(1), txCount(1), totalMsgCount(10),
-             dtx(false), quiet(false)
-    {
-        addOptions()
-
-            ("init", optValue(init, "yes|no"), "Declare queues and populate one with the initial set of messages.")
-            ("transfer", optValue(transfer, "yes|no"), "'Move' messages from one queue to another using transactions to ensure no message loss.")
-            ("check", optValue(check, "yes|no"), "Check that the initial messages are all still available.")
-            ("size", optValue(size, "N"), "message size")
-            ("durable", optValue(durable, "yes|no"), "use durable messages")
-            ("queues", optValue(queues, "N"), "number of queues")
-            ("queue-base-name", optValue(base, "<name>"), "base name for queues")
-            ("messages-per-tx", optValue(msgsPerTx, "N"), "number of messages transferred per transaction")
-            ("tx-count", optValue(txCount, "N"), "number of transactions per 'agent'")
-            ("total-messages", optValue(totalMsgCount, "N"), "total number of messages in 'circulation'")
-            ("dtx", optValue(dtx, "yes|no"), "use distributed transactions")
-            ("quiet", optValue(quiet), "reduce output from test");
-    }
-};
-
-const std::string chars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
-
-std::string generateData(uint size)
-{
-    if (size < chars.length()) {
-        return chars.substr(0, size);
-    }
-    std::string data;
-    for (uint i = 0; i < (size / chars.length()); i++) {
-        data += chars;
-    }
-    data += chars.substr(0, size % chars.length());
-    return data;
-}
-
-void generateSet(const std::string& base, uint count, StringSet& collection)
-{
-    for (uint i = 0; i < count; i++) {
-        std::ostringstream out;
-        out << base << "-" << (i+1);
-        collection.push_back(out.str());
-    }
-}
-
-Args opts;
-
-struct Client
-{
-    Connection connection;
-    AsyncSession session;
-
-    Client()
-    {
-        opts.open(connection);
-        session = connection.newSession();
-    }
-
-    ~Client()
-    {
-        try{
-            session.close();
-            connection.close();
-        } catch(const std::exception& e) {
-            std::cout << e.what() << std::endl;
-        }
-    }
-};
-
-struct Transfer : public Client, public Runnable
-{
-    std::string src;
-    std::string dest;
-    Thread thread;
-    framing::Xid xid;
-
-    Transfer(const std::string& to, const std::string& from) : src(to), dest(from), xid(0x4c414e47, "", from) {}
-
-    void run()
-    {
-        try {
-
-            if (opts.dtx) session.dtxSelect();
-            else session.txSelect();
-            SubscriptionManager subs(session);
-
-            LocalQueue lq;
-            SubscriptionSettings settings(FlowControl::messageWindow(opts.msgsPerTx));
-            settings.autoAck = 0; // Disabled
-            Subscription sub = subs.subscribe(lq, src, settings);
-
-            for (uint t = 0; t < opts.txCount; t++) {
-                Message in;
-                Message out("", dest);
-                if (opts.dtx) {
-                    setNewXid(xid);
-                    session.dtxStart(arg::xid=xid);
-                }
-                for (uint m = 0; m < opts.msgsPerTx; m++) {
-                    in = lq.pop();
-                    std::string& data = in.getData();
-                    if (data.size() != opts.size) {
-                        std::ostringstream oss;
-                        oss << "Message size incorrect: size=" << in.getData().size() << "; expected " << opts.size;
-                        throw std::runtime_error(oss.str());
-                    }
-                    out.setData(data);
-                    out.getMessageProperties().setCorrelationId(in.getMessageProperties().getCorrelationId());
-                    out.getDeliveryProperties().setDeliveryMode(in.getDeliveryProperties().getDeliveryMode());
-                    session.messageTransfer(arg::content=out, arg::acceptMode=1);
-                }
-                sub.accept(sub.getUnaccepted());
-                if (opts.dtx) {
-                    session.dtxEnd(arg::xid=xid);
-                    session.dtxPrepare(arg::xid=xid);
-                    session.dtxCommit(arg::xid=xid);
-                } else {
-                    session.txCommit();
-                }
-            }
-        } catch(const std::exception& e) {
-            std::cout << "Transfer interrupted: " << e.what() << std::endl;
-        }
-    }
-
-    void setNewXid(framing::Xid& xid) {
-        framing::Uuid uuid(true);
-        xid.setGlobalId(uuid.str());
-    }
-};
-
-struct Controller : public Client
-{
-    StringSet ids;
-    StringSet queues;
-
-    Controller()
-    {
-        generateSet(opts.base, opts.queues, queues);
-        generateSet("msg", opts.totalMsgCount, ids);
-    }
-
-    void init()
-    {
-        //declare queues
-        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
-            session.queueDeclare(arg::queue=*i, arg::durable=opts.durable);
-            session.sync();
-        }
-
-        Message msg(generateData(opts.size), *queues.begin());
-        if (opts.durable) {
-            msg.getDeliveryProperties().setDeliveryMode(framing::PERSISTENT);
-        }
-
-        //publish messages
-        for (StringSet::iterator i = ids.begin(); i != ids.end(); i++) {
-            msg.getMessageProperties().setCorrelationId(*i);
-            session.messageTransfer(arg::content=msg, arg::acceptMode=1);
-        }
-    }
-
-    void transfer()
-    {
-        boost::ptr_vector<Transfer> agents(opts.queues);
-        //launch transfer agents
-        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
-            StringSet::iterator next = i + 1;
-            if (next == queues.end()) next = queues.begin();
-
-            if (!opts.quiet) std::cout << "Transfering from " << *i << " to " << *next << std::endl;
-            agents.push_back(new Transfer(*i, *next));
-            agents.back().thread = Thread(agents.back());
-        }
-
-        for (boost::ptr_vector<Transfer>::iterator i = agents.begin(); i != agents.end(); i++) {
-            i->thread.join();
-        }
-    }
-
-    int check()
-    {
-        SubscriptionManager subs(session);
-
-        // Recover DTX transactions (if any)
-        if (opts.dtx) {
-            std::vector<std::string> inDoubtXids;
-            framing::DtxRecoverResult dtxRes = session.dtxRecover().get();
-            const framing::Array& xidArr = dtxRes.getInDoubt();
-            xidArr.collect(inDoubtXids);
-
-            if (inDoubtXids.size()) {
-                if (!opts.quiet) std::cout << "Recovering DTX in-doubt transaction(s):" << std::endl;
-                framing::StructHelper decoder;
-                framing::Xid xid;
-                // abort even, commit odd transactions
-                for (unsigned i = 0; i < inDoubtXids.size(); i++) {
-                    decoder.decode(xid, inDoubtXids[i]);
-                    if (!opts.quiet) std::cout << (i%2 ? " * aborting " : " * committing ");
-                    xid.print(std::cout);
-                    std::cout << std::endl;
-                    if (i%2) {
-                        session.dtxRollback(arg::xid=xid);
-                    } else {
-                        session.dtxCommit(arg::xid=xid);
-                    }
-                }
-            }
-        }
-
-        StringSet drained;
-        //drain each queue and verify the correct set of messages are available
-        for (StringSet::iterator i = queues.begin(); i != queues.end(); i++) {
-            //subscribe, allocate credit and flushn
-            LocalQueue lq;
-            SubscriptionSettings settings(FlowControl::unlimited(), ACCEPT_MODE_NONE);
-            subs.subscribe(lq, *i, settings);
-            session.messageFlush(arg::destination=*i);
-            session.sync();
-
-            uint count(0);
-            while (!lq.empty()) {
-                Message m = lq.pop();
-                //add correlation ids of received messages to drained
-                drained.push_back(m.getMessageProperties().getCorrelationId());
-                ++count;
-            }
-            if (!opts.quiet) std::cout << "Drained " << count << " messages from " << *i << std::endl;
-        }
-
-        sort(ids.begin(), ids.end());
-        sort(drained.begin(), drained.end());
-
-        //check that drained == ids
-        StringSet missing;
-        set_difference(ids.begin(), ids.end(), drained.begin(), drained.end(), back_inserter(missing));
-
-        StringSet extra;
-        set_difference(drained.begin(), drained.end(), ids.begin(), ids.end(), back_inserter(extra));
-
-        if (missing.empty() && extra.empty()) {
-            std::cout << "All expected messages were retrieved." << std::endl;
-            return 0;
-        } else {
-            if (!missing.empty()) {
-                std::cout << "The following ids were missing:" << std::endl;
-                for (StringSet::iterator i = missing.begin(); i != missing.end(); i++) {
-                    std::cout << "    '" << *i << "'" << std::endl;
-                }
-            }
-            if (!extra.empty()) {
-                std::cout << "The following extra ids were encountered:" << std::endl;
-                for (StringSet::iterator i = extra.begin(); i != extra.end(); i++) {
-                    std::cout << "    '" << *i << "'" << std::endl;
-                }
-            }
-            return 1;
-        }
-    }
-};
-
-}} // namespace qpid::tests
-
-using namespace qpid::tests;
-
-int main(int argc, char** argv)
-{
-    try {
-        opts.parse(argc, argv);
-        Controller controller;
-        if (opts.init) controller.init();
-        if (opts.transfer) controller.transfer();
-        if (opts.check) return controller.check();
-        return 0;
-    } catch(const std::exception& e) {
-	std::cout << e.what() << std::endl;
-    }
-    return 2;
-}
-- 
1.7.1.1

From f80f6ebf6ae83cc456ad225b18c9a92afd33e0fd Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Thu, 20 May 2010 19:52:55 +0000
Subject: [PATCH 005/129] Removed the logic in the broker's management agent that detected name collisions.
 The new logic will disambiguate colliding names by adding an underscore to the one
 being inserted.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@946773 13f79535-47bb-0310-9956-ffa450edef68
---
 .../cpp/include/qpid/management/ManagementObject.h |    1 +
 qpid/cpp/src/qpid/management/ManagementAgent.cpp   |  113 +++-----------------
 qpid/cpp/src/qpid/management/ManagementAgent.h     |    2 -
 qpid/cpp/src/qpid/management/ManagementObject.cpp  |   36 ++++---
 4 files changed, 37 insertions(+), 115 deletions(-)

diff --git a/qpid/cpp/include/qpid/management/ManagementObject.h b/qpid/cpp/include/qpid/management/ManagementObject.h
index 9c2d14f..6bbd7ec 100644
--- a/qpid/cpp/include/qpid/management/ManagementObject.h
+++ b/qpid/cpp/include/qpid/management/ManagementObject.h
@@ -78,6 +78,7 @@ public:
     QPID_COMMON_EXTERN bool equalV1(const ObjectId &other) const;
     QPID_COMMON_EXTERN void setV2Key(const std::string& _key) { v2Key = _key; }
     QPID_COMMON_EXTERN void setV2Key(const ManagementObject& object);
+    QPID_COMMON_EXTERN void disambiguate();
     QPID_COMMON_EXTERN void setAgentName(const std::string& _name) { agentName = _name; }
     QPID_COMMON_EXTERN const std::string& getAgentName() const { return agentName; }
     QPID_COMMON_EXTERN const std::string& getV2Key() const { return v2Key; }
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.cpp b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
index d4649a7..7f2dd69 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
@@ -135,12 +135,6 @@ ManagementAgent::~ManagementAgent ()
             delete object;
         }
         managementObjects.clear();
-
-        while (!deletedManagementObjects.empty()) {
-            ManagementObject* object = deletedManagementObjects.back();
-            delete object;
-            deletedManagementObjects.pop_back();
-        }
     }
 }
 
@@ -285,17 +279,11 @@ ObjectId ManagementAgent::addObject(ManagementObject* object, uint64_t persistId
     object->setObjectId(objId);
 
     {
-        sys::Mutex::ScopedLock lock (addLock);
+        sys::Mutex::ScopedLock lock(addLock);
         ManagementObjectMap::iterator destIter = newManagementObjects.find(objId);
-        if (destIter != newManagementObjects.end()) {
-            if (destIter->second->isDeleted()) {
-                newDeletedManagementObjects.push_back(destIter->second);
-                newManagementObjects.erase(destIter);
-            } else {
-                QPID_LOG(error, "ObjectId collision in addObject. class=" << object->getClassName() <<
-                         " key=" << objId.getV2Key());
-                return objId;
-            }
+        while (destIter != newManagementObjects.end()) {
+            objId.disambiguate();
+            destIter = newManagementObjects.find(objId);
         }
         newManagementObjects[objId] = object;
     }
@@ -323,17 +311,11 @@ ObjectId ManagementAgent::addObject(ManagementObject* object,
     object->setObjectId(objId);
 
     {
-        sys::Mutex::ScopedLock lock (addLock);
+        sys::Mutex::ScopedLock lock(addLock);
         ManagementObjectMap::iterator destIter = newManagementObjects.find(objId);
-        if (destIter != newManagementObjects.end()) {
-            if (destIter->second->isDeleted()) {
-                newDeletedManagementObjects.push_back(destIter->second);
-                newManagementObjects.erase(destIter);
-            } else {
-                QPID_LOG(error, "ObjectId collision in addObject. class=" << object->getClassName() <<
-                         " key=" << objId.getV2Key());
-                return objId;
-            }
+        while (destIter != newManagementObjects.end()) {
+            objId.disambiguate();
+            destIter = newManagementObjects.find(objId);
         }
         newManagementObjects[objId] = object;
     }
@@ -583,30 +565,16 @@ void ManagementAgent::moveNewObjectsLH()
     for (ManagementObjectMap::iterator iter = newManagementObjects.begin ();
          iter != newManagementObjects.end ();
          iter++) {
-        bool skip = false;
-        ManagementObjectMap::iterator destIter = managementObjects.find(iter->first);
-        if (destIter != managementObjects.end()) {
-            // We have an objectId collision with an existing object.  If the old object
-            // is deleted, move it to the deleted list.
-            if (destIter->second->isDeleted()) {
-                deletedManagementObjects.push_back(destIter->second);
-                managementObjects.erase(destIter);
-            } else {
-                QPID_LOG(error, "ObjectId collision in moveNewObjects. class=" <<
-                         iter->second->getClassName() << " key=" << iter->first.getV2Key());
-                skip = true;
-            }
+        ObjectId oid = iter->first;
+        ManagementObjectMap::iterator destIter = managementObjects.find(oid);
+        while (destIter != managementObjects.end()) {
+            oid.disambiguate();
+            destIter = managementObjects.find(oid);
         }
 
-        if (!skip)
-            managementObjects[iter->first] = iter->second;
+        managementObjects[oid] = iter->second;
     }
     newManagementObjects.clear();
-
-    while (!newDeletedManagementObjects.empty()) {
-        deletedManagementObjects.push_back(newDeletedManagementObjects.back());
-        newDeletedManagementObjects.pop_back();
-    }
 }
 
 void ManagementAgent::periodicProcessing (void)
@@ -760,58 +728,7 @@ void ManagementAgent::periodicProcessing (void)
         managementObjects.erase(iter->first);
     }
 
-    // Publish the deletion of objects created by insert-collision
-    bool collisionDeletions = false;
-    for (ManagementObjectVector::iterator cdIter = deletedManagementObjects.begin();
-         cdIter != deletedManagementObjects.end(); cdIter++) {
-        collisionDeletions = true;
-        {
-            if (qmf1Support) {
-                Buffer msgBuffer(msgChars, BUFSIZE);
-                encodeHeader(msgBuffer, 'c');
-                sBuf.clear();
-                (*cdIter)->writeProperties(sBuf);
-                msgBuffer.putRawData(sBuf);
-                contentSize = BUFSIZE - msgBuffer.available ();
-                msgBuffer.reset ();
-                stringstream key;
-                key << "console.obj.1.0." << (*cdIter)->getPackageName() << "." << (*cdIter)->getClassName();
-                sendBufferLH(msgBuffer, contentSize, mExchange, key.str());
-                QPID_LOG(trace, "SEND ContentInd for deleted object to=" << key.str());
-            }
-
-            if (qmf2Support) {
-                Variant::List list_;
-                Variant::Map  map_;
-                Variant::Map  values;
-                Variant::Map  headers;
-
-                map_["_schema_id"] = mapEncodeSchemaId((*cdIter)->getPackageName(),
-                                                       (*cdIter)->getClassName(),
-                                                       "_data",
-                                                       (*cdIter)->getMd5Sum());
-                (*cdIter)->writeTimestamps(map_);
-                (*cdIter)->mapEncodeValues(values, true, false);
-                map_["_values"] = values;
-                list_.push_back(map_);
-
-                headers["method"] = "indication";
-                headers["qmf.opcode"] = "_data_indication";
-                headers["qmf.content"] = "_data";
-                headers["qmf.agent"] = name_address;
-
-                stringstream key;
-                key << "agent.ind.data." << (*cdIter)->getPackageName() << "." << (*cdIter)->getClassName();
-
-                string content;
-                ListCodec::encode(list_, content);
-                sendBufferLH(content, "", headers, "amqp/list", v2Topic, key.str());
-                QPID_LOG(trace, "SEND ContentInd for deleted object to=" << key.str());
-            }
-        }
-    }
-
-    if (!deleteList.empty() || collisionDeletions) {
+    if (!deleteList.empty()) {
         deleteList.clear();
         deleteOrphanedAgentsLH();
     }
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.h b/qpid/cpp/src/qpid/management/ManagementAgent.h
index 8129c1e..d101ca1 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.h
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.h
@@ -242,13 +242,11 @@ private:
     // Protected by userLock
     //
     ManagementObjectMap          managementObjects;
-    ManagementObjectVector       deletedManagementObjects;
 
     //
     // Protected by addLock
     //
     ManagementObjectMap          newManagementObjects;
-    ManagementObjectVector       newDeletedManagementObjects;
 
     framing::Uuid                uuid;
 
diff --git a/qpid/cpp/src/qpid/management/ManagementObject.cpp b/qpid/cpp/src/qpid/management/ManagementObject.cpp
index 209c935..5cdf9ec 100644
--- a/qpid/cpp/src/qpid/management/ManagementObject.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementObject.cpp
@@ -30,6 +30,7 @@
 
 #include <stdlib.h>
 
+using namespace std;
 using namespace qpid;
 using namespace qpid::management;
 
@@ -71,19 +72,19 @@ ObjectId::ObjectId(AgentAttachment* _agent, uint8_t flags, uint16_t seq)
 }
 
 
-ObjectId::ObjectId(std::istream& in) : agent(0)
+ObjectId::ObjectId(istream& in) : agent(0)
 {
-    std::string text;
+    string text;
     in >> text;
     fromString(text);
 }
 
-ObjectId::ObjectId(const std::string& text) : agent(0)
+ObjectId::ObjectId(const string& text) : agent(0)
 {
     fromString(text);
 }
 
-void ObjectId::fromString(const std::string& text)
+void ObjectId::fromString(const string& text)
 {
 #define FIELDS 5
 #if defined (_WIN32) && !defined (atoll)
@@ -94,7 +95,7 @@ void ObjectId::fromString(const std::string& text)
     // V1: <flags>-<sequence>-<broker-bank>-<agent-bank>-<uint64-app-id>
     // V2: Not used
 
-    std::string copy(text.c_str());
+    string copy(text.c_str());
     char* cText;
     char* field[FIELDS];
     bool  atFieldStart = true;
@@ -124,7 +125,7 @@ void ObjectId::fromString(const std::string& text)
         (atoll(field[1]) << 48) +
         (atoll(field[2]) << 28);
 
-    agentName = std::string(field[3]);
+    agentName = string(field[3]);
     second = atoll(field[4]);
 }
 
@@ -146,7 +147,7 @@ bool ObjectId::equalV1(const ObjectId &other) const
 }
 
 // encode as V1-format binary
-void ObjectId::encode(std::string& buffer) const
+void ObjectId::encode(string& buffer) const
 {
     const uint32_t len = 16;
     char _data[len];
@@ -163,7 +164,7 @@ void ObjectId::encode(std::string& buffer) const
 }
 
 // decode as V1-format binary
-void ObjectId::decode(const std::string& buffer)
+void ObjectId::decode(const string& buffer)
 {
     const uint32_t len = 16;
     char _data[len];
@@ -174,18 +175,23 @@ void ObjectId::decode(const std::string& buffer)
     body.reset();
     first  = body.getLongLong();
     second = body.getLongLong();
-    v2Key = boost::lexical_cast<std::string>(second);
+    v2Key = boost::lexical_cast<string>(second);
 }
 
 // generate the V2 key from the index fields defined
 // in the schema.
 void ObjectId::setV2Key(const ManagementObject& object)
 {
-    std::stringstream oname;
+    stringstream oname;
     oname << object.getPackageName() << ":" << object.getClassName() << ":" << object.getKey();
     v2Key = oname.str();
 }
 
+void ObjectId::disambiguate()
+{
+    v2Key = v2Key + "_";
+}
+
 // encode as V2-format map
 void ObjectId::mapEncode(types::Variant::Map& map) const
 {
@@ -226,7 +232,7 @@ ObjectId::operator types::Variant::Map() const
 namespace qpid {
 namespace management {
 
-std::ostream& operator<<(std::ostream& out, const ObjectId& i)
+ostream& operator<<(ostream& out, const ObjectId& i)
 {
     uint64_t virtFirst = i.first;
     if (i.agent)
@@ -263,7 +269,7 @@ void ManagementObject::resourceDestroy()
 int ManagementObject::maxThreads = 1;
 int ManagementObject::nextThreadIndex = 0;
 
-void ManagementObject::writeTimestamps (std::string& buf) const
+void ManagementObject::writeTimestamps (string& buf) const
 {
     char _data[4000];
     qpid::framing::Buffer body(_data, 4000);
@@ -279,16 +285,16 @@ void ManagementObject::writeTimestamps (std::string& buf) const
     body.reset();
     body.getRawData(buf, len);
 
-    std::string oid;
+    string oid;
     objectId.encode(oid);
     buf += oid;
 }
 
-void ManagementObject::readTimestamps (const std::string& buf)
+void ManagementObject::readTimestamps (const string& buf)
 {
     char _data[4000];
     qpid::framing::Buffer body(_data, 4000);
-    std::string unused;
+    string unused;
     uint8_t unusedUuid[16];
 
     body.checkAvailable(buf.length());
-- 
1.7.1.1

From 856c5276a219a35752564a0d5b4657d381c24285 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Fri, 21 May 2010 15:40:39 +0000
Subject: [PATCH 006/129] Added setEncoding call to strings encoded from maps and lists.  Encoding is "utf8" for now.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@947045 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/bindings/qpid/dotnet/src/Message.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
index a3e966e..9c28e72 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
@@ -320,6 +320,7 @@ namespace messaging {
                 rpString = System::Convert::ToString(theObjp);
                 rString = QpidMarshal::ToNative(rpString);
                 targetp = rString;
+				targetp.setEncoding(QpidMarshal::ToNative("utf8"));
             }
             break;
 
-- 
1.7.1.1

From c940805177c8276f2ee9331c8db6f86f7baee8fd Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Tue, 25 May 2010 14:02:49 +0000
Subject: [PATCH 007/129] Replaced the earlier-removed init function (in ManagementAgent.h) that uses
 ConnectionSettings.  Created a ConnectionSettings in the qpid::management name
 space that mirrors that from the qpid::client namespace.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948046 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/include/qpid/agent/ManagementAgent.h      |    9 ++-
 .../include/qpid/management/ConnectionSettings.h   |  118 ++++++++++++++++++++
 qpid/cpp/src/CMakeLists.txt                        |    1 +
 qpid/cpp/src/Makefile.am                           |    2 +
 qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp    |   25 ++++-
 qpid/cpp/src/qpid/agent/ManagementAgentImpl.h      |    2 +-
 .../cpp/src/qpid/management/ConnectionSettings.cpp |   40 +++++++
 7 files changed, 192 insertions(+), 5 deletions(-)
 create mode 100644 qpid/cpp/include/qpid/management/ConnectionSettings.h
 create mode 100644 qpid/cpp/src/qpid/management/ConnectionSettings.cpp

diff --git a/qpid/cpp/include/qpid/agent/ManagementAgent.h b/qpid/cpp/include/qpid/agent/ManagementAgent.h
index 456b657..d534416 100644
--- a/qpid/cpp/include/qpid/agent/ManagementAgent.h
+++ b/qpid/cpp/include/qpid/agent/ManagementAgent.h
@@ -24,6 +24,7 @@
 #include "qpid/management/ManagementObject.h"
 #include "qpid/management/ManagementEvent.h"
 #include "qpid/management/Manageable.h"
+#include "qpid/management/ConnectionSettings.h"
 
 namespace qpid {
 namespace management {
@@ -103,6 +104,12 @@ class ManagementAgent
                       const std::string& mech = "PLAIN",
                       const std::string& proto = "tcp") = 0;
 
+    virtual void init(const management::ConnectionSettings& settings,
+                      uint16_t intervalSeconds = 10,
+                      bool useExternalThread = false,
+                      const std::string& storeFile = "") = 0;
+
+
     // Register a schema with the management agent.  This is normally called by the
     // package initializer generated by the management code generator.
     //
@@ -117,7 +124,7 @@ class ManagementAgent
                   const std::string& eventName,
                   uint8_t*    md5Sum,
                   management::ManagementEvent::writeSchemaCall_t schemaCall) = 0;
-
+
     // Add a management object to the agent.  Once added, this object shall be visible
     // in the greater management context.
     //
diff --git a/qpid/cpp/include/qpid/management/ConnectionSettings.h b/qpid/cpp/include/qpid/management/ConnectionSettings.h
new file mode 100644
index 0000000..b631ffa
--- /dev/null
+++ b/qpid/cpp/include/qpid/management/ConnectionSettings.h
@@ -0,0 +1,118 @@
+#ifndef _management_ConnectionSettings_h
+#define _management_ConnectionSettings_h
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+#include "qpid/CommonImportExport.h"
+#include "qpid/types/Variant.h"
+#include <string>
+
+namespace qpid {
+namespace management {
+
+/**
+ * Settings for a Connection.
+ */
+struct ConnectionSettings {
+
+    QPID_COMMON_EXTERN ConnectionSettings();
+    QPID_COMMON_EXTERN virtual ~ConnectionSettings();
+
+    /**
+     * The protocol used for the connection (defaults to 'tcp')
+     */
+    std::string protocol;
+
+    /**
+     * The host (or ip address) to connect to (defaults to 'localhost').
+     */
+    std::string host;
+    /**
+     * The port to connect to (defaults to 5672).
+     */
+    uint16_t port;
+    /**
+     * Allows an AMQP 'virtual host' to be specified for the
+     * connection.
+     */
+    std::string virtualhost;
+
+    /**
+     * The username to use when authenticating the connection. If not
+     * specified the current users login is used if available.
+     */
+    std::string username;
+    /**
+     * The password to use when authenticating the connection.
+     */
+    std::string password;
+    /**
+     * The SASL mechanism to use when authenticating the connection;
+     * the options are currently PLAIN or ANONYMOUS.
+     */
+    std::string mechanism;
+    /**
+     * Allows a locale to be specified for the connection.
+     */
+    std::string locale;
+    /**
+     * Allows a heartbeat frequency to be specified
+     */
+    uint16_t heartbeat;
+    /**
+     * The maximum number of channels that the client will request for
+     * use on this connection.
+     */
+    uint16_t maxChannels;
+    /**
+     * The maximum frame size that the client will request for this
+     * connection.
+     */
+    uint16_t maxFrameSize;
+    /**
+     * Limit the size of the connections send buffer . The buffer
+     * is limited to bounds * maxFrameSize.
+     */
+    unsigned int bounds;
+    /**
+     * If true, TCP_NODELAY will be set for the connection.
+     */
+    bool tcpNoDelay;
+    /**
+     * SASL service name
+     */
+    std::string service;
+    /**
+     * Minimum acceptable strength of any SASL negotiated security
+     * layer. 0 means no security layer required.
+     */
+    unsigned int minSsf;
+    /**
+     * Maximum acceptable strength of any SASL negotiated security
+     * layer. 0 means no security layer allowed.
+     */
+    unsigned int maxSsf;
+};
+
+}}
+
+#endif
+
diff --git a/qpid/cpp/src/CMakeLists.txt b/qpid/cpp/src/CMakeLists.txt
index aa40fd7..7083574 100644
--- a/qpid/cpp/src/CMakeLists.txt
+++ b/qpid/cpp/src/CMakeLists.txt
@@ -616,6 +616,7 @@ set (qpidcommon_SOURCES
      qpid/log/Selector.cpp
      qpid/log/Statement.cpp
      qpid/management/Buffer.cpp
+     qpid/management/ConnectionSettings.cpp
      qpid/management/Mutex.cpp
      qpid/management/Manageable.cpp
      qpid/management/ManagementObject.cpp
diff --git a/qpid/cpp/src/Makefile.am b/qpid/cpp/src/Makefile.am
index f2125eb..2df445e 100644
--- a/qpid/cpp/src/Makefile.am
+++ b/qpid/cpp/src/Makefile.am
@@ -421,6 +421,7 @@ libqpidcommon_la_SOURCES +=			\
   qpid/log/Selector.cpp				\
   qpid/log/Statement.cpp			\
   qpid/management/Buffer.cpp			\
+  qpid/management/ConnectionSettings.cpp	\
   qpid/management/Manageable.cpp		\
   qpid/management/ManagementObject.cpp		\
   qpid/management/Mutex.cpp			\
@@ -808,6 +809,7 @@ nobase_include_HEADERS +=			\
   ../include/qpid/log/Statement.h		\
   ../include/qpid/management/Args.h		\
   ../include/qpid/management/Buffer.h		\
+  ../include/qpid/management/ConnectionSettings.h \
   ../include/qpid/management/Manageable.h	\
   ../include/qpid/management/ManagementEvent.h	\
   ../include/qpid/management/ManagementObject.h	\
diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
index 5c2c6c5..6a07d8c 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
@@ -148,7 +148,7 @@ void ManagementAgentImpl::init(const string& brokerHost,
                                const string& mech,
                                const string& proto)
 {
-    client::ConnectionSettings settings;
+    management::ConnectionSettings settings;
     settings.protocol = proto;
     settings.host = brokerHost;
     settings.port = brokerPort;
@@ -158,7 +158,7 @@ void ManagementAgentImpl::init(const string& brokerHost,
     init(settings, intervalSeconds, useExternalThread, _storeFile);
 }
 
-void ManagementAgentImpl::init(const qpid::client::ConnectionSettings& settings,
+void ManagementAgentImpl::init(const qpid::management::ConnectionSettings& settings,
                                uint16_t intervalSeconds,
                                bool useExternalThread,
                                const string& _storeFile)
@@ -170,7 +170,26 @@ void ManagementAgentImpl::init(const qpid::client::ConnectionSettings& settings,
 
     QPID_LOG(info, "QMF Agent Initialized: broker=" << settings.host << ":" << settings.port <<
              " interval=" << intervalSeconds << " storeFile=" << _storeFile);
-    connectionSettings = settings;
+
+    //
+    // Convert from management::ConnectionSettings to client::ConnectionSettings
+    //
+    connectionSettings.protocol     = settings.protocol;
+    connectionSettings.host         = settings.host;
+    connectionSettings.port         = settings.port;
+    connectionSettings.virtualhost  = settings.virtualhost;
+    connectionSettings.username     = settings.username;
+    connectionSettings.password     = settings.password;
+    connectionSettings.mechanism    = settings.mechanism;
+    connectionSettings.locale       = settings.locale;
+    connectionSettings.heartbeat    = settings.heartbeat;
+    connectionSettings.maxChannels  = settings.maxChannels;
+    connectionSettings.maxFrameSize = settings.maxFrameSize;
+    connectionSettings.bounds       = settings.bounds;
+    connectionSettings.tcpNoDelay   = settings.tcpNoDelay;
+    connectionSettings.service      = settings.service;
+    connectionSettings.minSsf       = settings.minSsf;
+    connectionSettings.maxSsf       = settings.maxSsf;
 
     retrieveData();
     bootSequence++;
diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
index d160934..7d4531f 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
@@ -63,7 +63,7 @@ class ManagementAgentImpl : public ManagementAgent, public client::MessageListen
               const std::string& pwd = "guest",
               const std::string& mech = "PLAIN",
               const std::string& proto = "tcp");
-    void init(const client::ConnectionSettings& settings,
+    void init(const management::ConnectionSettings& settings,
               uint16_t intervalSeconds = 10,
               bool useExternalThread = false,
               const std::string& storeFile = "");
diff --git a/qpid/cpp/src/qpid/management/ConnectionSettings.cpp b/qpid/cpp/src/qpid/management/ConnectionSettings.cpp
new file mode 100644
index 0000000..1421a26
--- /dev/null
+++ b/qpid/cpp/src/qpid/management/ConnectionSettings.cpp
@@ -0,0 +1,40 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+#include "qpid/management/ConnectionSettings.h"
+#include "qpid/Version.h"
+
+qpid::management::ConnectionSettings::ConnectionSettings() :
+    protocol("tcp"),
+    host("localhost"), 
+    port(5672),
+    locale("en_US"),
+    heartbeat(0),
+    maxChannels(32767),
+    maxFrameSize(65535),
+    bounds(2),
+    tcpNoDelay(false),
+    service(qpid::saslName),
+    minSsf(0),
+    maxSsf(256)
+{}
+
+qpid::management::ConnectionSettings::~ConnectionSettings() {}
+
-- 
1.7.1.1

From 87a548b4b5e525bd887fd486469e63ed9bd79c03 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Tue, 25 May 2010 18:05:54 +0000
Subject: [PATCH 008/129] Bug 592999: Fix "mismatched cluster-id" errors during start up.

Intermittent failure when starting a persistent cluster with all clean stores.
Some brokers fail with:
  critical Unexpected error: Cluster-ID mismatch. Stores belong to different clusters.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948143 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 5b381f3f71c69ab356527965a639466bc3bc3615)
---
 qpid/cpp/src/qpid/cluster/Cluster.cpp |   47 +++++++++++++++++++--------------
 qpid/cpp/src/qpid/cluster/Cluster.h   |    2 +-
 2 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Cluster.cpp b/qpid/cpp/src/qpid/cluster/Cluster.cpp
index 099c3ef..6b9fcec 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.cpp
+++ b/qpid/cpp/src/qpid/cluster/Cluster.cpp
@@ -266,7 +266,7 @@ Cluster::Cluster(const ClusterSettings& set, broker::Broker& b) :
     initMap(self, settings.size),
     store(broker.getDataDir().getPath()),
     elder(false),
-    lastSize(0),
+    lastAliveCount(0),
     lastBroker(false),
     updateRetracted(false),
     error(*this)
@@ -290,7 +290,7 @@ Cluster::Cluster(const ClusterSettings& set, broker::Broker& b) :
         store.load();
         clusterId = store.getClusterId(); 
         QPID_LOG(notice, "Cluster store state: " << store)
-    }
+            }
     cpg.join(name);
     // pump the CPG dispatch manually till we get past PRE_INIT.
     while (state == PRE_INIT)
@@ -326,7 +326,8 @@ void Cluster::initialize() {
         mgmtObject->set_status("JOINING");
     }
 
-    // Run initMapCompleted immediately to process the initial configuration.
+    // Run initMapCompleted immediately to process the initial configuration
+    // that allowed us to transition out of PRE_INIT
     assert(state == INIT);
     initMapCompleted(*(Mutex::ScopedLock*)0); // Fake lock, single-threaded context.
 
@@ -433,7 +434,7 @@ const ClusterUpdateOfferBody* castUpdateOffer(const framing::AMQBody* body) {
 const ClusterConnectionAnnounceBody* castAnnounce( const framing::AMQBody *body) {
     return  (body && body->getMethod() &&
              body->getMethod()->isA<ClusterConnectionAnnounceBody>()) ?
-      static_cast<const ClusterConnectionAnnounceBody*>(body) : 0;
+        static_cast<const ClusterConnectionAnnounceBody*>(body) : 0;
 }
 
 // Handler for deliverEventQueue.
@@ -616,8 +617,8 @@ void Cluster::initMapCompleted(Lock& l) {
                      << " members, waiting for at least " << initMap.getRequiredSize());
             return;
         }
-        initMap.checkConsistent();
 
+        initMap.checkConsistent();
         elders = initMap.getElders();
         QPID_LOG(debug, *this << " elders: " << elders);
         if (elders.empty())
@@ -657,11 +658,11 @@ void Cluster::configChange(const MemberId&,
     MemberSet members = decodeMemberSet(membersStr);
     MemberSet left = decodeMemberSet(leftStr);
     MemberSet joined = decodeMemberSet(joinedStr);
-    QPID_LOG(notice, *this << " Membership update: " << members);
+    QPID_LOG(notice, *this << " configuration change: " << members);
     QPID_LOG_IF(notice, !left.empty(), *this << " Members left: " << left);
     QPID_LOG_IF(notice, !joined.empty(), *this << " Members joined: " << joined);
 
-    // Update initital status for members joining or leaving.
+    // If we are still joining, make sure there is someone to give us an update.
     elders = intersection(elders, members);
     if (elders.empty() && INIT < state && state < CATCHUP) {
         QPID_LOG(critical, "Cannot update, all potential updaters left the cluster.");
@@ -882,6 +883,7 @@ void Cluster::checkUpdateIn(Lock& l) {
         failoverExchange->setUrls(getUrls(l));
         mcast.mcastControl(ClusterReadyBody(ProtocolVersion(), myUrl.str()), self);
         state = CATCHUP;
+        memberUpdate(l);
         broker.setClusterUpdatee(false);
         if (mAgent) mAgent->suppress(false); // Enable management output.
         discarding = false;     // ok to set, we're stalled for update.
@@ -908,7 +910,7 @@ void Cluster::updateOutDone(Lock& l) {
     QPID_LOG(notice, *this << " update sent");
     assert(state == UPDATER);
     state = READY;
-     deliverEventQueue.start();       // Start processing events again.
+    deliverEventQueue.start();       // Start processing events again.
     makeOffer(map.firstJoiner(), l); // Try another offer
 }
 
@@ -959,15 +961,18 @@ void Cluster::stopFullCluster(Lock& ) {
 }
 
 void Cluster::memberUpdate(Lock& l) {
+    // Ignore config changes while we are joining.
+    if (state < CATCHUP) return;
     QPID_LOG(info, *this << " member update: " << map);
     std::vector<Url> urls = getUrls(l);
     std::vector<string> ids = getIds(l);
-    size_t size = urls.size();
+    size_t aliveCount = map.aliveCount();
+    assert(map.isAlive(self));
     failoverExchange->updateUrls(urls);
 
+    // Mark store clean if I am the only broker, dirty otherwise.
     if (store.hasStore()) {
-        // Mark store clean if I am the only broker, dirty otherwise.
-        if (size == 1 ) {
+        if (aliveCount == 1) {
             if (store.getState() != STORE_STATE_CLEAN_STORE) {
                 QPID_LOG(notice, *this << "Sole member of cluster, marking store clean.");
                 store.clean(Uuid(true));
@@ -975,26 +980,28 @@ void Cluster::memberUpdate(Lock& l) {
         }
         else {
             if (store.getState() != STORE_STATE_DIRTY_STORE) {
-                QPID_LOG(notice, "No longer sole cluster member, marking store dirty.");
+                QPID_LOG(notice, "Running in a cluster, marking store dirty.");
                 store.dirty();
             }
         }
     }
 
-    if (size == 1 && lastSize > 1 && state >= CATCHUP) {
+    // If I am the last member standing, set queue policies.
+    if (aliveCount == 1 && lastAliveCount > 1 && state >= CATCHUP) {
         QPID_LOG(notice, *this << " last broker standing, update queue policies");
         lastBroker = true;
         broker.getQueues().updateQueueClusterState(true);
     }
-    else if (size > 1 && lastBroker) {
-        QPID_LOG(notice, *this << " last broker standing joined by " << size-1 << " replicas, updating queue policies" << size);
+    else if (aliveCount > 1 && lastBroker) {
+        QPID_LOG(notice, *this << " last broker standing joined by " << aliveCount-1
+                 << " replicas, updating queue policies.");
         lastBroker = false;
         broker.getQueues().updateQueueClusterState(false);
     }
-    lastSize = size;
+    lastAliveCount = aliveCount;
 
     if (mgmtObject) {
-        mgmtObject->set_clusterSize(size); 
+        mgmtObject->set_clusterSize(urls.size()); 
         string urlstr;
         for(std::vector<Url>::iterator iter = urls.begin(); iter != urls.end(); iter++ ) {
             if (iter != urls.begin()) urlstr += ";";
@@ -1029,7 +1036,7 @@ std::ostream& operator<<(std::ostream& o, const Cluster& cluster) {
     assert(sizeof(STATE)/sizeof(*STATE) == Cluster::LEFT+1);
     o << "cluster(" << cluster.self << " " << STATE[cluster.state];
     if (cluster.error.isUnresolved()) o << "/error";
-    return o << ")";;
+    return o << ")";
 }
 
 MemberId Cluster::getId() const {
@@ -1071,8 +1078,8 @@ void Cluster::timerWakeup(const MemberId& , const std::string& name, Lock&) {
 
 void Cluster::timerDrop(const MemberId& , const std::string& name, Lock&) {
     QPID_LOG(debug, "Cluster timer drop " << map.getFrameSeq() << ": " << name)
-    if (state >= CATCHUP) // Pre catchup our timer isn't set up.
-        timer->deliverDrop(name);
+        if (state >= CATCHUP) // Pre catchup our timer isn't set up.
+            timer->deliverDrop(name);
 }
 
 bool Cluster::isElder() const {
diff --git a/qpid/cpp/src/qpid/cluster/Cluster.h b/qpid/cpp/src/qpid/cluster/Cluster.h
index 343a664..0d8b55c 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.h
+++ b/qpid/cpp/src/qpid/cluster/Cluster.h
@@ -273,7 +273,7 @@ class Cluster : private Cpg::Handler, public management::Manageable {
     ClusterMap map;
     MemberSet elders;
     bool elder;
-    size_t lastSize;
+    size_t lastAliveCount;
     bool lastBroker;
     sys::Thread updateThread;
     boost::optional<ClusterMap> updatedMap;
-- 
1.7.1.1

From d040ae874743e188779161c54d9e460f5b9ab9fe Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Thu, 27 May 2010 18:09:13 +0000
Subject: [PATCH 009/129] Fix for BZ-587190, preventing blocking on bounds.

QPID-2631: For blocking Bounds::expand() calls, only increase the current count when there is space. In SessionImpl::send() expand bounds before queueing frame. Expand bounds for all frames sent (including connection frames and cluster specific frames).

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948936 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 882b4c591fe13b1daf19eb65a8a2e2faf2bbb5b1)
---
 qpid/cpp/src/qpid/client/Bounds.cpp            |    6 +++---
 qpid/cpp/src/qpid/client/ConnectionHandler.cpp |   12 ++++++++++--
 qpid/cpp/src/qpid/client/ConnectionHandler.h   |    9 ++++++---
 qpid/cpp/src/qpid/client/ConnectionImpl.cpp    |    2 +-
 qpid/cpp/src/qpid/client/SessionImpl.cpp       |    2 +-
 qpid/cpp/src/qpid/cluster/UpdateClient.cpp     |   16 ++++++++++++++--
 qpid/cpp/src/tests/cluster_test.cpp            |    2 ++
 7 files changed, 37 insertions(+), 12 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/Bounds.cpp b/qpid/cpp/src/qpid/client/Bounds.cpp
index abb983a..cc2577d 100644
--- a/qpid/cpp/src/qpid/client/Bounds.cpp
+++ b/qpid/cpp/src/qpid/client/Bounds.cpp
@@ -33,19 +33,19 @@ Bounds::Bounds(size_t maxSize) : max(maxSize), current(0) {}
 bool Bounds::expand(size_t sizeRequired, bool block) {
     if (!max) return true;
     Waitable::ScopedLock l(lock);
-    current += sizeRequired;
     if (block) {
         Waitable::ScopedWait w(lock);
-        while (current > max) 
+        while (current + sizeRequired > max) 
             lock.wait();
     }
+    current += sizeRequired;
     return current <= max;
 }
 
 void Bounds::reduce(size_t size) {
     if (!max || size == 0) return;
     Waitable::ScopedLock l(lock);
-    if (current == 0) return;
+    assert(current >= size);
     current -= std::min(size, current);
     if (current < max && lock.hasWaiters()) {
         lock.notifyAll();
diff --git a/qpid/cpp/src/qpid/client/ConnectionHandler.cpp b/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
index 9d68448..6aea4c4 100644
--- a/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
+++ b/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
@@ -22,6 +22,7 @@
 #include "qpid/client/ConnectionHandler.h"
 
 #include "qpid/client/SaslFactory.h"
+#include "qpid/client/Bounds.h"
 #include "qpid/framing/amqp_framing.h"
 #include "qpid/framing/all_method_bodies.h"
 #include "qpid/framing/ClientInvoker.h"
@@ -70,8 +71,15 @@ CloseCode ConnectionHandler::convert(uint16_t replyCode)
     }
 }
 
-ConnectionHandler::ConnectionHandler(const ConnectionSettings& s, ProtocolVersion& v)
-    : StateManager(NOT_STARTED), ConnectionSettings(s), outHandler(*this), proxy(outHandler),
+ConnectionHandler::Adapter::Adapter(ConnectionHandler& h, Bounds& b) : handler(h), bounds(b) {}
+void ConnectionHandler::Adapter::handle(framing::AMQFrame& f)
+{ 
+    bounds.expand(f.encodedSize(), false);
+    handler.out(f);
+}
+
+ConnectionHandler::ConnectionHandler(const ConnectionSettings& s, ProtocolVersion& v, Bounds& b)
+    : StateManager(NOT_STARTED), ConnectionSettings(s), outHandler(*this, b), proxy(outHandler),
       errorCode(CLOSE_CODE_NORMAL), version(v)
 {
     insist = true;
diff --git a/qpid/cpp/src/qpid/client/ConnectionHandler.h b/qpid/cpp/src/qpid/client/ConnectionHandler.h
index 5f4b454..61709db 100644
--- a/qpid/cpp/src/qpid/client/ConnectionHandler.h
+++ b/qpid/cpp/src/qpid/client/ConnectionHandler.h
@@ -47,6 +47,8 @@ struct SecuritySettings;
 
 namespace client {
 
+class Bounds;
+
 class ConnectionHandler : private StateManager,
                           public ConnectionSettings,
                           public ChainableFrameHandler,
@@ -60,9 +62,10 @@ class ConnectionHandler : private StateManager,
     class Adapter : public framing::FrameHandler
     {
         ConnectionHandler& handler;
+        Bounds& bounds;
     public:
-        Adapter(ConnectionHandler& h) : handler(h) {}
-        void handle(framing::AMQFrame& f) { handler.out(f); }
+        Adapter(ConnectionHandler& h, Bounds& bounds);
+        void handle(framing::AMQFrame& f);
     }; 
 
     Adapter outHandler;
@@ -102,7 +105,7 @@ public:
     typedef boost::function<void(uint16_t, const std::string&)> ErrorListener;
     typedef boost::function<const qpid::sys::SecuritySettings*()> GetSecuritySettings;
 
-    ConnectionHandler(const ConnectionSettings&, framing::ProtocolVersion&);
+    ConnectionHandler(const ConnectionSettings&, framing::ProtocolVersion&, Bounds&);
 
     void received(framing::AMQFrame& f) { incoming(f); } 
 
diff --git a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
index d5fe748..99f4411 100644
--- a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
@@ -182,7 +182,7 @@ boost::shared_ptr<ConnectionImpl> ConnectionImpl::create(framing::ProtocolVersio
 
 ConnectionImpl::ConnectionImpl(framing::ProtocolVersion v, const ConnectionSettings& settings)
     : Bounds(settings.maxFrameSize * settings.bounds),
-      handler(settings, v),
+      handler(settings, v, *this),
       version(v),
       nextChannel(1),
       shutdownComplete(false),
diff --git a/qpid/cpp/src/qpid/client/SessionImpl.cpp b/qpid/cpp/src/qpid/client/SessionImpl.cpp
index b7ff430..b507625 100644
--- a/qpid/cpp/src/qpid/client/SessionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/SessionImpl.cpp
@@ -510,8 +510,8 @@ void SessionImpl::proxyOut(AMQFrame& frame) // network thread
 
 void SessionImpl::sendFrame(AMQFrame& frame, bool canBlock)
 {
-    channel.handle(frame);
     connection->expand(frame.encodedSize(), canBlock);
+    channel.handle(frame);
 }
 
 void SessionImpl::deliver(AMQFrame& frame) // network thread
diff --git a/qpid/cpp/src/qpid/cluster/UpdateClient.cpp b/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
index 1b74015..6499519 100644
--- a/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
+++ b/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
@@ -73,11 +73,22 @@ using namespace framing;
 namespace arg=client::arg;
 using client::SessionBase_0_10Access;
 
-struct ClusterConnectionProxy : public AMQP_AllProxy::ClusterConnection {
+struct ClusterConnectionProxy : public AMQP_AllProxy::ClusterConnection, public framing::FrameHandler 
+{
+    boost::shared_ptr<qpid::client::ConnectionImpl> connection;
+
     ClusterConnectionProxy(client::Connection c) :
-        AMQP_AllProxy::ClusterConnection(*client::ConnectionAccess::getImpl(c)) {}
+        AMQP_AllProxy::ClusterConnection(*static_cast<framing::FrameHandler*>(this)),
+        connection(client::ConnectionAccess::getImpl(c)) {}
     ClusterConnectionProxy(client::AsyncSession s) :
         AMQP_AllProxy::ClusterConnection(SessionBase_0_10Access(s).get()->out) {}
+
+    void handle(framing::AMQFrame& f)
+    {
+        assert(connection);
+        connection->expand(f.encodedSize(), false);
+        connection->handle(f);
+    }
 };
 
 // Create a connection with special version that marks it as a catch-up connection.
@@ -153,6 +164,7 @@ void UpdateClient::update() {
     ClusterConnectionMembershipBody membership;
     map.toMethodBody(membership);
     AMQFrame frame(membership);
+    client::ConnectionAccess::getImpl(connection)->expand(frame.encodedSize(), false);
     client::ConnectionAccess::getImpl(connection)->handle(frame);
 
     connection.close();
diff --git a/qpid/cpp/src/tests/cluster_test.cpp b/qpid/cpp/src/tests/cluster_test.cpp
index 8c18e57..d5f2c45 100644
--- a/qpid/cpp/src/tests/cluster_test.cpp
+++ b/qpid/cpp/src/tests/cluster_test.cpp
@@ -124,6 +124,7 @@ class Sender {
         f.setLastSegment(lastSeg);
         f.setFirstFrame(firstFrame);
         f.setLastFrame(lastFrame);
+        connection->expand(f.encodedSize(), false);
         connection->handle(f);
     }
 
@@ -209,6 +210,7 @@ QPID_AUTO_TEST_CASE(testBadClientData) {
     boost::shared_ptr<client::ConnectionImpl> ci =
         client::ConnectionAccess::getImpl(c0.connection);
     AMQFrame poison(boost::intrusive_ptr<AMQBody>(new PoisonPill));
+    ci->expand(poison.encodedSize(), false);
     ci->handle(poison);
     {
         ScopedSuppressLogging sl;
-- 
1.7.1.1

From 939a12c7d1f3fc56f328a23e496a87514f7bd42d Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Thu, 27 May 2010 20:02:18 +0000
Subject: [PATCH 010/129] Bug 558526: Fix issues with cluster+security

- was using "none" not empty string for no ID.
- was multicasting secure id for update and shadow connections.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948967 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit e41664eafd017f9eb9c675f573c4ae75eb476402)
---
 qpid/cpp/src/qpid/broker/ConnectionHandler.cpp |   17 ++++++-------
 qpid/cpp/src/qpid/broker/ConnectionHandler.h   |    7 +----
 qpid/cpp/src/qpid/cluster/Connection.cpp       |   30 ++++++++++++------------
 3 files changed, 24 insertions(+), 30 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
index b2d4210..bf1af2f 100644
--- a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
+++ b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
@@ -181,14 +181,6 @@ void ConnectionHandler::Handler::tuneOk(uint16_t /*channelmax*/,
     connection.setHeartbeatInterval(heartbeat);
 }
 
-void ConnectionHandler::Handler::callUserIdCallbacks ( ) {
-    string s;
-    if ( false == authenticator->getUsername(s) )
-        s = "none";
-    if ( userIdCallback )
-      userIdCallback ( s );
-}
-
 void ConnectionHandler::Handler::open(const string& /*virtualHost*/,
                                       const framing::Array& /*capabilities*/, bool /*insist*/)
 {
@@ -204,7 +196,14 @@ void ConnectionHandler::Handler::open(const string& /*virtualHost*/,
         if (sl.get()) secured->activateSecurityLayer(sl);
     }
 
-    callUserIdCallbacks ( );
+    if ( userIdCallback ) {
+        string s;
+        // Not checking the return value of getUsername, if there is
+        // no username then we want to call the userIdCallback anyway
+        // with an empty string.
+        authenticator->getUsername(s);
+        userIdCallback(s);
+    }
 }
 
 
diff --git a/qpid/cpp/src/qpid/broker/ConnectionHandler.h b/qpid/cpp/src/qpid/broker/ConnectionHandler.h
index 0372942..ecc8868 100644
--- a/qpid/cpp/src/qpid/broker/ConnectionHandler.h
+++ b/qpid/cpp/src/qpid/broker/ConnectionHandler.h
@@ -68,12 +68,7 @@ class ConnectionHandler : public framing::FrameHandler
         void closeOk();
 
         UserIdCallback userIdCallback;
-        void setUserIdCallback ( UserIdCallback fn ) {
-                 userIdCallback = fn;
-             };
-
-
-        void callUserIdCallbacks ( );
+        void setUserIdCallback ( UserIdCallback fn ) { userIdCallback = fn; };
 
 
         void start(const qpid::framing::FieldTable& serverProperties,
diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index d7e5ee5..18d0e0e 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -620,26 +620,26 @@ void Connection::managementAgents(const std::string& data) {
 }
 
 
-// Only the direct, non-shadow gets this call.
 void Connection::mcastUserId ( std::string & id ) {
-    cluster.getMulticast().mcastControl( ClusterConnectionSecureUserIdBody(ProtocolVersion(), string(id)), getId() );
-
-  {
-      sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
-      inConnectionNegotiation = false;
-      mcastSentButNotReceived = false;
-      connectionNegotiationMonitor.notify();
-  }
+    // Only the directly connected broker will mcast the secure user id, and only
+    // for client connections (not update connections)
+    if (isLocalClient())
+        cluster.getMulticast().mcastControl(
+            ClusterConnectionSecureUserIdBody(ProtocolVersion(), string(id)), getId() );
+    {
+        // This call signals the end of the connection negotiation phase.
+        sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
+        inConnectionNegotiation = false;
+        mcastSentButNotReceived = false;
+        connectionNegotiationMonitor.notify();
+    }
 }
 
 // All connections, shadow or not, get this call.
 void Connection::secureUserId(const std::string& id) {
-    if ( isShadow() ) {
-        // If the user ID is "none", it is not legitimate.  Take no action.
-        if ( strcmp ( id.c_str(), "none" ) ) {
-            connection->setUserId ( id );
-        }
-    }
+    // Only set the user ID on shadow connections, and only if id is not the empty string.
+    if ( isShadow() && !id.empty() )
+        connection->setUserId ( id );
 }
 
 
-- 
1.7.1.1

From 20d5d896b2ae01b717fc8c70ce67a95e6fb2c737 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@redhat.com>
Date: Thu, 27 May 2010 17:15:35 -0400
Subject: [PATCH 011/129] Bug 558526: Fixed: authentication with bad credentials causes cluster broker to exit.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948969 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 148033c59cf1b1f36ec4e80eef6e5c9beb65577b)
---
 qpid/cpp/src/qpid/cluster/Connection.cpp |   14 ++++++++++++--
 1 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index 18d0e0e..0772215 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -573,12 +573,22 @@ void Connection::queue(const std::string& encoded) {
 }
 
 void Connection::sessionError(uint16_t , const std::string& msg) {
-    cluster.flagError(*this, ERROR_TYPE_SESSION, msg);
+    // If we are negotiating the connection when it fails just close the connectoin.
+    // If it fails after that then we have to flag the error to the cluster.
+    if (inConnectionNegotiation)
+        cluster.getMulticast().mcastControl(ClusterConnectionDeliverCloseBody(), self);
+    else
+        cluster.flagError(*this, ERROR_TYPE_SESSION, msg);
     
 }
 
 void Connection::connectionError(const std::string& msg) {
-    cluster.flagError(*this, ERROR_TYPE_CONNECTION, msg);
+    // If we are negotiating the connection when it fails just close the connectoin.
+    // If it fails after that then we have to flag the error to the cluster.
+    if (inConnectionNegotiation)
+        cluster.getMulticast().mcastControl(ClusterConnectionDeliverCloseBody(), self);
+    else
+        cluster.flagError(*this, ERROR_TYPE_CONNECTION, msg);
 }
 
 void Connection::addQueueListener(const std::string& q, uint32_t listener) {
-- 
1.7.1.1

From bebf319d41b4f4abb9cd3b6cbb3af0183d249825 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Fri, 28 May 2010 13:37:22 +0000
Subject: [PATCH 012/129] BZ-591420: C++ clients on windows hang at program end

QPID-2598: Prevent exit hang on windows (at the expense of intermittent leak on exit under linux)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@949176 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 23ce1e7140ce5dd66788a0af066f3f12893046ac)
---
 qpid/cpp/src/qpid/client/ConnectionImpl.cpp |   18 ++++++++----------
 1 files changed, 8 insertions(+), 10 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
index 99f4411..8848554 100644
--- a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
@@ -83,7 +83,6 @@ class IOThread {
     int ioThreads;
     int connections;
     Mutex threadLock;
-    Condition noConnections;
     std::vector<Thread> t;
     Poller::shared_ptr poller_;
 
@@ -103,8 +102,6 @@ public:
     void sub() {
         ScopedLock<Mutex> l(threadLock);
         --connections;
-        if (connections == 0)
-            noConnections.notifyAll();
     }
 
     Poller::shared_ptr poller() const {
@@ -128,14 +125,15 @@ public:
     // and we can't do that before we're unloaded as we can't
     // restart the Poller after shutting it down
     ~IOThread() {
-        ScopedLock<Mutex> l(threadLock);
-        while (connections > 0) {
-            noConnections.wait(threadLock);
+        std::vector<Thread> threads;
+        {
+            ScopedLock<Mutex> l(threadLock);
+            if (poller_)
+                poller_->shutdown();
+            t.swap(threads);
         }
-        if (poller_)
-            poller_->shutdown();
-        for (int i=0; i<ioThreads; ++i) {
-            t[i].join();
+        for (std::vector<Thread>::iterator i = threads.begin(); i != threads.end(); ++i) {
+            i->join();
         }
     }
 };
-- 
1.7.1.1

From ad3a7e4927edc01a262a0ee3903f55592b41d337 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Mon, 31 May 2010 15:14:54 +0000
Subject: [PATCH 013/129] Bug 597362 Sporadic failure of check-long in cluster_tests.py test_failover.

Fixed assertion error in cluster_tests.py test_failover.

Added missing call to expandd in cluster/RetractClient.cpp

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@949767 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 866d10b0fdd44c6df8ea8fd2f497b1bc28fc432d)
---
 qpid/cpp/src/qpid/cluster/Connection.cpp    |    2 +-
 qpid/cpp/src/qpid/cluster/RetractClient.cpp |    1 +
 2 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index 0772215..43a4793 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -439,7 +439,7 @@ void Connection::membership(const FieldTable& joiners, const FieldTable& members
 }
 
 void Connection::retractOffer() {
-    QPID_LOG(debug, cluster << " incoming update retracted on connection " << *this);
+    QPID_LOG(info, cluster << " incoming update retracted on connection " << *this);
     cluster.updateInRetracted();
     self.second = 0;        // Mark this as completed update connection.
 }
diff --git a/qpid/cpp/src/qpid/cluster/RetractClient.cpp b/qpid/cpp/src/qpid/cluster/RetractClient.cpp
index 7d9f52f..a8c4b0d 100644
--- a/qpid/cpp/src/qpid/cluster/RetractClient.cpp
+++ b/qpid/cpp/src/qpid/cluster/RetractClient.cpp
@@ -52,6 +52,7 @@ void RetractClient::run() {
         c.open(url, connectionSettings);
         AutoClose ac(c);
         AMQFrame retract((ClusterConnectionRetractOfferBody()));
+        client::ConnectionAccess::getImpl(c)->expand(retract.encodedSize(), false);
         client::ConnectionAccess::getImpl(c)->handle(retract);
     } catch (const std::exception& e) {
         QPID_LOG(error, " while retracting retract to " << url << ": " << e.what()); 
-- 
1.7.1.1

From 93c3927ec66f0c98332286fe36a93d9ab0c2a752 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Fri, 28 May 2010 14:10:57 +0000
Subject: [PATCH 014/129] BZ-598350 - Fixed compilation error on windows

Fix compilation error on windows

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@949182 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 3453f90ba58b5036cb48210ed38883261bec1304)
---
 qpid/cpp/src/qpid/client/ConnectionHandler.cpp |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/ConnectionHandler.cpp b/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
index 6aea4c4..ba15e63 100644
--- a/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
+++ b/qpid/cpp/src/qpid/client/ConnectionHandler.cpp
@@ -72,7 +72,7 @@ CloseCode ConnectionHandler::convert(uint16_t replyCode)
 }
 
 ConnectionHandler::Adapter::Adapter(ConnectionHandler& h, Bounds& b) : handler(h), bounds(b) {}
-void ConnectionHandler::Adapter::handle(framing::AMQFrame& f)
+void ConnectionHandler::Adapter::handle(qpid::framing::AMQFrame& f)
 { 
     bounds.expand(f.encodedSize(), false);
     handler.out(f);
-- 
1.7.1.1

From 7f006841387b54cb0165cfa6d1423cd3fae06ce2 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 1 Jun 2010 09:25:23 +0000
Subject: [PATCH 015/129] BZ-597066

Don't use guest/guest default username/password, use None instead (this allows sasl implementation to infer the correct choice while retaining the ability to override it should that be desired)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@949971 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 5d7e22ba6f96a800a0af166559bea35652665951)
---
 qpid/python/qpid/messaging/endpoints.py |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 3016543..f5f957c 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -127,8 +127,8 @@ class Connection:
     else:
       self.port = default(url.port, options.get("port", AMQP_PORT))
     self.heartbeat = options.get("heartbeat")
-    self.username = default(url.user, options.get("username", "guest"))
-    self.password = default(url.password, options.get("password", "guest"))
+    self.username = default(url.user, options.get("username", None))
+    self.password = default(url.password, options.get("password", None))
 
     self.sasl_mechanisms = options.get("sasl_mechanisms")
     self.sasl_service = options.get("sasl_service", "qpidd")
-- 
1.7.1.1

From c9a6a956b126ccc27e03cb32cea269cc3a0b495f Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 1 Jun 2010 18:54:56 +0000
Subject: [PATCH 016/129] BZ-591650

QPID-2636: Ensure close is called for a disconnect preventing occasional leaks of abruptly terminated connections

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950201 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit fff0a43d69db6e62f1a21d52f752bf59c35fbd2a)
---
 qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp |   11 +++++------
 qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp  |   10 +++-------
 2 files changed, 8 insertions(+), 13 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp b/qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp
index 5771141..30a87d9 100644
--- a/qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp
+++ b/qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp
@@ -173,9 +173,8 @@ void AsynchIOHandler::readbuff(AsynchIO& , AsynchIO::BufferBase* buff) {
     }
 }
 
-void AsynchIOHandler::eof(AsynchIO&) {
-    QPID_LOG(debug, "DISCONNECTED [" << identifier << "]");
-    if (codec) codec->closed();
+void AsynchIOHandler::eof(AsynchIO& a) {
+    disconnect(a);
     readError = true;
     aio->queueWriteClose();
 }
@@ -190,9 +189,9 @@ void AsynchIOHandler::closedSocket(AsynchIO&, const Socket& s) {
     delete this;
 }
 
-void AsynchIOHandler::disconnect(AsynchIO& a) {
-    // treat the same as eof
-    eof(a);
+void AsynchIOHandler::disconnect(AsynchIO&) {
+    QPID_LOG(debug, "DISCONNECTED [" << identifier << "]");
+    if (codec) codec->closed();
 }
 
 // Notifications
diff --git a/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp b/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
index fd78861..cef9f1f 100644
--- a/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
+++ b/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
@@ -554,13 +554,9 @@ void AsynchIO::writeable(DispatchHandle& h) {
 }
         
 void AsynchIO::disconnected(DispatchHandle& h) {
-    // If we've already queued close do it instead of disconnected callback
-    if (queuedClose) {
-        close(h);
-    } else if (disCallback) {
-        disCallback(*this);
-        h.unwatch();
-    }
+    // If we have not already queued close then call disconnected callback before closing
+    if (!queuedClose && disCallback) disCallback(*this);
+    close(h);
 }
 
 /*
-- 
1.7.1.1

From 01a4cfaf9b3a3c5539f80f301722852d6ae37425 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 1 Jun 2010 18:59:52 +0000
Subject: [PATCH 017/129] BZ-598597 (fix client leaks on linux)

QPID-2004: Send disconnected event to any handles still registered after shutdown to ensure they can clean themselves up

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950205 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 292347fdbd7ef8e204ff3486b21497f33bff50fd)
---
 qpid/cpp/src/qpid/cluster/PollerDispatch.cpp |    6 ++-
 qpid/cpp/src/qpid/sys/Poller.h               |    2 +
 qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp  |   46 ++++++++++++++++++++++++++
 qpid/cpp/src/qpid/sys/solaris/ECFPoller.cpp  |    5 +++
 qpid/cpp/src/qpid/sys/windows/IocpPoller.cpp |    5 +++
 5 files changed, 62 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/PollerDispatch.cpp b/qpid/cpp/src/qpid/cluster/PollerDispatch.cpp
index a839ef8..b8d94b9 100644
--- a/qpid/cpp/src/qpid/cluster/PollerDispatch.cpp
+++ b/qpid/cpp/src/qpid/cluster/PollerDispatch.cpp
@@ -60,8 +60,10 @@ void PollerDispatch::dispatch(sys::DispatchHandle& h) {
 
 // Entry point: called if disconnected from  CPG.
 void PollerDispatch::disconnect(sys::DispatchHandle& ) {
-    QPID_LOG(critical, "Disconnected from cluster");
-    onError();
+    if (!poller->hasShutdown()) {
+        QPID_LOG(critical, "Disconnected from cluster");
+        onError();
+    }
 }
 
 }} // namespace qpid::cluster
diff --git a/qpid/cpp/src/qpid/sys/Poller.h b/qpid/cpp/src/qpid/sys/Poller.h
index 413d424..47b7606 100644
--- a/qpid/cpp/src/qpid/sys/Poller.h
+++ b/qpid/cpp/src/qpid/sys/Poller.h
@@ -99,6 +99,8 @@ public:
     QPID_COMMON_EXTERN void monitorHandle(PollerHandle& handle, Direction dir);
     QPID_COMMON_EXTERN void unmonitorHandle(PollerHandle& handle, Direction dir);
     QPID_COMMON_EXTERN Event wait(Duration timeout = TIME_INFINITE);
+
+    QPID_COMMON_EXTERN bool hasShutdown();
 };
 
 /**
diff --git a/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp b/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
index 7b0d0aa..9ae9bce 100644
--- a/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
+++ b/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
@@ -22,6 +22,7 @@
 #include "qpid/sys/Poller.h"
 #include "qpid/sys/IOHandle.h"
 #include "qpid/sys/Mutex.h"
+#include "qpid/sys/AtomicCount.h"
 #include "qpid/sys/DeletionManager.h"
 #include "qpid/sys/posix/check.h"
 #include "qpid/sys/posix/PrivatePosix.h"
@@ -33,6 +34,7 @@
 
 #include <assert.h>
 #include <queue>
+#include <set>
 #include <exception>
 
 namespace qpid {
@@ -156,6 +158,37 @@ PollerHandle::~PollerHandle() {
     PollerHandleDeletionManager.markForDeletion(impl);
 }
 
+class HandleSet
+{
+    Mutex lock;
+    std::set<PollerHandle*> handles;
+  public:
+    void add(PollerHandle*);
+    void remove(PollerHandle*);
+    void cleanup();
+};
+
+void HandleSet::add(PollerHandle* h)
+{
+    ScopedLock<Mutex> l(lock);
+    handles.insert(h);
+}
+void HandleSet::remove(PollerHandle* h)
+{
+    ScopedLock<Mutex> l(lock);
+    handles.erase(h);
+}
+void HandleSet::cleanup()
+{
+    // Inform all registered handles of disconnection
+    std::set<PollerHandle*> copy;
+    handles.swap(copy);
+    for (std::set<PollerHandle*>::const_iterator i = copy.begin(); i != copy.end(); ++i) {
+        Poller::Event event(*i, Poller::DISCONNECTED);
+        event.process();
+    }
+}
+
 /**
  * Concrete implementation of Poller to use the Linux specific epoll
  * interface
@@ -230,6 +263,8 @@ class PollerPrivate {
     bool isShutdown;
     InterruptHandle interruptHandle;
     ::sigset_t sigMask;
+    HandleSet registeredHandles;
+    AtomicCount threadCount;
 
     static ::__uint32_t directionToEpollEvent(Poller::Direction dir) {
         switch (dir) {
@@ -308,6 +343,7 @@ void Poller::registerHandle(PollerHandle& handle) {
     epe.data.u64 = 0; // Keep valgrind happy
     epe.data.ptr = &eh;
 
+    impl->registeredHandles.add(&handle);
     QPID_POSIX_CHECK(::epoll_ctl(impl->epollFd, EPOLL_CTL_ADD, eh.fd(), &epe));
 
     eh.setActive();
@@ -318,6 +354,7 @@ void Poller::unregisterHandle(PollerHandle& handle) {
     ScopedLock<Mutex> l(eh.lock);
     assert(!eh.isIdle());
 
+    impl->registeredHandles.remove(&handle);
     int rc = ::epoll_ctl(impl->epollFd, EPOLL_CTL_DEL, eh.fd(), 0);
     // Ignore EBADF since deleting a nonexistent fd has the overall required result!
     // And allows the case where a sloppy program closes the fd and then does the delFd()
@@ -475,6 +512,7 @@ void Poller::run() {
         ::sigfillset(&ss);
         ::pthread_sigmask(SIG_SETMASK, &ss, 0);
 
+        ++(impl->threadCount);
         do {
             Event event = wait();
 
@@ -486,6 +524,8 @@ void Poller::run() {
                 switch (event.type) {
                 case SHUTDOWN:
                     PollerHandleDeletionManager.destroyThreadState();
+                    //last thread to respond to shutdown cleans up:
+                    if (--(impl->threadCount) == 0) impl->registeredHandles.cleanup();
                     return;
                 default:
                     // This should be impossible
@@ -497,6 +537,12 @@ void Poller::run() {
         QPID_LOG(error, "IO worker thread exiting with unhandled exception: " << e.what());
     }
     PollerHandleDeletionManager.destroyThreadState();
+    --(impl->threadCount);
+}
+
+bool Poller::hasShutdown()
+{
+    return impl->isShutdown;
 }
 
 Poller::Event Poller::wait(Duration timeout) {
diff --git a/qpid/cpp/src/qpid/sys/solaris/ECFPoller.cpp b/qpid/cpp/src/qpid/sys/solaris/ECFPoller.cpp
index f12012c..06d542c 100644
--- a/qpid/cpp/src/qpid/sys/solaris/ECFPoller.cpp
+++ b/qpid/cpp/src/qpid/sys/solaris/ECFPoller.cpp
@@ -293,6 +293,11 @@ void Poller::shutdown() {
     impl->interrupt();
 }
 
+bool Poller::hasShutdown()
+{
+    return impl->isShutdown;
+}
+
 bool Poller::interrupt(PollerHandle& handle) {
     PollerPrivate::InterruptHandle& ih = impl->interruptHandle;
     PollerHandlePrivate& eh = *static_cast<PollerHandle&>(ih).impl;
diff --git a/qpid/cpp/src/qpid/sys/windows/IocpPoller.cpp b/qpid/cpp/src/qpid/sys/windows/IocpPoller.cpp
index 4fcc915..d326ab0 100755
--- a/qpid/cpp/src/qpid/sys/windows/IocpPoller.cpp
+++ b/qpid/cpp/src/qpid/sys/windows/IocpPoller.cpp
@@ -100,6 +100,11 @@ void Poller::shutdown() {
     PostQueuedCompletionStatus(impl->iocp, 0, key, 0);
 }
 
+bool Poller::hasShutdown()
+{
+    return impl->isShutdown;
+}
+
 bool Poller::interrupt(PollerHandle&) {
     return false;  // There's no concept of a registered handle.
 }
-- 
1.7.1.1

From 9e7d9497b8665b51075ddcfd1d01d805f009f78b Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 2 Jun 2010 10:24:10 +0000
Subject: [PATCH 018/129] Bug 538188 - Fixed connection.start() hangs if connection is not accepted

QPID-2637: Mark connection as failed if read from socket fails

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950472 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit ee264c0fdaede4c4fee624b289aad475c9bd31b0)
---
 qpid/python/qpid/connection.py |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/python/qpid/connection.py b/qpid/python/qpid/connection.py
index 2c61e5a..7dbefb8 100644
--- a/qpid/python/qpid/connection.py
+++ b/qpid/python/qpid/connection.py
@@ -132,6 +132,7 @@ class Connection(Framer):
 
   def detach_all(self):
     self.lock.acquire()
+    self.failed = True
     try:
       for ssn in self.attached.values():
         if self.close_code[0] != 200:
-- 
1.7.1.1

From e61456d966e7f4d35aaf9a0e04d2f4d5142c7ae3 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 2 Jun 2010 10:39:10 +0000
Subject: [PATCH 019/129] Bug 596907 - Fixed Default behaviour of new messaging client is to retry forever

QPID-664: Changed default for reconnect to false as that is more intuitive (e.g. when you specify the wrong broker address to start with)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950480 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit d5632b8d700ac1fdec1c9d380f6478c59f7a7f1b)
---
 .../src/qpid/client/amqp0_10/ConnectionImpl.cpp    |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
index 58f4f2a..f93df90 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
@@ -111,7 +111,7 @@ void convert(const Variant::Map& from, ConnectionSettings& to)
 }
 
 ConnectionImpl::ConnectionImpl(const std::string& url, const Variant::Map& options) : 
-    reconnect(true), timeout(-1), limit(-1),
+    reconnect(false), timeout(-1), limit(-1),
     minReconnectInterval(3), maxReconnectInterval(60),
     retries(0), reconnectOnLimitExceeded(true)
 {
-- 
1.7.1.1

From b63360247ac0a9a8faf5a47c2dc4c53e079125c0 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Wed, 2 Jun 2010 15:49:49 +0000
Subject: [PATCH 020/129] Bug 598516: Fixed sporadic client "reserved bits not 0" exceptions with cluster + encryption.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950608 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit e15ce475ce200560b650f8d6c512ffdaa42e76f5)
---
 qpid/cpp/src/qpid/broker/ConnectionHandler.cpp |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
index bf1af2f..225735d 100644
--- a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
+++ b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
@@ -188,7 +188,6 @@ void ConnectionHandler::Handler::open(const string& /*virtualHost*/,
     framing::Array array(0x95); // str16 array
     for (std::vector<Url>::iterator i = urls.begin(); i < urls.end(); ++i)
         array.add(boost::shared_ptr<Str16Value>(new Str16Value(i->str())));
-    proxy.openOk(array);
 
     //install security layer if one has been negotiated:
     if (secured) {
@@ -204,6 +203,7 @@ void ConnectionHandler::Handler::open(const string& /*virtualHost*/,
         authenticator->getUsername(s);
         userIdCallback(s);
     }
+    proxy.openOk(array);
 }
 
 
-- 
1.7.1.1

From 548ca3db11f4ce05063393bf402e4467684ca624 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 2 Jun 2010 19:45:34 +0000
Subject: [PATCH 021/129] BZ-598597: Relax cluster assertions, necessitated by previous fix for leaks.

QPID-2004: Now that connections are cleaned up on shutdown, some cluster safety assertions need to be relaxed.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950735 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 7776e2efa144a6179311a8e95e27c298a233d494)
---
 qpid/cpp/src/qpid/broker/Queue.cpp         |    1 -
 qpid/cpp/src/qpid/broker/SemanticState.cpp |    2 --
 2 files changed, 0 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Queue.cpp b/qpid/cpp/src/qpid/broker/Queue.cpp
index 42c678c..8c9e5b8 100644
--- a/qpid/cpp/src/qpid/broker/Queue.cpp
+++ b/qpid/cpp/src/qpid/broker/Queue.cpp
@@ -374,7 +374,6 @@ bool Queue::browseNextMessage(QueuedMessage& m, Consumer::shared_ptr c)
 
 void Queue::removeListener(Consumer::shared_ptr c)
 {
-    assertClusterSafe();
     QueueListeners::NotificationSet set;
     {
         Mutex::ScopedLock locker(messageLock);
diff --git a/qpid/cpp/src/qpid/broker/SemanticState.cpp b/qpid/cpp/src/qpid/broker/SemanticState.cpp
index e85d835..b8981b4 100644
--- a/qpid/cpp/src/qpid/broker/SemanticState.cpp
+++ b/qpid/cpp/src/qpid/broker/SemanticState.cpp
@@ -391,7 +391,6 @@ SemanticState::ConsumerImpl::~ConsumerImpl()
 
 void SemanticState::cancel(ConsumerImpl::shared_ptr c)
 {
-    assertClusterSafe();
     c->disableNotify();
     if (session.isAttached())
         session.getConnection().outputTasks.removeOutputTask(c.get());
@@ -698,7 +697,6 @@ void SemanticState::ConsumerImpl::enableNotify()
 void SemanticState::ConsumerImpl::disableNotify()
 {
     Mutex::ScopedLock l(lock);
-    assertClusterSafe();
     notifyEnabled = false;
 }
 
-- 
1.7.1.1

From b90d8b5e0fa2723dfb16c8d7b597d906e447b762 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Thu, 3 Jun 2010 10:07:23 +0000
Subject: [PATCH 022/129] Bug 599470 - Fixed - options string for connection does not work for some types

QPID-2640: Don't try to cast integer-like values during parsing; leave as strings and let the usage context determine the correct type to cast to.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950932 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit a1d95779da866899f1bdc0a2dd00f21dc131defb)
---
 qpid/cpp/src/qpid/messaging/AddressParser.cpp |    3 ---
 1 files changed, 0 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/messaging/AddressParser.cpp b/qpid/cpp/src/qpid/messaging/AddressParser.cpp
index 4f22410..aea9118 100644
--- a/qpid/cpp/src/qpid/messaging/AddressParser.cpp
+++ b/qpid/cpp/src/qpid/messaging/AddressParser.cpp
@@ -200,9 +200,6 @@ bool AddressParser::readSimpleValue(Variant& value)
     std::string s;
     if (readWord(s)) {
         value = s;
-        try { value = value.asInt32(); return true; } catch (const InvalidConversion&) {}
-        try { value = value.asInt64(); return true; } catch (const InvalidConversion&) {}
-        try { value = value.asDouble(); return true; } catch (const InvalidConversion&) {}
         return true;
     } else {
         return false;
-- 
1.7.1.1

From fec18359ad3c942fb2168bfbfdbe0c43e071fb27 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Wed, 2 Jun 2010 21:21:38 +0000
Subject: [PATCH 023/129] Fix error string for invalid options, fix exception handling in qpid_send/qpid_receive.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@950763 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 7bbadfd55b56d1917c6b3f62601aedcc07ad2018)
---
 qpid/cpp/src/qpid/messaging/Connection.cpp |    2 +-
 qpid/cpp/src/tests/qpid_receive.cpp        |   19 ++++++++++---------
 qpid/cpp/src/tests/qpid_send.cpp           |   15 ++++++++-------
 3 files changed, 19 insertions(+), 17 deletions(-)

diff --git a/qpid/cpp/src/qpid/messaging/Connection.cpp b/qpid/cpp/src/qpid/messaging/Connection.cpp
index 53d3756..2bd5ba9 100644
--- a/qpid/cpp/src/qpid/messaging/Connection.cpp
+++ b/qpid/cpp/src/qpid/messaging/Connection.cpp
@@ -46,7 +46,7 @@ Connection::Connection(const std::string& url, const std::string& o)
     if (o.empty() || parser.parseMap(options)) {
         PI::ctor(*this, new qpid::client::amqp0_10::ConnectionImpl(url, options));
     } else {
-        throw InvalidOptionString(o);
+        throw InvalidOptionString("Invalid option string: " + o);
     }
 }
 Connection::Connection(const std::string& url, const Variant::Map& options)
diff --git a/qpid/cpp/src/tests/qpid_receive.cpp b/qpid/cpp/src/tests/qpid_receive.cpp
index 15b8d76..294a60b 100644
--- a/qpid/cpp/src/tests/qpid_receive.cpp
+++ b/qpid/cpp/src/tests/qpid_receive.cpp
@@ -103,7 +103,7 @@ struct Options : public qpid::Options
             ("report-total", qpid::optValue(reportTotal), "Report total throughput and latency statistics")
             ("report-every", qpid::optValue(reportEvery,"N"), "Report throughput and latency statistics every N messages.")
             ("report-header", qpid::optValue(reportHeader, "yes|no"), "Headers on report.")            ("ready-address", qpid::optValue(readyAddress, "ADDRESS"),
-             "send a message to this address when ready to receive")
+                                                                                                        "send a message to this address when ready to receive")
             ("help", qpid::optValue(help), "print this usage statement");
         add(log);
     }
@@ -162,10 +162,11 @@ using namespace qpid::tests;
 
 int main(int argc, char ** argv)
 {
-    Options opts;
-    if (opts.parse(argc, argv)) {
-        Connection connection(opts.url, opts.connectionOptions);
-        try {
+    Connection connection;
+    try {
+        Options opts;
+        if (opts.parse(argc, argv)) {
+            connection = Connection(opts.url, opts.connectionOptions);
             connection.open();
             std::auto_ptr<FailoverUpdates> updates(opts.failoverUpdates ? new FailoverUpdates(connection) : 0);
             Session session = opts.tx ? connection.createTransactionalSession() : connection.createSession();
@@ -227,10 +228,10 @@ int main(int argc, char ** argv)
             session.close();
             connection.close();
             return 0;
-        } catch(const std::exception& error) {
-            std::cerr << "Failure: " << error.what() << std::endl;
-            connection.close();
         }
+    } catch(const std::exception& error) {
+        std::cerr << "Failure: " << error.what() << std::endl;
+        connection.close();
+        return 1;
     }
-    return 1;
 }
diff --git a/qpid/cpp/src/tests/qpid_send.cpp b/qpid/cpp/src/tests/qpid_send.cpp
index 7fef57a..98d7cd6 100644
--- a/qpid/cpp/src/tests/qpid_send.cpp
+++ b/qpid/cpp/src/tests/qpid_send.cpp
@@ -247,10 +247,11 @@ class MapContentGenerator   : public ContentGenerator {
 
 int main(int argc, char ** argv)
 {
+    Connection connection;
     Options opts;
-    if (opts.parse(argc, argv)) {
-        Connection connection(opts.url, opts.connectionOptions);
-        try {
+    try {
+        if (opts.parse(argc, argv)) {
+             connection = Connection(opts.url, opts.connectionOptions);
             connection.open();
             std::auto_ptr<FailoverUpdates> updates(opts.failoverUpdates ? new FailoverUpdates(connection) : 0);
             Session session = opts.tx ? connection.createTransactionalSession() : connection.createSession();
@@ -327,10 +328,10 @@ int main(int argc, char ** argv)
             session.close();
             connection.close();
             return 0;
-        } catch(const std::exception& error) {
-            std::cout << "Failed: " << error.what() << std::endl;
-            connection.close();
         }
+    } catch(const std::exception& error) {
+        std::cout << "Failed: " << error.what() << std::endl;
+        connection.close();
+        return 1;
     }
-    return 1;
 }
-- 
1.7.1.1

From 4b96352abe88aa513434d59812a6d44679d2acd8 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Fri, 4 Jun 2010 15:23:32 +0000
Subject: [PATCH 024/129] Bug 589675 - Fix initialization-order problem with URL protocol tags.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951441 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 4424bc7676367fef809d0de1fb720c1c50c6bd08)
---
 qpid/cpp/include/qpid/Url.h |    2 --
 qpid/cpp/src/qpid/Url.cpp   |   38 +++++++++++++++++++++++++++++++-------
 2 files changed, 31 insertions(+), 9 deletions(-)

diff --git a/qpid/cpp/include/qpid/Url.h b/qpid/cpp/include/qpid/Url.h
index 8093161..353e9d5 100644
--- a/qpid/cpp/include/qpid/Url.h
+++ b/qpid/cpp/include/qpid/Url.h
@@ -82,8 +82,6 @@ struct Url : public std::vector<Address> {
     QPID_COMMON_EXTERN std::string getPass() const;
 
   private:
-    static std::vector<std::string> protocols;
-
     mutable std::string cache;  // cache string form for efficiency.
     std::string user, pass;
 
diff --git a/qpid/cpp/src/qpid/Url.cpp b/qpid/cpp/src/qpid/Url.cpp
index 0b9fdbf..ab796f4 100644
--- a/qpid/cpp/src/qpid/Url.cpp
+++ b/qpid/cpp/src/qpid/Url.cpp
@@ -22,10 +22,12 @@
 #include "qpid/sys/SystemInfo.h"
 #include "qpid/sys/StrError.h"
 #include "qpid/client/Connector.h"
-
+#include "qpid/sys/Mutex.h"
 #include <boost/lexical_cast.hpp>
 
 #include <algorithm>
+#include <vector>
+#include <string>
 
 #include <string.h>
 
@@ -34,6 +36,32 @@ using boost::lexical_cast;
 
 namespace qpid {
 
+class ProtocolTags {
+  public:
+    bool find(const string& tag) {
+        sys::Mutex::ScopedLock l(lock);
+        return std::find(tags.begin(), tags.end(), tag) != tags.end();
+    }
+
+    void add(const string& tag) {
+        sys::Mutex::ScopedLock l(lock);
+        if (std::find(tags.begin(), tags.end(), tag) == tags.end())
+            tags.push_back(tag);
+    }
+
+    static ProtocolTags& instance() {
+        /** First call must be made while program is still single threaded.
+         * This will be the case since tags are registered in static initializers.
+         */
+        static ProtocolTags tags;
+        return tags;
+    }
+    
+  private:
+    sys::Mutex lock;
+    vector<string> tags;
+};
+
 Url::Invalid::Invalid(const string& s) : Exception(s) {}
 
 Url Url::getHostNameUrl(uint16_t port) {
@@ -119,9 +147,7 @@ class UrlParser {
         const char* j = std::find(i,end,':');
         if (j != end) {
             string tag(i,j);
-            if (std::find(Url::protocols.begin(), Url::protocols.end(), tag) !=
-                Url::protocols.end())
-            {
+            if (ProtocolTags::instance().find(tag)) {
                 i = j+1;
                 result = tag;
                 return true;
@@ -234,8 +260,6 @@ std::istream& operator>>(std::istream& is, Url& url) {
     return is;
 }
 
-std::vector<std::string> Url::protocols;
-
-void Url::addProtocol(const std::string& tag) { protocols.push_back(tag); }
+void Url::addProtocol(const std::string& tag) { ProtocolTags::instance().add(tag); }
 
 } // namespace qpid
-- 
1.7.1.1

From 8504208f6107251003272fec9055cc937cef5f70 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@redhat.com>
Date: Fri, 4 Jun 2010 11:43:49 -0400
Subject: [PATCH 025/129] Fixed sporadic failure of cluster_tests.py sasl_test

- added missing initializer for cluster::Connection::inConnectionNegotiation

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951452 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 888a7d9b4d896314a4515dfb0c9f172b87e0a1cd)
---
 qpid/cpp/src/qpid/cluster/Connection.cpp |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index 43a4793..9a8cab2 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -108,7 +108,8 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
     mcastFrameHandler(cluster.getMulticast(), self),
     updateIn(c.getUpdateReceiver()),
     secureConnection(0),
-    mcastSentButNotReceived(false)
+    mcastSentButNotReceived(false),
+    inConnectionNegotiation(true)
 {
     cluster.addLocalConnection(this);
     if (isLocalClient()) {
-- 
1.7.1.1

From f2fd925d0846d940af997d9c6451404fa054a137 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Fri, 4 Jun 2010 17:36:47 -0400
Subject: [PATCH 026/129] Trivial change: Eliminate windows warning

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951502 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/include/qpid/framing/FieldValue.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/include/qpid/framing/FieldValue.h b/qpid/cpp/include/qpid/framing/FieldValue.h
index 8af1f8d..19220e7 100644
--- a/qpid/cpp/include/qpid/framing/FieldValue.h
+++ b/qpid/cpp/include/qpid/framing/FieldValue.h
@@ -123,7 +123,7 @@ template <>
 inline bool FieldValue::convertsTo<std::string>() const { return data->convertsToString(); }
 
 template <>
-inline int FieldValue::get<int>() const { return data->getInt(); }
+inline int FieldValue::get<int>() const { return static_cast<int>(data->getInt()); }
 
 template <>
 inline int64_t FieldValue::get<int64_t>() const { return data->getInt(); }
-- 
1.7.1.1

From bb0b3b1a4014604dd951ae67e566d1ef3ecfccc1 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Fri, 4 Jun 2010 17:48:44 -0400
Subject: [PATCH 027/129] BZ 582460: Remove dependency on qpid::sys::AbsTime (which uses boost on Windows)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951150 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/examples/messaging/spout.cpp |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/qpid/cpp/examples/messaging/spout.cpp b/qpid/cpp/examples/messaging/spout.cpp
index 05d66f6..e100560 100644
--- a/qpid/cpp/examples/messaging/spout.cpp
+++ b/qpid/cpp/examples/messaging/spout.cpp
@@ -25,19 +25,16 @@
 #include <qpid/messaging/Sender.h>
 #include <qpid/messaging/Session.h>
 #include <qpid/types/Variant.h>
-#include <qpid/sys/Time.h>
 
 #include <iostream>
 #include <sstream>
 #include <vector>
+#include <ctime>
 
 #include "OptionParser.h"
 
 using namespace qpid::messaging;
 using namespace qpid::types;
-using qpid::sys::AbsTime;
-using qpid::sys::now;
-using qpid::sys::TIME_INFINITE;
 
 typedef std::vector<std::string> string_vector;
 
@@ -152,8 +149,11 @@ int main(int argc, char** argv)
                 message.setContent(options.content);
                 message.setContentType("text/plain");
             }
-            AbsTime end(now(), options.timeout * qpid::sys::TIME_SEC);
-            for (int count = 0; (count < options.count || options.count == 0) && (options.timeout == 0 || end > now()); count++) {
+            std::time_t start = std::time(0);
+            for (int count = 0; 
+                (count < options.count || options.count == 0) && 
+                (options.timeout == 0 || std::difftime(std::time(0), start) < options.timeout); 
+                count++) {
                 if (!options.replyto.empty()) message.setReplyTo(Address(options.replyto));
                 std::string id = options.id.empty() ? Uuid(true).str() : options.id;
                 std::stringstream spoutid;
-- 
1.7.1.1

From 4dfbb074af5cd176b94ab532fa901c0b716070c1 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Fri, 4 Jun 2010 17:54:33 -0400
Subject: [PATCH 028/129] BZ 582460, BZ577274

Windows SDK work:
* Added message_drain & message_spout programs back into the SDK examples
* Modified messaging example project files to use qpidmessaging library (instead of old qpidclient lib)
* Removed all x64 configurations from the example messaging projects
  as we don't include the x64 libs in the SDK
* Put import libs in lib directory to separate them from dlls
* Removed use of BOOST_ROOT env var from example projects as no boost headers are needed by the SDK

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951572 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/bld-winsdk.ps1                            |   19 +-
 qpid/cpp/examples/examples.sln                     |   32 +--
 .../cpp/examples/messaging/messaging_client.vcproj |  221 +++-----------------
 qpid/cpp/examples/messaging/messaging_drain.vcproj |  183 +---------------
 .../messaging/messaging_map_receiver.vcproj        |  221 +++-----------------
 .../examples/messaging/messaging_map_sender.vcproj |  221 +++-----------------
 .../cpp/examples/messaging/messaging_server.vcproj |  221 +++-----------------
 qpid/cpp/examples/messaging/messaging_spout.vcproj |  182 +---------------
 qpid/cpp/examples/old-examples.sln                 |   12 -
 9 files changed, 159 insertions(+), 1153 deletions(-)

diff --git a/qpid/cpp/bld-winsdk.ps1 b/qpid/cpp/bld-winsdk.ps1
index 3e13c18..8618160 100644
--- a/qpid/cpp/bld-winsdk.ps1
+++ b/qpid/cpp/bld-winsdk.ps1
@@ -59,11 +59,13 @@ devenv qpid-cpp.sln /build "Release|Win32" /project docs-user-api
 devenv qpid-cpp.sln /build "Debug|Win32" /project INSTALL
 devenv qpid-cpp.sln /build "Release|Win32" /project INSTALL
 
-# This is kludgy until we have more than one entry as the array declaration syntax
+# This would be kludgy if we have only one entry as the array declaration syntax
 # can't cope with just one nested array
-$move1=('bin/boost/*','bin')
-$move=@(0)
-$move[0]=$move1
+# Target must be a directory
+$move=(
+	('bin/*.lib','lib'),
+	('bin/boost/*.dll','bin')
+)
 
 $preserve=(
 	'include/qpid/agent',
@@ -77,16 +79,12 @@ $preserve=(
 $remove=(
 	'bin/qpidd.exe', 'bin/qpidbroker*.*',
 	'bin/qmfengine*.*', 'bin/qpidxarm*.*',
-	'bin/boost_regex*.*', 'bin/boost*.lib',
+	'bin/boost_regex*.*',
 	'bin/boost',
 	'conf',
 	'examples/direct',
 	'examples/failover',
 	'examples/fanout',
-	'examples/messaging/drain.cpp',
-	'examples/messaging/spout.cpp',
-	'examples/messaging/messaging_drain.vcproj',
-	'examples/messaging/messaging_spout.vcproj',
 	'examples/pub-sub',
 	'examples/qmf-console',
 	'examples/request-response',
@@ -100,8 +98,7 @@ $remove=(
 # Move some files around in the install tree
 foreach ($pattern in $move) {
 	$target = Join-Path $install_dir $pattern[1]
-	$tparent = Split-Path -parent $target
-	New-Item -force -type directory $tparent
+	New-Item -force -type directory $target
 	Move-Item -force -path "$install_dir/$($pattern[0])" -destination "$install_dir/$($pattern[1])"
 }
 # Copy aside the files to preserve
diff --git a/qpid/cpp/examples/examples.sln b/qpid/cpp/examples/examples.sln
index 14dcc34..4a26ac7 100644
--- a/qpid/cpp/examples/examples.sln
+++ b/qpid/cpp/examples/examples.sln
@@ -26,15 +26,11 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_map_receiver", "m
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_map_sender", "messaging\messaging_map_sender.vcproj", "{3B9EA507-FECA-1BAD-1FEE-AE349A6B75AA}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_queue_receiver", "messaging\messaging_queue_receiver.vcproj", "{64932FB7-FECA-1BAD-1FEE-AE349A6B75AA}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_queue_sender", "messaging\messaging_queue_sender.vcproj", "{2668EEDD-FECA-1BAD-1FEE-AE349A6B75AA}"
-EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_server", "messaging\messaging_server.vcproj", "{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_topic_receiver", "messaging\messaging_topic_receiver.vcproj", "{64979B71-FECA-1BAD-1FEE-AE349A6B75AA}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_drain", "messaging\messaging_drain.vcproj", "{D79791E5-C593-4F23-B545-0CE72D181F2A}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_topic_sender", "messaging\messaging_topic_sender.vcproj", "{E068EA69-FECA-1BAD-1FEE-AE349A6B75AA}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_spout", "messaging\messaging_spout.vcproj", "{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -54,26 +50,18 @@ Global
 		{3B9EA507-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
 		{3B9EA507-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
 		{3B9EA507-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
-		{64932FB7-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.ActiveCfg = Debug|Win32
-		{64932FB7-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
-		{64932FB7-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
-		{64932FB7-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
-		{2668EEDD-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.ActiveCfg = Debug|Win32
-		{2668EEDD-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
-		{2668EEDD-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
-		{2668EEDD-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
 		{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.ActiveCfg = Debug|Win32
 		{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
 		{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
 		{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
-		{64979B71-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.ActiveCfg = Debug|Win32
-		{64979B71-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
-		{64979B71-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
-		{64979B71-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
-		{E068EA69-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.ActiveCfg = Debug|Win32
-		{E068EA69-FECA-1BAD-1FEE-AE349A6B75AA}.Debug|Win32.Build.0 = Debug|Win32
-		{E068EA69-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.ActiveCfg = Release|Win32
-		{E068EA69-FECA-1BAD-1FEE-AE349A6B75AA}.Release|Win32.Build.0 = Release|Win32
+		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Debug|Win32.Build.0 = Debug|Win32
+		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Release|Win32.ActiveCfg = Release|Win32
+		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Release|Win32.Build.0 = Release|Win32
+		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Debug|Win32.Build.0 = Debug|Win32
+		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Release|Win32.ActiveCfg = Release|Win32
+		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Release|Win32.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/qpid/cpp/examples/messaging/messaging_client.vcproj b/qpid/cpp/examples/messaging/messaging_client.vcproj
index e2f8c26..f6e5da0 100644
--- a/qpid/cpp/examples/messaging/messaging_client.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_client.vcproj
@@ -26,15 +26,12 @@
 	ProjectGUID="{80B58CBC-FECA-1BAD-1FEE-AE349A6B75AA}"
 	RootNamespace="messaging_client"
 	Keyword="Win32Proj"
-	SignManifests="true"
+	TargetFrameworkVersion="0"
 	>
 	<Platforms>
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -45,7 +42,6 @@
 			IntermediateDirectory="Debug\messaging_client\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -71,7 +67,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -95,11 +91,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\client.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -108,6 +104,9 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
 				Name="VCXDCMakeTool"
 			/>
 			<Tool
@@ -117,6 +116,9 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
@@ -126,7 +128,6 @@
 			IntermediateDirectory="Release\messaging_client\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -152,7 +153,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -173,11 +174,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\client.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -188,86 +189,7 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_client\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\client.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
+				Name="VCManifestTool"
 			/>
 			<Tool
 				Name="VCXDCMakeTool"
@@ -279,85 +201,7 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_client\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\client.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
+				Name="VCAppVerifierTool"
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
@@ -369,39 +213,34 @@
 	<Files>
 		<Filter
 			Name="Source Files"
-			Filter="cpp;cxx;cc;c;C">
+			Filter="cpp;cxx;cc;c;C"
+			>
 			<File
-				RelativePath="client.cpp">
+				RelativePath="client.cpp"
+				>
 			</File>
 		</Filter>
 		<Filter
 			Name="Documentation"
-			Filter="">
+			>
 			<File
-				RelativePath="CMakeLists.txt">
+				RelativePath="CMakeLists.txt"
+				>
 				<FileConfiguration
 					Name="Debug|Win32"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 				<FileConfiguration
 					Name="Release|Win32"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|x64"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 			</File>
 		</Filter>
diff --git a/qpid/cpp/examples/messaging/messaging_drain.vcproj b/qpid/cpp/examples/messaging/messaging_drain.vcproj
index ea7704c..78f89d6 100644
--- a/qpid/cpp/examples/messaging/messaging_drain.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_drain.vcproj
@@ -26,14 +26,12 @@
 	ProjectGUID="{D79791E5-C593-4F23-B545-0CE72D181F2A}"
 	RootNamespace="messaging_drain"
 	Keyword="Win32Proj"
+	TargetFrameworkVersion="0"
 	>
 	<Platforms>
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -63,7 +61,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -84,11 +82,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\drain.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -140,7 +138,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -158,11 +156,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\drain.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -191,169 +189,6 @@
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_drain\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\drain.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_drain\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\drain.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
 	</Configurations>
 	<References>
 	</References>
@@ -367,6 +202,10 @@
 				RelativePath="drain.cpp"
 				>
 			</File>
+			<File
+				RelativePath=".\OptionParser.cpp"
+				>
+			</File>
 		</Filter>
 	</Files>
 	<Globals>
diff --git a/qpid/cpp/examples/messaging/messaging_map_receiver.vcproj b/qpid/cpp/examples/messaging/messaging_map_receiver.vcproj
index ed806c0..a928198 100644
--- a/qpid/cpp/examples/messaging/messaging_map_receiver.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_map_receiver.vcproj
@@ -26,15 +26,12 @@
 	ProjectGUID="{92D8F5AA-FECA-1BAD-1FEE-AE349A6B75AA}"
 	RootNamespace="messaging_map_receiver"
 	Keyword="Win32Proj"
-	SignManifests="true"
+	TargetFrameworkVersion="0"
 	>
 	<Platforms>
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -45,7 +42,6 @@
 			IntermediateDirectory="Debug\messaging_map_receiver\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -71,7 +67,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -95,11 +91,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\map_receiver.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -108,6 +104,9 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
 				Name="VCXDCMakeTool"
 			/>
 			<Tool
@@ -117,6 +116,9 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
@@ -126,7 +128,6 @@
 			IntermediateDirectory="Release\messaging_map_receiver\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -152,7 +153,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -173,11 +174,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\map_receiver.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -188,86 +189,7 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_map_receiver\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\map_receiver.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
+				Name="VCManifestTool"
 			/>
 			<Tool
 				Name="VCXDCMakeTool"
@@ -279,85 +201,7 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_map_receiver\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\map_receiver.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
+				Name="VCAppVerifierTool"
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
@@ -369,39 +213,34 @@
 	<Files>
 		<Filter
 			Name="Source Files"
-			Filter="cpp;cxx;cc;c;C">
+			Filter="cpp;cxx;cc;c;C"
+			>
 			<File
-				RelativePath="map_receiver.cpp">
+				RelativePath="map_receiver.cpp"
+				>
 			</File>
 		</Filter>
 		<Filter
 			Name="Documentation"
-			Filter="">
+			>
 			<File
-				RelativePath="CMakeLists.txt">
+				RelativePath="CMakeLists.txt"
+				>
 				<FileConfiguration
 					Name="Debug|Win32"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 				<FileConfiguration
 					Name="Release|Win32"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|x64"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 			</File>
 		</Filter>
diff --git a/qpid/cpp/examples/messaging/messaging_map_sender.vcproj b/qpid/cpp/examples/messaging/messaging_map_sender.vcproj
index 55d1606..29b3114 100644
--- a/qpid/cpp/examples/messaging/messaging_map_sender.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_map_sender.vcproj
@@ -26,15 +26,12 @@
 	ProjectGUID="{3B9EA507-FECA-1BAD-1FEE-AE349A6B75AA}"
 	RootNamespace="messaging_map_sender"
 	Keyword="Win32Proj"
-	SignManifests="true"
+	TargetFrameworkVersion="0"
 	>
 	<Platforms>
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -45,7 +42,6 @@
 			IntermediateDirectory="Debug\messaging_map_sender\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -71,7 +67,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -95,11 +91,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\map_sender.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -108,6 +104,9 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
 				Name="VCXDCMakeTool"
 			/>
 			<Tool
@@ -117,6 +116,9 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
@@ -126,7 +128,6 @@
 			IntermediateDirectory="Release\messaging_map_sender\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -152,7 +153,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -173,11 +174,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\map_sender.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -188,86 +189,7 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_map_sender\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\map_sender.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
+				Name="VCManifestTool"
 			/>
 			<Tool
 				Name="VCXDCMakeTool"
@@ -279,85 +201,7 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_map_sender\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\map_sender.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
+				Name="VCAppVerifierTool"
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
@@ -369,39 +213,34 @@
 	<Files>
 		<Filter
 			Name="Source Files"
-			Filter="cpp;cxx;cc;c;C">
+			Filter="cpp;cxx;cc;c;C"
+			>
 			<File
-				RelativePath="map_sender.cpp">
+				RelativePath="map_sender.cpp"
+				>
 			</File>
 		</Filter>
 		<Filter
 			Name="Documentation"
-			Filter="">
+			>
 			<File
-				RelativePath="CMakeLists.txt">
+				RelativePath="CMakeLists.txt"
+				>
 				<FileConfiguration
 					Name="Debug|Win32"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 				<FileConfiguration
 					Name="Release|Win32"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|x64"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 			</File>
 		</Filter>
diff --git a/qpid/cpp/examples/messaging/messaging_server.vcproj b/qpid/cpp/examples/messaging/messaging_server.vcproj
index 5a4f614..38d43e7 100644
--- a/qpid/cpp/examples/messaging/messaging_server.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_server.vcproj
@@ -26,15 +26,12 @@
 	ProjectGUID="{E0A50687-FECA-1BAD-1FEE-AE349A6B75AA}"
 	RootNamespace="messaging_server"
 	Keyword="Win32Proj"
-	SignManifests="true"
+	TargetFrameworkVersion="0"
 	>
 	<Platforms>
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -45,7 +42,6 @@
 			IntermediateDirectory="Debug\messaging_server\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -71,7 +67,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -95,11 +91,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\server.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -108,6 +104,9 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
 				Name="VCXDCMakeTool"
 			/>
 			<Tool
@@ -117,6 +116,9 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
@@ -126,7 +128,6 @@
 			IntermediateDirectory="Release\messaging_server\I386"
 			ConfigurationType="1"
 			CharacterSet="0"
-
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -152,7 +153,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -173,11 +174,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\server.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -188,86 +189,7 @@
 				Name="VCALinkTool"
 			/>
 			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_server\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\server.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
+				Name="VCManifestTool"
 			/>
 			<Tool
 				Name="VCXDCMakeTool"
@@ -279,85 +201,7 @@
 				Name="VCFxCopTool"
 			/>
 			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_server\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\server.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
+				Name="VCAppVerifierTool"
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
@@ -369,39 +213,34 @@
 	<Files>
 		<Filter
 			Name="Source Files"
-			Filter="cpp;cxx;cc;c;C">
+			Filter="cpp;cxx;cc;c;C"
+			>
 			<File
-				RelativePath="server.cpp">
+				RelativePath="server.cpp"
+				>
 			</File>
 		</Filter>
 		<Filter
 			Name="Documentation"
-			Filter="">
+			>
 			<File
-				RelativePath="CMakeLists.txt">
+				RelativePath="CMakeLists.txt"
+				>
 				<FileConfiguration
 					Name="Debug|Win32"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 				<FileConfiguration
 					Name="Release|Win32"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|x64"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCustomBuildTool"/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					ExcludedFromBuild="TRUE">
+					ExcludedFromBuild="true"
+					>
 					<Tool
-						Name="VCCustomBuildTool"/>
+						Name="VCCustomBuildTool"
+					/>
 				</FileConfiguration>
 			</File>
 		</Filter>
diff --git a/qpid/cpp/examples/messaging/messaging_spout.vcproj b/qpid/cpp/examples/messaging/messaging_spout.vcproj
index b4b941f..e10b00f 100644
--- a/qpid/cpp/examples/messaging/messaging_spout.vcproj
+++ b/qpid/cpp/examples/messaging/messaging_spout.vcproj
@@ -32,9 +32,6 @@
 		<Platform
 			Name="Win32"
 		/>
-		<Platform
-			Name="x64"
-		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
@@ -64,7 +61,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
@@ -85,11 +82,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
+				AdditionalDependencies="qpidmessagingd.lib qpidcommond.lib"
 				OutputFile="$(OutDir)\spout.exe"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				TargetMachine="1"
@@ -141,7 +138,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
+				AdditionalIncludeDirectories="&quot;$(QPID_ROOT)\include&quot;;..\..\include"
 				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -159,11 +156,11 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
+				AdditionalDependencies="qpidmessaging.lib qpidcommon.lib"
 				OutputFile="$(OutDir)\drain.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
+				AdditionalLibraryDirectories="$(QPID_ROOT)\bin;..\..\lib"
 				GenerateDebugInformation="true"
 				SubSystem="1"
 				OptimizeReferences="2"
@@ -192,169 +189,6 @@
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="."
-			IntermediateDirectory="Debug\messaging_spout\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="_DEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommond.lib qpidclientd.lib"
-				OutputFile="$(OutDir)\spout.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release\messaging_spout\AMD64"
-			ConfigurationType="1"
-			CharacterSet="0"
-
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				AdditionalOptions=""
-				AdditionalIncludeDirectories=""
-				TypeLibraryName="$(InputName).tlb"
-				HeaderFileName="$(InputName).h"
-				InterfaceIdentifierFileName="$(InputName)_i.c"
-				ProxyFileName="$(InputName)_p.c"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-				PreprocessorDefinitions="NDEBUG;WIN32;_CONSOLE;_CRT_NONSTDC_NO_WARNINGS;_AMD64_;_WIN64;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;BOOST_ALL_DYN_LINK"
-				RuntimeLibrary="2"
-				RuntimeTypeInfo="true"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG;_CRT_NONSTDC_NO_WARNINGS;NOMINMAX;WIN32_LEAN_AND_MEAN;_SCL_SECURE_NO_WARNINGS;_WIN64"
-				Culture="1033"
-				AdditionalIncludeDirectories="$(BOOST_ROOT)\include\$(BOOST_VERSION),$(BOOST_ROOT)\.,$(QPID_ROOT)\include,..\..\include"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/machine:AMD64"
-				AdditionalDependencies="qpidcommon.lib qpidclient.lib"
-				OutputFile="$(OutDir)\spout.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories=".;$(BOOST_ROOT)\lib;$(QPID_ROOT)\bin;..\..\bin"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
 	</Configurations>
 	<References>
 	</References>
@@ -365,6 +199,10 @@
 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
 			>
 			<File
+				RelativePath=".\OptionParser.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\spout.cpp"
 				>
 			</File>
diff --git a/qpid/cpp/examples/old-examples.sln b/qpid/cpp/examples/old-examples.sln
index 7b84ba8..7f2fa3e 100644
--- a/qpid/cpp/examples/old-examples.sln
+++ b/qpid/cpp/examples/old-examples.sln
@@ -58,10 +58,6 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tradedemo_topic_listener",
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tradedemo_topic_publisher", "tradedemo\tradedemo_topic_publisher.vcproj", "{E614CC2C-FECA-1BAD-23CE-CD4095BD3C8B}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_drain", "messaging\messaging_drain.vcproj", "{D79791E5-C593-4F23-B545-0CE72D181F2A}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "messaging_spout", "messaging\messaging_spout.vcproj", "{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}"
-EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Win32 = Debug|Win32
@@ -144,14 +140,6 @@ Global
 		{E614CC2C-FECA-1BAD-23CE-CD4095BD3C8B}.Debug|Win32.Build.0 = Debug|Win32
 		{E614CC2C-FECA-1BAD-23CE-CD4095BD3C8B}.Release|Win32.ActiveCfg = Release|Win32
 		{E614CC2C-FECA-1BAD-23CE-CD4095BD3C8B}.Release|Win32.Build.0 = Release|Win32
-		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Debug|Win32.ActiveCfg = Debug|Win32
-		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Debug|Win32.Build.0 = Debug|Win32
-		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Release|Win32.ActiveCfg = Release|Win32
-		{D79791E5-C593-4F23-B545-0CE72D181F2A}.Release|Win32.Build.0 = Release|Win32
-		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Debug|Win32.ActiveCfg = Debug|Win32
-		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Debug|Win32.Build.0 = Debug|Win32
-		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Release|Win32.ActiveCfg = Release|Win32
-		{D3115AC9-91C4-4D79-BCAC-DE837C70F1EA}.Release|Win32.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
-- 
1.7.1.1

From 79804fa332a5c1b7a2ca7da5cbee843f91f7fa3b Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Mon, 7 Jun 2010 16:15:27 +0000
Subject: [PATCH 029/129] Bug 566691 - Fixed - Abort in qpid::management::ManagementAgent::periodicProcessing on shutting down qpidd

QPID-2649: Ensure timer is stopped before we start deleting broker members

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@952307 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 24a1aa7464f703084430b033c1c416391615cbab)
---
 qpid/cpp/src/qpid/broker/Broker.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Broker.cpp b/qpid/cpp/src/qpid/broker/Broker.cpp
index 09157c1..399ed58 100644
--- a/qpid/cpp/src/qpid/broker/Broker.cpp
+++ b/qpid/cpp/src/qpid/broker/Broker.cpp
@@ -359,6 +359,7 @@ Broker::~Broker() {
     finalize();                 // Finalize any plugins.
     if (config.auth)
         SaslAuthenticator::fini();
+    timer.stop();
     QPID_LOG(notice, "Shut down");
 }
 
-- 
1.7.1.1

From 395447da146aac21bc8ced9a1de3c75bc1008233 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Mon, 7 Jun 2010 19:46:55 +0000
Subject: [PATCH 030/129] Bug 598948 - Fixed - qpid c++ client occasionly fails to authenticate using GSSAPI

Don't set USER callback, AUTHNAME is sufficient

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@952390 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 20850221af97fba3fb4d055c623fc8eb53f70ea3)
---
 qpid/cpp/src/qpid/client/SaslFactory.cpp |    4 ----
 1 files changed, 0 insertions(+), 4 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/SaslFactory.cpp b/qpid/cpp/src/qpid/client/SaslFactory.cpp
index 5175c77..79acf3c 100644
--- a/qpid/cpp/src/qpid/client/SaslFactory.cpp
+++ b/qpid/cpp/src/qpid/client/SaslFactory.cpp
@@ -145,10 +145,6 @@ CyrusSasl::CyrusSasl(const ConnectionSettings& s) : conn(0), settings(s)
     callbacks[i++].context = 0;
 
     if (!settings.username.empty()) {
-        callbacks[i].id = SASL_CB_USER;
-        callbacks[i].proc = (CallbackProc*) &getUserFromSettings;
-        callbacks[i++].context = &settings;
-
         callbacks[i].id = SASL_CB_AUTHNAME;
         callbacks[i].proc = (CallbackProc*) &getUserFromSettings;
         callbacks[i++].context = &settings;
-- 
1.7.1.1

From c13cc742f961cb771f008cd19edf38cb43ee6aeb Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Tue, 8 Jun 2010 15:31:31 +0000
Subject: [PATCH 031/129] Bug 577362: Long failover_soak test hangs.

Cluster handle connection-negotiation phase in local broker.

The connection negotiation phase up to the "open" or "open-ok" frame
establishes whether/what encryption to use for the rest of the
connection.

With this patch a cluster broker completes the initial negotiation
with its local clients and only then begins multicasting to other
brokers. The local broker decrypts if necessary and multicasts in the
clear.

This replaces a problematic locking scheme that was formerly in place
which caused deadlocks.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@952692 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 4f6804221443259a89ff761f798d8c25b9cbffa7)
---
 qpid/cpp/src/qpid/broker/Connection.cpp        |    3 +-
 qpid/cpp/src/qpid/broker/Connection.h          |    8 +-
 qpid/cpp/src/qpid/broker/ConnectionHandler.cpp |   13 +-
 qpid/cpp/src/qpid/broker/ConnectionHandler.h   |   12 +--
 qpid/cpp/src/qpid/broker/SaslAuthenticator.h   |   10 --
 qpid/cpp/src/qpid/cluster/Connection.cpp       |  206 ++++++++++--------------
 qpid/cpp/src/qpid/cluster/Connection.h         |   20 +--
 qpid/cpp/src/qpid/cluster/Multicaster.cpp      |    1 -
 qpid/cpp/src/tests/cluster_test.cpp            |    8 +-
 qpid/cpp/xml/cluster.xml                       |   10 +-
 10 files changed, 112 insertions(+), 179 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Connection.cpp b/qpid/cpp/src/qpid/broker/Connection.cpp
index 51615e5..ac574fc 100644
--- a/qpid/cpp/src/qpid/broker/Connection.cpp
+++ b/qpid/cpp/src/qpid/broker/Connection.cpp
@@ -386,7 +386,6 @@ void Connection::restartTimeout()
         timeoutTimer->touch();
 }
 
-
-
+bool Connection::isOpen() { return adapter.isOpen(); }
 
 }}
diff --git a/qpid/cpp/src/qpid/broker/Connection.h b/qpid/cpp/src/qpid/broker/Connection.h
index 0639bcb..ad9f786 100644
--- a/qpid/cpp/src/qpid/broker/Connection.h
+++ b/qpid/cpp/src/qpid/broker/Connection.h
@@ -63,9 +63,6 @@ class LinkRegistry;
 class SecureConnection;
 struct ConnectionTimeoutTask;
 
-typedef boost::function<void ( std::string& )> userIdCallback;
-
-
 class Connection : public sys::ConnectionInputHandler,
                    public ConnectionState,
                    public RefCounted
@@ -146,9 +143,8 @@ class Connection : public sys::ConnectionInputHandler,
         return securitySettings;
     }
 
-    void setUserIdCallback ( UserIdCallback fn ) {
-        adapter.setUserIdCallback ( fn );
-    }
+    /** @return true if the initial connection negotiation is complete. */
+    bool isOpen();
 
   private:
     typedef boost::ptr_map<framing::ChannelId, SessionHandler> ChannelMap;
diff --git a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
index 225735d..c349bc7 100644
--- a/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
+++ b/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp
@@ -87,7 +87,8 @@ ConnectionHandler::ConnectionHandler(Connection& connection, bool isClient, bool
 
 ConnectionHandler::Handler::Handler(Connection& c, bool isClient, bool isShadow) :
     proxy(c.getOutput()),
-    connection(c), serverMode(!isClient), acl(0), secured(0), userIdCallback(0)
+    connection(c), serverMode(!isClient), acl(0), secured(0),
+    isOpen(false)
 {
     if (serverMode) {
 
@@ -195,14 +196,7 @@ void ConnectionHandler::Handler::open(const string& /*virtualHost*/,
         if (sl.get()) secured->activateSecurityLayer(sl);
     }
 
-    if ( userIdCallback ) {
-        string s;
-        // Not checking the return value of getUsername, if there is
-        // no username then we want to call the userIdCallback anyway
-        // with an empty string.
-        authenticator->getUsername(s);
-        userIdCallback(s);
-    }
+    isOpen = true;
     proxy.openOk(array);
 }
 
@@ -272,6 +266,7 @@ void ConnectionHandler::Handler::openOk(const framing::Array& knownHosts)
         Url url((*i)->get<std::string>());
         connection.getKnownHosts().push_back(url);
     }
+    isOpen = true;
 }
 
 void ConnectionHandler::Handler::redirect(const string& /*host*/, const framing::Array& /*knownHosts*/)
diff --git a/qpid/cpp/src/qpid/broker/ConnectionHandler.h b/qpid/cpp/src/qpid/broker/ConnectionHandler.h
index ecc8868..6d55cab 100644
--- a/qpid/cpp/src/qpid/broker/ConnectionHandler.h
+++ b/qpid/cpp/src/qpid/broker/ConnectionHandler.h
@@ -40,9 +40,6 @@ namespace broker {
 class Connection;
 class SecureConnection;
 
-typedef boost::function<void ( std::string& )> UserIdCallback;
-
-
 class ConnectionHandler : public framing::FrameHandler
 {
     struct Handler : public framing::AMQP_AllOperations::ConnectionHandler
@@ -53,6 +50,7 @@ class ConnectionHandler : public framing::FrameHandler
         std::auto_ptr<SaslAuthenticator> authenticator;
         AclModule* acl;
         SecureConnection* secured;
+        bool isOpen;
 
         Handler(Connection& connection, bool isClient, bool isShadow=false);
         ~Handler();
@@ -67,10 +65,6 @@ class ConnectionHandler : public framing::FrameHandler
         void close(uint16_t replyCode, const std::string& replyText);
         void closeOk();
 
-        UserIdCallback userIdCallback;
-        void setUserIdCallback ( UserIdCallback fn ) { userIdCallback = fn; };
-
-
         void start(const qpid::framing::FieldTable& serverProperties,
                    const framing::Array& mechanisms,
                    const framing::Array& locales);
@@ -95,9 +89,7 @@ class ConnectionHandler : public framing::FrameHandler
     void heartbeat();
     void handle(framing::AMQFrame& frame);
     void setSecureConnection(SecureConnection* secured);
-    void setUserIdCallback ( UserIdCallback fn ) {
-      handler->setUserIdCallback ( fn );
-    }
+    bool isOpen() { return handler->isOpen; }
 };
 
 
diff --git a/qpid/cpp/src/qpid/broker/SaslAuthenticator.h b/qpid/cpp/src/qpid/broker/SaslAuthenticator.h
index f4ad24b..f1f1039 100644
--- a/qpid/cpp/src/qpid/broker/SaslAuthenticator.h
+++ b/qpid/cpp/src/qpid/broker/SaslAuthenticator.h
@@ -36,12 +36,6 @@ namespace broker {
 
 class Connection;
 
-// Calls your fn with the user ID string, just 
-// after the security negotiation is complete.
-// Add your callback to the list with addUserIdCallback().
-typedef boost::function<void ( std::string& )> UserIdCallback;
-
-
 class SaslAuthenticator
 {
 public:
@@ -54,7 +48,6 @@ public:
     virtual void getError(std::string&) {}
     virtual std::auto_ptr<qpid::sys::SecurityLayer> getSecurityLayer(uint16_t maxFrameSize) = 0;
 
-    virtual void setUserIdCallback ( UserIdCallback ) { }
     static bool available(void);
 
     // Initialize the SASL mechanism; throw if it fails.
@@ -64,9 +57,6 @@ public:
     static std::auto_ptr<SaslAuthenticator> createAuthenticator(Connection& connection, bool isShadow);
 
     virtual void callUserIdCallbacks() { }
-
-private:
-    UserIdCallback userIdCallback;
 };
 
 }}
diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index 9a8cab2..08e31c1 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -39,7 +39,6 @@
 #include "qpid/framing/DeliveryProperties.h"
 #include "qpid/framing/ClusterConnectionDeliverCloseBody.h"
 #include "qpid/framing/ClusterConnectionAnnounceBody.h"
-#include "qpid/framing/ClusterConnectionSecureUserIdBody.h"
 #include "qpid/framing/ConnectionCloseBody.h"
 #include "qpid/framing/ConnectionCloseOkBody.h"
 #include "qpid/log/Statement.h"
@@ -48,15 +47,6 @@
 #include <boost/current_function.hpp>
 
 
-typedef boost::function<void ( std::string& )> UserIdCallback;
-
-// TODO aconway 2008-11-03:
-// 
-// Refactor code for receiving an update into a separate UpdateConnection
-// class.
-//
-
-
 namespace qpid {
 namespace cluster {
 
@@ -88,10 +78,8 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
       expectProtocolHeader(false),
       mcastFrameHandler(cluster.getMulticast(), self),
       updateIn(c.getUpdateReceiver()),
-      secureConnection(0),
-      mcastSentButNotReceived(false),
-      inConnectionNegotiation(true)
-{ }
+      secureConnection(0)
+{}
 
 // Local connection
 Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
@@ -107,9 +95,7 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
     expectProtocolHeader(isLink),
     mcastFrameHandler(cluster.getMulticast(), self),
     updateIn(c.getUpdateReceiver()),
-    secureConnection(0),
-    mcastSentButNotReceived(false),
-    inConnectionNegotiation(true)
+    secureConnection(0)
 {
     cluster.addLocalConnection(this);
     if (isLocalClient()) {
@@ -117,11 +103,7 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
         // and initialized when the announce is received.
         QPID_LOG(info, "new client connection " << *this);
         giveReadCredit(cluster.getSettings().readMax); // Flow control
-        cluster.getMulticast().mcastControl(
-            ClusterConnectionAnnounceBody(ProtocolVersion(), mgmtId,
-                                          connectionCtor.external.ssf,
-                                          connectionCtor.external.authid,
-                                          connectionCtor.external.nodict), getId());
+        init();
     }
     else {
         // Catch-up shadow connections initialized using nextShadow id.
@@ -135,7 +117,8 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
 }
 
 void Connection::setSecureConnection(broker::SecureConnection* sc) {
-  secureConnection = sc;
+    secureConnection = sc;
+    if (connection.get()) connection->setSecureConnection(sc);
 }
 
 void Connection::init() {
@@ -155,30 +138,33 @@ void Connection::init() {
     }
     if (!isCatchUp())
         connection->setErrorListener(this);
-    UserIdCallback fn = boost::bind ( &Connection::mcastUserId, this, _1 );
-    connection->setUserIdCallback ( fn );
 }
 
 // Called when we have consumed a read buffer to give credit to the
 // connection layer to continue reading.
 void Connection::giveReadCredit(int credit) {
-    {
-        sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
-        if (inConnectionNegotiation) {
-            mcastSentButNotReceived = false;
-            connectionNegotiationMonitor.notify();
-        }
-    }
     if (cluster.getSettings().readMax && credit) 
         output.giveReadCredit(credit);
 }
 
-void Connection::announce(const std::string& mgmtId, uint32_t ssf, const std::string& authid, bool nodict) {
+void Connection::announce(
+    const std::string& mgmtId, uint32_t ssf, const std::string& authid, bool nodict,
+    const std::string& username, const std::string& initialFrames)
+{
     QPID_ASSERT(mgmtId == connectionCtor.mgmtId);
     QPID_ASSERT(ssf == connectionCtor.external.ssf);
     QPID_ASSERT(authid == connectionCtor.external.authid);
     QPID_ASSERT(nodict == connectionCtor.external.nodict);
-    init();
+    // Local connections are already initialized.
+    if (isShadow()) {
+        init();
+        // Play initial frames into the connection.
+        Buffer buf(const_cast<char*>(initialFrames.data()), initialFrames.size());
+        AMQFrame frame;
+        while (frame.decode(buf))
+            connection->received(frame);
+         connection->setUserId(username);
+    }
 }
 
 Connection::~Connection() {
@@ -201,7 +187,6 @@ void Connection::received(framing::AMQFrame& f) {
     if (isLocal()) {            // Local catch-up connection.
         currentChannel = f.getChannel();
         if (!framing::invoke(*this, *f.getBody()).wasHandled())
-
             connection->received(f);
     }
     else {             // Shadow or updated catch-up connection.
@@ -235,7 +220,7 @@ struct GiveReadCreditOnExit {
     int credit;
     GiveReadCreditOnExit(Connection& connection_, int credit_) :
         connection(connection_), credit(credit_) {}
-    ~GiveReadCreditOnExit() { connection.giveReadCredit(credit); }
+    ~GiveReadCreditOnExit() { if (credit) connection.giveReadCredit(credit); }
 };
 
 void Connection::deliverDoOutput(uint32_t limit) {
@@ -307,57 +292,76 @@ void Connection::abort() {
 }
 
 // ConnectionCodec::decode receives read buffers from  directly-connected clients.
-size_t Connection::decode(const char* buffer, size_t size) {
-
-    if (catchUp) {  // Handle catch-up locally.
-        Buffer buf(const_cast<char*>(buffer), size);
+size_t Connection::decode(const char* data, size_t size) {
+    GiveReadCreditOnExit grc(*this, 1);   // Give a read credit by default.
+    const char* ptr = data;
+    const char* end = data + size;
+    if (catchUp) {              // Handle catch-up locally.
+        Buffer buf(const_cast<char*>(ptr), size);
+        ptr += size;
         while (localDecoder.decode(buf))
             received(localDecoder.getFrame());
-        return buf.getPosition();
     }
     else {                      // Multicast local connections.
-        assert(isLocal());
-        const char* remainingData = buffer;
-        size_t remainingSize = size;
-
-        if (expectProtocolHeader) {
-            //If this is an outgoing link, we will receive a protocol
-            //header which needs to be decoded first
-            framing::ProtocolInitiation pi;
-            Buffer buf(const_cast<char*>(buffer), size);
-            if (pi.decode(buf)) {
-                //TODO: check the version is correct
-                QPID_LOG(debug, "Outgoing clustered link connection received INIT(" << pi << ")");
-                expectProtocolHeader = false;
-                remainingData = buffer + pi.encodedSize();
-                remainingSize = size - pi.encodedSize();
-            } else {
-                QPID_LOG(debug, "Not enough data for protocol header on outgoing clustered link");
-                giveReadCredit(1); // We're not going to mcast so give read credit now.
-                return 0;
-            }
+        assert(isLocalClient());
+        assert(connection.get());
+        if (!checkProtocolHeader(ptr, size)) // Updates ptr
+            return 0; // Incomplete header
+
+        if (!connection->isOpen()) 
+            processInitialFrames(ptr, end-ptr); // Updates ptr
+        
+        if (connection->isOpen() && end - ptr > 0) {
+            // We're multi-casting, we will give read credit on delivery.
+            grc.credit = 0;
+            cluster.getMulticast().mcastBuffer(ptr, end - ptr, self);
+            ptr = end;
         }
-
-        // During connection negotiation wait for each multicast to be
-        // processed before sending the next, to ensure that the
-        // security layer is activated before we attempt to decode
-        // encrypted frames.
-        { 
-            sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
-            if ( inConnectionNegotiation ) {
-                assert(!mcastSentButNotReceived);
-                mcastSentButNotReceived = true;
-            }
-        }
-        cluster.getMulticast().mcastBuffer(remainingData, remainingSize, self);
-        {
-            sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
-            if (inConnectionNegotiation)
-                while (mcastSentButNotReceived)
-                    connectionNegotiationMonitor.wait();
-            assert(!mcastSentButNotReceived);
+    }
+    return ptr - data;
+}
+
+// Decode the protocol header if needed. Updates data and size
+// returns true if the header is complete or already read.
+bool Connection::checkProtocolHeader(const char*& data, size_t size) {
+    if (expectProtocolHeader) {
+        //If this is an outgoing link, we will receive a protocol
+        //header which needs to be decoded first
+        framing::ProtocolInitiation pi;
+        Buffer buf(const_cast<char*&>(data), size);
+        if (pi.decode(buf)) {
+            //TODO: check the version is correct
+            QPID_LOG(debug, "Outgoing clustered link connection received INIT(" << pi << ")");
+            expectProtocolHeader = false;
+            data += pi.encodedSize();
+        } else {
+            return false;
         }
-        return size;
+    }
+    return true;
+}
+
+void Connection::processInitialFrames(const char*& ptr, size_t size) {
+    // Process the initial negotiation locally and store it so
+    // it can be replayed on other brokers in announce()
+    Buffer buf(const_cast<char*>(ptr), size);
+    framing::AMQFrame frame;
+    while (!connection->isOpen() && frame.decode(buf))
+        received(frame);
+    initialFrames.append(ptr, buf.getPosition());
+    ptr += buf.getPosition();
+    if (connection->isOpen()) { // initial negotiation complete
+        cluster.getMulticast().mcastControl(
+            ClusterConnectionAnnounceBody(
+                ProtocolVersion(),
+                connectionCtor.mgmtId,
+                connectionCtor.external.ssf,
+                connectionCtor.external.authid,
+                connectionCtor.external.nodict,
+                connection->getUserId(),
+                initialFrames),
+            getId());
+        initialFrames.clear();
     }
 }
 
@@ -574,21 +578,14 @@ void Connection::queue(const std::string& encoded) {
 }
 
 void Connection::sessionError(uint16_t , const std::string& msg) {
-    // If we are negotiating the connection when it fails just close the connectoin.
-    // If it fails after that then we have to flag the error to the cluster.
-    if (inConnectionNegotiation)
-        cluster.getMulticast().mcastControl(ClusterConnectionDeliverCloseBody(), self);
-    else
+    // Ignore errors before isOpen(), we're not multicasting yet.
+    if (connection->isOpen())
         cluster.flagError(*this, ERROR_TYPE_SESSION, msg);
-    
 }
 
 void Connection::connectionError(const std::string& msg) {
-    // If we are negotiating the connection when it fails just close the connectoin.
-    // If it fails after that then we have to flag the error to the cluster.
-    if (inConnectionNegotiation)
-        cluster.getMulticast().mcastControl(ClusterConnectionDeliverCloseBody(), self);
-    else
+    // Ignore errors before isOpen(), we're not multicasting yet.
+    if (connection->isOpen())
         cluster.flagError(*this, ERROR_TYPE_CONNECTION, msg);
 }
 
@@ -630,30 +627,5 @@ void Connection::managementAgents(const std::string& data) {
     QPID_LOG(debug, cluster << " updated management agents");
 }
 
-
-void Connection::mcastUserId ( std::string & id ) {
-    // Only the directly connected broker will mcast the secure user id, and only
-    // for client connections (not update connections)
-    if (isLocalClient())
-        cluster.getMulticast().mcastControl(
-            ClusterConnectionSecureUserIdBody(ProtocolVersion(), string(id)), getId() );
-    {
-        // This call signals the end of the connection negotiation phase.
-        sys::Mutex::ScopedLock l(connectionNegotiationMonitor);
-        inConnectionNegotiation = false;
-        mcastSentButNotReceived = false;
-        connectionNegotiationMonitor.notify();
-    }
-}
-
-// All connections, shadow or not, get this call.
-void Connection::secureUserId(const std::string& id) {
-    // Only set the user ID on shadow connections, and only if id is not the empty string.
-    if ( isShadow() && !id.empty() )
-        connection->setUserId ( id );
-}
-
-
-
 }} // Namespace qpid::cluster
 
diff --git a/qpid/cpp/src/qpid/cluster/Connection.h b/qpid/cpp/src/qpid/cluster/Connection.h
index 4f69bf7..70c4d0e 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.h
+++ b/qpid/cpp/src/qpid/cluster/Connection.h
@@ -164,8 +164,9 @@ class Connection :
     void exchange(const std::string& encoded);
 
     void giveReadCredit(int credit);
-    void announce(const std::string& mgmtId, uint32_t ssf, const std::string& authid, bool nodict);
-    void secureUserId(const std::string&);
+    void announce(const std::string& mgmtId, uint32_t ssf, const std::string& authid,
+                  bool nodict, const std::string& username,
+                  const std::string& initFrames);
     void abort();
     void deliverClose();
 
@@ -175,16 +176,8 @@ class Connection :
     void managementSchema(const std::string& data);
     void managementAgents(const std::string& data);
     void managementSetupState(uint64_t objectNum, uint16_t bootSequence);
-
-    //uint32_t getSsf() const { return connectionCtor.external.ssf; }
-
     void setSecureConnection ( broker::SecureConnection * sc );
 
-    // This is a callback, registered with the broker connection.
-    // It gives me the user ID, if one is negotiated through Sasl.
-    void mcastUserId ( std::string & );
-
-
   private:
     struct NullFrameHandler : public framing::FrameHandler {
         void handle(framing::AMQFrame&) {}
@@ -228,6 +221,8 @@ class Connection :
     bool checkUnsupported(const framing::AMQBody& body);
     void deliverDoOutput(uint32_t limit);
 
+    bool checkProtocolHeader(const char*& data, size_t size);
+    void processInitialFrames(const char*& data, size_t size);
     boost::shared_ptr<broker::Queue> findQueue(const std::string& qname);
     broker::SessionState& sessionState();
     broker::SemanticState& semanticState();
@@ -247,13 +242,10 @@ class Connection :
     McastFrameHandler mcastFrameHandler;
     UpdateReceiver& updateIn;
     qpid::broker::SecureConnection* secureConnection;
+    std::string initialFrames;
 
     static qpid::sys::AtomicValue<uint64_t> catchUpId;
 
-    mutable sys::Monitor connectionNegotiationMonitor;
-    bool mcastSentButNotReceived;
-    bool inConnectionNegotiation;
-    
   friend std::ostream& operator<<(std::ostream&, const Connection&);
 };
 
diff --git a/qpid/cpp/src/qpid/cluster/Multicaster.cpp b/qpid/cpp/src/qpid/cluster/Multicaster.cpp
index d57ff76..8916de9 100644
--- a/qpid/cpp/src/qpid/cluster/Multicaster.cpp
+++ b/qpid/cpp/src/qpid/cluster/Multicaster.cpp
@@ -61,7 +61,6 @@ void Multicaster::mcast(const Event& e) {
     QPID_LOG(trace, "MCAST " << e);
     if (bypass) {               // direct, don't queue
         iovec iov = e.toIovec();
-        // FIXME aconway 2010-03-10: should do limited retry.
         while (!cpg.mcast(&iov, 1))
             ;
     }
diff --git a/qpid/cpp/src/tests/cluster_test.cpp b/qpid/cpp/src/tests/cluster_test.cpp
index d5f2c45..0565ecc 100644
--- a/qpid/cpp/src/tests/cluster_test.cpp
+++ b/qpid/cpp/src/tests/cluster_test.cpp
@@ -510,7 +510,7 @@ QPID_AUTO_TEST_CASE(testUpdateMessageBuilder) {
     Client c1(cluster[1], "c1");
     BOOST_CHECK(c1.subs.get(m, "q", TIMEOUT));
     BOOST_CHECK_EQUAL(m.getData(), "abcd");
-    BOOST_CHECK_EQUAL(2u, knownBrokerPorts(c1.connection).size());
+    BOOST_CHECK_EQUAL(2u, knownBrokerPorts(c1.connection, 2).size());
 }
 
 QPID_AUTO_TEST_CASE(testConnectionKnownHosts) {
@@ -518,13 +518,13 @@ QPID_AUTO_TEST_CASE(testConnectionKnownHosts) {
     prepareArgs(args, durableFlag);
     ClusterFixture cluster(1, args, -1);
     Client c0(cluster[0], "c0");
-    set<int> kb0 = knownBrokerPorts(c0.connection);
+    set<int> kb0 = knownBrokerPorts(c0.connection, 1);
     BOOST_CHECK_EQUAL(kb0.size(), 1u);
     BOOST_CHECK_EQUAL(kb0, makeSet(cluster));
 
     cluster.add();
     Client c1(cluster[1], "c1");
-    set<int> kb1 = knownBrokerPorts(c1.connection);
+    set<int> kb1 = knownBrokerPorts(c1.connection, 2);
     kb0 = knownBrokerPorts(c0.connection, 2);
     BOOST_CHECK_EQUAL(kb1.size(), 2u);
     BOOST_CHECK_EQUAL(kb1, makeSet(cluster));
@@ -532,7 +532,7 @@ QPID_AUTO_TEST_CASE(testConnectionKnownHosts) {
 
     cluster.add();
     Client c2(cluster[2], "c2");
-    set<int> kb2 = knownBrokerPorts(c2.connection);
+    set<int> kb2 = knownBrokerPorts(c2.connection, 3);
     kb1 = knownBrokerPorts(c1.connection, 3);
     kb0 = knownBrokerPorts(c0.connection, 3);
     BOOST_CHECK_EQUAL(kb2.size(), 3u);
diff --git a/qpid/cpp/xml/cluster.xml b/qpid/cpp/xml/cluster.xml
index 29157dc..30cd159 100644
--- a/qpid/cpp/xml/cluster.xml
+++ b/qpid/cpp/xml/cluster.xml
@@ -127,6 +127,10 @@
       <field name="authid" type="str16"/>
       <!-- exclude certain sasl mechs, used with ssl and sasl-external -->
       <field name="nodict" type="bit"/>
+      <!-- User name as negotiated by SASL -->
+      <field name="username" type="str32"/>
+      <!-- Frames forming the initial connection negotiation.  -->
+      <field name="initial-frames" type="str32"/>
     </control>
 
     <!-- Marks the cluster-wide point when a connection is considered closed. -->
@@ -263,11 +267,5 @@
     <control name="management-agents" code="0x37">
       <field name="data" type="vbin32"/>
     </control>
-
-    <!-- Announce the user ID on a secure connection -->
-    <control name="secureUserId" code="0x38">
-      <field name="secure-user-id" type="str16"/>
-    </control>
-
   </class>
 </amqp>
-- 
1.7.1.1

From d6ead34fe2802092c0dd6490df11a6cc763506c1 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 9 Jun 2010 10:21:59 +0000
Subject: [PATCH 032/129] Bug 508959 - Fixed - Attempt to propagate binding info over dynamic link can crash broker if session has already failed

Ensure that bindings for dynamic bridges are not propagated over failed sessions.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@952942 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 04e23a8984a81a869067ade50c445f17f8dafbea)
---
 qpid/cpp/src/qpid/broker/Bridge.cpp |   26 +++++++++++++++++---------
 qpid/cpp/src/qpid/broker/Bridge.h   |    2 ++
 2 files changed, 19 insertions(+), 9 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Bridge.cpp b/qpid/cpp/src/qpid/broker/Bridge.cpp
index 003d508..3e632f6 100644
--- a/qpid/cpp/src/qpid/broker/Bridge.cpp
+++ b/qpid/cpp/src/qpid/broker/Bridge.cpp
@@ -153,16 +153,12 @@ void Bridge::create(Connection& c)
     if (args.i_srcIsLocal) sessionHandler.getSession()->enableReceiverTracking();
 }
 
-void Bridge::cancel(Connection& c)
+void Bridge::cancel(Connection&)
 {
-    if (args.i_srcIsLocal) {    
-        //recreate peer to be sure that the session handler reference
-        //is valid (it could have been deleted due to a detach)
-        SessionHandler& sessionHandler = c.getChannel(id);
-        peer.reset(new framing::AMQP_ServerProxy(sessionHandler.out));
+    if (resetProxy()) {
+        peer->getMessage().cancel(args.i_dest);
+        peer->getSession().detach(name);
     }
-    peer->getMessage().cancel(args.i_dest);
-    peer->getSession().detach(name);
 }
 
 void Bridge::closed()
@@ -310,10 +306,22 @@ void Bridge::sendReorigin()
     conn->requestIOProcessing(boost::bind(&Bridge::ioThreadPropagateBinding, this,
                                           queueName, args.i_src, args.i_key, bindArgs));
 }
+bool Bridge::resetProxy() 
+{
+    SessionHandler& sessionHandler = conn->getChannel(id);
+    if (!sessionHandler.getSession()) peer.reset();
+    else peer.reset(new framing::AMQP_ServerProxy(sessionHandler.out));
+    return peer.get();
+}
 
 void Bridge::ioThreadPropagateBinding(const string& queue, const string& exchange, const string& key, FieldTable args)
 {
-    peer->getExchange().bind(queue, exchange, key, args);
+    if (resetProxy()) {
+        peer->getExchange().bind(queue, exchange, key, args);
+    } else {
+        QPID_LOG(error, "Cannot propagate binding for dynamic bridge as session has been detached, deleting dynamic bridge");
+        destroy();
+    }
 }
 
 bool Bridge::containsLocalTag(const string& tagList) const
diff --git a/qpid/cpp/src/qpid/broker/Bridge.h b/qpid/cpp/src/qpid/broker/Bridge.h
index 5f9a46a..f25d32e 100644
--- a/qpid/cpp/src/qpid/broker/Bridge.h
+++ b/qpid/cpp/src/qpid/broker/Bridge.h
@@ -101,6 +101,8 @@ private:
     mutable uint64_t  persistenceId;
     ConnectionState* connState;
     Connection* conn;
+
+    bool resetProxy();
 };
 
 
-- 
1.7.1.1

From 079143676f0881d15138059d328a5531ef6a307e Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 9 Jun 2010 14:40:26 +0000
Subject: [PATCH 033/129] Bug 591292 - Fixed - MRG-M Heartbeat causes core

Ensure heartbeat task is cancelled before ConnectionImpl it refers to is deleted

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953032 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit a43e46bbed2bc9449494ff1db039f11a1230405d)
---
 qpid/cpp/src/qpid/client/ConnectionImpl.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
index 8848554..397bd4e 100644
--- a/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/ConnectionImpl.cpp
@@ -198,6 +198,7 @@ ConnectionImpl::ConnectionImpl(framing::ProtocolVersion v, const ConnectionSetti
 const uint16_t ConnectionImpl::NEXT_CHANNEL = std::numeric_limits<uint16_t>::max();
 
 ConnectionImpl::~ConnectionImpl() {
+    if (heartbeatTask) heartbeatTask->cancel();
     theIO().sub();
 }
 
-- 
1.7.1.1

From 4ee966781844a3757eaa44ebf4690105c2f18850 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 9 Jun 2010 15:37:02 +0000
Subject: [PATCH 034/129] Bug 597149 - Fixed - qpid python high level API clients not runnable on RHEL4 incompatible with python 2.3.4 OptionParser

Minor adjustment to option definitions for Python 2.3

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953044 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 4f7efe697023e9b654e5ceef9648204a322ce779)
---
 qpid/python/examples/api/drain  |    8 ++++----
 qpid/python/examples/api/server |    4 ++--
 qpid/python/examples/api/spout  |    8 ++++----
 3 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/qpid/python/examples/api/drain b/qpid/python/examples/api/drain
index eaf86f9..5e30153 100755
--- a/qpid/python/examples/api/drain
+++ b/qpid/python/examples/api/drain
@@ -27,17 +27,17 @@ parser = optparse.OptionParser(usage="usage: %prog [options] ADDRESS ...",
                                description="Drain messages from the supplied address.")
 parser.add_option("-b", "--broker", default="localhost",
                   help="connect to specified BROKER (default %default)")
-parser.add_option("-c", "--count", type=int,
+parser.add_option("-c", "--count", type="int",
                   help="number of messages to drain")
 parser.add_option("-f", "--forever", action="store_true",
                   help="ignore timeout and wait forever")
 parser.add_option("-r", "--reconnect", action="store_true",
                   help="enable auto reconnect")
-parser.add_option("-i", "--reconnect-interval", type=float, default=3,
+parser.add_option("-i", "--reconnect-interval", type="float", default=3,
                   help="interval between reconnect attempts")
-parser.add_option("-l", "--reconnect-limit", type=int,
+parser.add_option("-l", "--reconnect-limit", type="int",
                   help="maximum number of reconnect attempts")
-parser.add_option("-t", "--timeout", type=float, default=0,
+parser.add_option("-t", "--timeout", type="float", default=0,
                   help="timeout in seconds to wait before exiting (default %default)")
 parser.add_option("-p", "--print", dest="format", default="%(M)s",
                   help="format string for printing messages (default %default)")
diff --git a/qpid/python/examples/api/server b/qpid/python/examples/api/server
index 0500e6f..3b9a356 100755
--- a/qpid/python/examples/api/server
+++ b/qpid/python/examples/api/server
@@ -30,9 +30,9 @@ parser.add_option("-b", "--broker", default="localhost",
                   help="connect to specified BROKER (default %default)")
 parser.add_option("-r", "--reconnect", action="store_true",
                   help="enable auto reconnect")
-parser.add_option("-i", "--reconnect-interval", type=float, default=3,
+parser.add_option("-i", "--reconnect-interval", type="float", default=3,
                   help="interval between reconnect attempts")
-parser.add_option("-l", "--reconnect-limit", type=int,
+parser.add_option("-l", "--reconnect-limit", type="int",
                   help="maximum number of reconnect attempts")
 parser.add_option("-v", dest="verbose", action="store_true",
                   help="enable logging")
diff --git a/qpid/python/examples/api/spout b/qpid/python/examples/api/spout
index dacebb5..c2dc4db 100755
--- a/qpid/python/examples/api/spout
+++ b/qpid/python/examples/api/spout
@@ -39,13 +39,13 @@ parser.add_option("-b", "--broker", default="localhost",
                   help="connect to specified BROKER (default %default)")
 parser.add_option("-r", "--reconnect", action="store_true",
                   help="enable auto reconnect")
-parser.add_option("-i", "--reconnect-interval", type=float, default=3,
+parser.add_option("-i", "--reconnect-interval", type="float", default=3,
                   help="interval between reconnect attempts")
-parser.add_option("-l", "--reconnect-limit", type=int,
+parser.add_option("-l", "--reconnect-limit", type="int",
                   help="maximum number of reconnect attempts")
-parser.add_option("-c", "--count", type=int, default=1,
+parser.add_option("-c", "--count", type="int", default=1,
                   help="stop after count messages have been sent, zero disables (default %default)")
-parser.add_option("-t", "--timeout", type=float, default=None,
+parser.add_option("-t", "--timeout", type="float", default=None,
                   help="exit after the specified time")
 parser.add_option("-I", "--id", help="use the supplied id instead of generating one")
 parser.add_option("-S", "--subject", help="specify a subject")
-- 
1.7.1.1

From d092a33ae3f83cf0cc6423a0990cd26b06de6087 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Wed, 9 Jun 2010 20:29:32 +0000
Subject: [PATCH 035/129] Bug 602347: Fix cluster-safe assertion in connection negotiation.

See https://bugzilla.redhat.com/show_bug.cgi?id=602347.
In a cluster, raise the management connect event when processing cluster.announce.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953147 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit bfd0ea5b4582f99fe423ec18d206e7f3d2a635dc)
---
 qpid/cpp/src/qpid/broker/Connection.cpp  |   12 +++++++++++-
 qpid/cpp/src/qpid/broker/Connection.h    |    1 +
 qpid/cpp/src/qpid/cluster/Connection.cpp |    2 ++
 qpid/cpp/src/qpid/sys/ClusterSafe.cpp    |    6 +++++-
 qpid/cpp/src/qpid/sys/ClusterSafe.h      |   17 ++++++++++++++++-
 qpid/cpp/src/tests/cluster_tests.py      |    6 ++++--
 6 files changed, 39 insertions(+), 5 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Connection.cpp b/qpid/cpp/src/qpid/broker/Connection.cpp
index ac574fc..619f1a1 100644
--- a/qpid/cpp/src/qpid/broker/Connection.cpp
+++ b/qpid/cpp/src/qpid/broker/Connection.cpp
@@ -24,6 +24,7 @@
 #include "qpid/broker/Bridge.h"
 #include "qpid/broker/Broker.h"
 #include "qpid/sys/SecuritySettings.h"
+#include "qpid/sys/ClusterSafe.h"
 
 #include "qpid/log/Statement.h"
 #include "qpid/ptr_map.h"
@@ -121,7 +122,9 @@ Connection::~Connection()
 {
     if (mgmtObject != 0) {
         mgmtObject->resourceDestroy();
-        if (!isLink)
+        // In a cluster, Connections destroyed during shutdown are in
+        // a cluster-unsafe context. Don't raise an event in that case.
+        if (!isLink && isClusterSafe())
             agent->raiseEvent(_qmf::EventClientDisconnect(mgmtId, ConnectionState::getUserId()));
     }
     if (isLink)
@@ -202,6 +205,13 @@ void Connection::notifyConnectionForced(const string& text)
 void Connection::setUserId(const string& userId)
 {
     ConnectionState::setUserId(userId);
+    // In a cluster, the cluster code will raise the connect event
+    // when the connection is replicated to the cluster.
+    if (!sys::isCluster())
+        raiseConnectEvent();
+}
+
+void Connection::raiseConnectEvent() {
     if (mgmtObject != 0) {
         mgmtObject->set_authIdentity(userId);
         agent->raiseEvent(_qmf::EventClientConnect(mgmtId, userId));
diff --git a/qpid/cpp/src/qpid/broker/Connection.h b/qpid/cpp/src/qpid/broker/Connection.h
index ad9f786..cf199fa 100644
--- a/qpid/cpp/src/qpid/broker/Connection.h
+++ b/qpid/cpp/src/qpid/broker/Connection.h
@@ -111,6 +111,7 @@ class Connection : public sys::ConnectionInputHandler,
     std::string getAuthCredentials();
     void notifyConnectionForced(const std::string& text);
     void setUserId(const string& uid);
+    void raiseConnectEvent();
     const std::string& getUserId() const { return ConnectionState::getUserId(); }
     const std::string& getMgmtId() const { return mgmtId; }
     management::ManagementAgent* getAgent() const { return agent; }
diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index 08e31c1..c402415 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -165,6 +165,8 @@ void Connection::announce(
             connection->received(frame);
          connection->setUserId(username);
     }
+    // Raise the connection management event now that the connection is replicated.
+    connection->raiseConnectEvent();
 }
 
 Connection::~Connection() {
diff --git a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
index 498a46d..e051591 100644
--- a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
+++ b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
@@ -32,8 +32,12 @@ bool inCluster = false;
 QPID_TSS bool inContext = false;
 }
 
+bool isClusterSafe() { return !inCluster || inContext; }
+
+bool isCluster() { return inCluster; }
+
 void assertClusterSafe()  {
-    if (inCluster && !inContext) {
+    if (!isClusterSafe()) {
         QPID_LOG(critical, "Modified cluster state outside of cluster context");
         ::abort();
     }
diff --git a/qpid/cpp/src/qpid/sys/ClusterSafe.h b/qpid/cpp/src/qpid/sys/ClusterSafe.h
index abb9ad0..f338230 100644
--- a/qpid/cpp/src/qpid/sys/ClusterSafe.h
+++ b/qpid/cpp/src/qpid/sys/ClusterSafe.h
@@ -42,6 +42,20 @@ namespace sys {
 QPID_COMMON_EXTERN void assertClusterSafe();
 
 /**
+ * In a non-clustered broker, returns true.
+ *
+ * In a clustered broker returns true if we are in a context where it
+ * is safe to modify cluster state.
+ *
+ * This function is in the common library rather than the cluster
+ * library because it is called by code in the broker library.
+ */
+QPID_COMMON_EXTERN bool isClusterSafe();
+
+/** Return true in a clustered broker */
+QPID_COMMON_EXTERN bool isCluster();
+
+/**
  * Base class for classes that encapsulate state which is replicated
  * to all members of a cluster. Acts as a marker for clustered state
  * and provides functions to assist detecting bugs in cluster
@@ -53,7 +67,8 @@ struct ClusterSafeScope {
 };
 
 /**
- * Enable cluster-safe assertions. By defaul they are no-ops.
+ * Enable cluster-safe assertions. By default they are no-ops.
+ * Called by cluster code.
  */
 void enableClusterSafe();
 
diff --git a/qpid/cpp/src/tests/cluster_tests.py b/qpid/cpp/src/tests/cluster_tests.py
index f36cde9..983a8bd 100755
--- a/qpid/cpp/src/tests/cluster_tests.py
+++ b/qpid/cpp/src/tests/cluster_tests.py
@@ -211,6 +211,7 @@ class LongTests(BrokerTest):
             """Start ordinary clients for a broker. Start one client per broker.
             Round-robin on a colllection of different clients."""
             cmds=[
+                ["qpid-tool", "localhost:%s"%(broker.port())],
                 ["qpid-perftest", "--count", 50000,
                  "--base-name", str(qpid.datatypes.uuid4()), "--port", broker.port()],
                 ["qpid-queue-stats", "-a", "localhost:%s" %(broker.port())],
@@ -222,14 +223,15 @@ class LongTests(BrokerTest):
             cmd = ["qpid-stat", "-b", "localhost:%s" %(broker.port())]
             mclients.append(ClientLoop(broker, cmd))
 
-        endtime = time.time() + self.duration()
+        duration = max(self.duration(), 5)
+        endtime = time.time() + duration
         alive = 0                       # First live cluster member
         for i in range(len(cluster)):
             start_clients(cluster[i], i)
         start_mclients(cluster[alive])
 
         while time.time() < endtime:
-            time.sleep(min(5,self.duration()/2))
+            time.sleep(min(5,duration/2))
             for b in cluster[alive:]: b.ready() # Check if a broker crashed.
             # Kill the first broker, expect the clients to fail. 
             for c in clients[alive] + mclients: c.expect_fail()
-- 
1.7.1.1

From 46909ad1f9b0a01027da5fae7f41ccffb3778780 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Thu, 10 Jun 2010 13:36:15 +0000
Subject: [PATCH 036/129] Bug 602672 - Fixed -Message::getSubject() returns an empty string even if the message has a subject

QPID-664: Correct the name of the subject string used for incoming messages.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953321 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 1e4b6eddcbb9e45190c708967fce2097d2a69fa1)
---
 .../src/qpid/client/amqp0_10/IncomingMessages.cpp  |    2 +-
 qpid/cpp/src/tests/MessagingSessionTests.cpp       |    2 ++
 2 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp b/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
index cbf05fc..30cb634 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
@@ -289,7 +289,7 @@ void IncomingMessages::MessageTransfer::retrieve(qpid::messaging::Message* messa
 namespace {
 //TODO: unify conversion to and from 0-10 message that is currently
 //split between IncomingMessages and OutgoingMessage
-const std::string SUBJECT("subject");
+const std::string SUBJECT("qpid.subject");
 }
 
 void populateHeaders(qpid::messaging::Message& message, 
diff --git a/qpid/cpp/src/tests/MessagingSessionTests.cpp b/qpid/cpp/src/tests/MessagingSessionTests.cpp
index 2c51b9e..375af73 100644
--- a/qpid/cpp/src/tests/MessagingSessionTests.cpp
+++ b/qpid/cpp/src/tests/MessagingSessionTests.cpp
@@ -55,11 +55,13 @@ QPID_AUTO_TEST_CASE(testSimpleSendReceive)
     QueueFixture fix;
     Sender sender = fix.session.createSender(fix.queue);
     Message out("test-message");
+    out.setSubject("test-subject");
     sender.send(out);
     Receiver receiver = fix.session.createReceiver(fix.queue);
     Message in = receiver.fetch(Duration::SECOND * 5);
     fix.session.acknowledge();
     BOOST_CHECK_EQUAL(in.getContent(), out.getContent());
+    BOOST_CHECK_EQUAL(in.getSubject(), out.getSubject());
 }
 
 QPID_AUTO_TEST_CASE(testSyncSendReceive)
-- 
1.7.1.1

From 6227acefa2c27ad6b66ae7616e0b738ba3f9a754 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Fri, 11 Jun 2010 08:42:37 +0000
Subject: [PATCH 037/129] Bug 591292 - Further fix for heartbeat related segfault

Ensure that AsynchConnector is disassociated from Poller when aborting connection attempt due to a heartbeat timeout

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953610 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit ade27a1e658534e7188f90d91e6991bafac69870)
---
 qpid/cpp/src/qpid/client/TCPConnector.cpp |   12 ++++++++----
 qpid/cpp/src/qpid/client/TCPConnector.h   |    1 +
 qpid/cpp/src/qpid/sys/AsynchIO.h          |    2 +-
 qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp  |    6 ++++++
 4 files changed, 16 insertions(+), 5 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/TCPConnector.cpp b/qpid/cpp/src/qpid/client/TCPConnector.cpp
index d0a12c8..e284d57 100644
--- a/qpid/cpp/src/qpid/client/TCPConnector.cpp
+++ b/qpid/cpp/src/qpid/client/TCPConnector.cpp
@@ -76,10 +76,11 @@ TCPConnector::TCPConnector(Poller::shared_ptr p,
       initiated(false),
       closed(true),
       shutdownHandler(0),
+      connector(0),
       aio(0),
       poller(p)
 {
-    QPID_LOG(debug, "TCPConnector created for " << version.toString());
+    QPID_LOG(debug, "TCPConnector created for " << version);
     settings.configureSocket(socket);
 }
 
@@ -90,17 +91,18 @@ TCPConnector::~TCPConnector() {
 void TCPConnector::connect(const std::string& host, int port) {
     Mutex::ScopedLock l(lock);
     assert(closed);
-    AsynchConnector* c = AsynchConnector::create(
+    connector = AsynchConnector::create(
         socket,
         host, port,
         boost::bind(&TCPConnector::connected, this, _1),
         boost::bind(&TCPConnector::connectFailed, this, _3));
     closed = false;
 
-    c->start(poller);
+    connector->start(poller);
 }
 
 void TCPConnector::connected(const Socket&) {
+    connector = 0;
     aio = AsynchIO::create(socket,
                        boost::bind(&TCPConnector::readbuff, this, _1, _2),
                        boost::bind(&TCPConnector::eof, this, _1),
@@ -128,6 +130,7 @@ void TCPConnector::initAmqp() {
 }
 
 void TCPConnector::connectFailed(const std::string& msg) {
+    connector = 0;
     QPID_LOG(warning, "Connect failed: " << msg);
     socket.close();
     if (!closed)
@@ -158,8 +161,9 @@ void TCPConnector::abort() {
         if (aio) {
             // Established connection
             aio->requestCallback(boost::bind(&TCPConnector::eof, this, _1));
-        } else {
+        } else if (connector) {
             // We're still connecting
+            connector->stop();
             connectFailed("Connection timedout");
         }
     }
diff --git a/qpid/cpp/src/qpid/client/TCPConnector.h b/qpid/cpp/src/qpid/client/TCPConnector.h
index bce5f59..c756469 100644
--- a/qpid/cpp/src/qpid/client/TCPConnector.h
+++ b/qpid/cpp/src/qpid/client/TCPConnector.h
@@ -71,6 +71,7 @@ class TCPConnector : public Connector, public sys::Codec
 
     sys::Socket socket;
 
+    sys::AsynchConnector* connector;
     sys::AsynchIO* aio;
     std::string identifier;
     boost::shared_ptr<sys::Poller> poller;
diff --git a/qpid/cpp/src/qpid/sys/AsynchIO.h b/qpid/cpp/src/qpid/sys/AsynchIO.h
index f184163..50da8fa 100644
--- a/qpid/cpp/src/qpid/sys/AsynchIO.h
+++ b/qpid/cpp/src/qpid/sys/AsynchIO.h
@@ -69,7 +69,7 @@ public:
                                    ConnectedCallback connCb,
                                    FailedCallback failCb);
     virtual void start(boost::shared_ptr<Poller> poller) = 0;
-
+    virtual void stop() {};
 protected:
     AsynchConnector() {}
     virtual ~AsynchConnector() {}
diff --git a/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp b/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
index cef9f1f..7d85b43 100644
--- a/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
+++ b/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp
@@ -157,6 +157,7 @@ public:
                     ConnectedCallback connCb,
                     FailedCallback failCb);
     void start(Poller::shared_ptr poller);
+    void stop();
 };
 
 AsynchConnector::AsynchConnector(const Socket& s,
@@ -183,6 +184,11 @@ void AsynchConnector::start(Poller::shared_ptr poller)
     startWatch(poller);
 }
 
+void AsynchConnector::stop()
+{
+    stopWatch();
+}
+
 void AsynchConnector::connComplete(DispatchHandle& h)
 {
     h.stopWatch();
-- 
1.7.1.1

From 2e2fa6ccfda4ba82811fae63fa994ed99468245b Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Fri, 11 Jun 2010 09:10:13 +0000
Subject: [PATCH 038/129] Bug 598550 - Alleviates some of the broker load for QMF V2 format requests.

QPID-664: Avoid allocation for void Variant

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953615 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 0ef592408a84c9f55c33b5796e186b07a29bd6c9)
---
 qpid/cpp/src/qpid/types/Variant.cpp |   55 ++++++++++++++++++----------------
 1 files changed, 29 insertions(+), 26 deletions(-)

diff --git a/qpid/cpp/src/qpid/types/Variant.cpp b/qpid/cpp/src/qpid/types/Variant.cpp
index f22483f..1457449 100644
--- a/qpid/cpp/src/qpid/types/Variant.cpp
+++ b/qpid/cpp/src/qpid/types/Variant.cpp
@@ -482,7 +482,7 @@ VariantImpl* VariantImpl::create(const Variant& v)
     }
 }
 
-Variant::Variant() : impl(new VariantImpl()) {}
+Variant::Variant() : impl(0) {}
 Variant::Variant(bool b) : impl(new VariantImpl(b)) {}
 Variant::Variant(uint8_t i) : impl(new VariantImpl(i)) {}
 Variant::Variant(uint16_t i) : impl(new VariantImpl(i)) {}
@@ -506,7 +506,7 @@ Variant::~Variant() { if (impl) delete impl; }
 void Variant::reset()
 {
     if (impl) delete impl;
-    impl = new VariantImpl();
+    impl = 0;
 }
 
 
@@ -622,29 +622,32 @@ Variant& Variant::operator=(const Variant& v)
     return *this;
 }
 
-VariantType Variant::getType() const { return impl->getType(); }
-bool Variant::isVoid() const { return impl->getType() == VAR_VOID; }
-bool Variant::asBool() const { return impl->asBool(); }
-uint8_t Variant::asUint8() const { return impl->asUint8(); }
-uint16_t Variant::asUint16() const { return impl->asUint16(); }
-uint32_t Variant::asUint32() const { return impl->asUint32(); }
-uint64_t Variant::asUint64() const { return impl->asUint64(); }
-int8_t Variant::asInt8() const { return impl->asInt8(); }
-int16_t Variant::asInt16() const { return impl->asInt16(); }
-int32_t Variant::asInt32() const { return impl->asInt32(); }
-int64_t Variant::asInt64() const { return impl->asInt64(); }
-float Variant::asFloat() const { return impl->asFloat(); }
-double Variant::asDouble() const { return impl->asDouble(); }
-std::string Variant::asString() const { return impl->asString(); }
-Uuid Variant::asUuid() const { return impl->asUuid(); }
-const Variant::Map& Variant::asMap() const { return impl->asMap(); }
-Variant::Map& Variant::asMap() { return impl->asMap(); }
-const Variant::List& Variant::asList() const { return impl->asList(); }
-Variant::List& Variant::asList() { return impl->asList(); }
-const std::string& Variant::getString() const { return impl->getString(); }
-std::string& Variant::getString() { return impl->getString(); }
-void Variant::setEncoding(const std::string& s) { impl->setEncoding(s); }
-const std::string& Variant::getEncoding() const { return impl->getEncoding(); }
+VariantType Variant::getType() const { return impl ? impl->getType() : VAR_VOID; }
+bool Variant::isVoid() const { return getType() == VAR_VOID; }
+bool Variant::asBool() const { return impl && impl->asBool(); }
+uint8_t Variant::asUint8() const { return impl ? impl->asUint8() : 0; }
+uint16_t Variant::asUint16() const { return impl ? impl->asUint16() : 0; }
+uint32_t Variant::asUint32() const { return impl ? impl->asUint32() : 0; }
+uint64_t Variant::asUint64() const { return impl ? impl->asUint64() : 0; }
+int8_t Variant::asInt8() const { return impl ? impl->asInt8() : 0; }
+int16_t Variant::asInt16() const { return impl ? impl->asInt16() : 0; }
+int32_t Variant::asInt32() const { return impl ? impl->asInt32(): 0; }
+int64_t Variant::asInt64() const { return impl ? impl->asInt64() : 0; }
+float Variant::asFloat() const { return impl ? impl->asFloat() : 0; }
+double Variant::asDouble() const { return impl ? impl->asDouble() : 0; }
+std::string Variant::asString() const { return impl ? impl->asString() : EMPTY; }
+Uuid Variant::asUuid() const { return impl ? impl->asUuid() : Uuid(); }
+const Variant::Map& Variant::asMap() const { if (!impl) throw InvalidConversion("Can't convert VOID to MAP"); return impl->asMap(); }
+Variant::Map& Variant::asMap() { if (!impl) throw InvalidConversion("Can't convert VOID to MAP"); return impl->asMap(); }
+const Variant::List& Variant::asList() const { if (!impl) throw InvalidConversion("Can't convert VOID to LIST"); return impl->asList(); }
+Variant::List& Variant::asList() { if (!impl) throw InvalidConversion("Can't convert VOID to LIST"); return impl->asList(); }
+const std::string& Variant::getString() const { if (!impl) throw InvalidConversion("Can't convert VOID to STRING"); return impl->getString(); }
+std::string& Variant::getString() { if (!impl) throw InvalidConversion("Can't convert VOID to STRING"); return impl->getString(); }
+void Variant::setEncoding(const std::string& s) { 
+    if (!impl) impl = new VariantImpl();
+    impl->setEncoding(s); 
+}
+const std::string& Variant::getEncoding() const { return impl ? impl->getEncoding() : EMPTY; }
 
 Variant::operator bool() const { return asBool(); }
 Variant::operator uint8_t() const { return asUint8(); }
@@ -708,7 +711,7 @@ bool operator==(const Variant& a, const Variant& b)
 
 bool Variant::isEqualTo(const Variant& other) const
 {
-    return impl->isEqualTo(*other.impl);
+    return impl && impl->isEqualTo(*other.impl);
 }
 
 }} // namespace qpid::types
-- 
1.7.1.1

From 299fb71454960dbf62f635d846e5a4be9abb4429 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Wed, 9 Jun 2010 18:17:19 +0000
Subject: [PATCH 039/129] Bug 601277 - qpidd broker crash

Cleaned up the storage of RemoteAgents in ManagementAgent.
This closes a window of opportunity for a double-free.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953107 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit ffaa25d6c05dd381f603edb0107e914d3130480b)
---
 qpid/cpp/src/qpid/management/ManagementAgent.cpp |   27 +++++++++-------------
 qpid/cpp/src/qpid/management/ManagementAgent.h   |    6 +----
 2 files changed, 12 insertions(+), 21 deletions(-)

diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.cpp b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
index 7f2dd69..b1c2780 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
@@ -1390,31 +1390,26 @@ uint32_t ManagementAgent::assignBankLH (uint32_t requestedBank)
 
 void ManagementAgent::deleteOrphanedAgentsLH()
 {
-    vector<ObjectId> deleteList;
+    list<ObjectId> deleteList;
 
-    for (RemoteAgentMap::iterator aIter = remoteAgents.begin(); aIter != remoteAgents.end(); aIter++) {
-        ObjectId connectionRef = aIter->first;
+    for (RemoteAgentMap::const_iterator aIter = remoteAgents.begin(); aIter != remoteAgents.end(); aIter++) {
         bool found = false;
 
         for (ManagementObjectMap::iterator iter = managementObjects.begin();
              iter != managementObjects.end();
              iter++) {
-            if (iter->first == connectionRef && !iter->second->isDeleted()) {
+            if (iter->first == aIter->first && !iter->second->isDeleted()) {
                 found = true;
                 break;
             }
         }
 
-        if (!found) {
-            deleteList.push_back(connectionRef);
-            delete aIter->second;
-        }
+        if (!found)
+            deleteList.push_back(aIter->first);
     }
 
-    for (vector<ObjectId>::iterator dIter = deleteList.begin(); dIter != deleteList.end(); dIter++)
+    for (list<ObjectId>::const_iterator dIter = deleteList.begin(); dIter != deleteList.end(); dIter++)
         remoteAgents.erase(*dIter);
-
-    deleteList.clear();
 }
 
 void ManagementAgent::handleAttachRequestLH (Buffer& inBuffer, const string& replyToKey, uint32_t sequence, const ConnectionToken* connToken)
@@ -1444,12 +1439,12 @@ void ManagementAgent::handleAttachRequestLH (Buffer& inBuffer, const string& rep
 
     assignedBank = assignBankLH(requestedAgentBank);
 
-    RemoteAgent* agent = new RemoteAgent(*this);
+    boost::shared_ptr<RemoteAgent> agent(new RemoteAgent(*this));
     agent->brokerBank = brokerBank;
     agent->agentBank  = assignedBank;
     agent->routingKey = replyToKey;
     agent->connectionRef = connectionRef;
-    agent->mgmtObject = new _qmf::Agent (this, agent);
+    agent->mgmtObject = new _qmf::Agent (this, agent.get());
     agent->mgmtObject->set_connectionRef(agent->connectionRef);
     agent->mgmtObject->set_label        (label);
     agent->mgmtObject->set_registeredTo (broker->GetManagementObject()->getObjectId());
@@ -2289,7 +2284,7 @@ void ManagementAgent::exportAgents(string& out) {
          ++i)
     {
         // TODO aconway 2010-03-04: see comment in ManagementAgent::RemoteAgent::encode
-        RemoteAgent* agent = i->second;
+        boost::shared_ptr<RemoteAgent> agent(i->second);
 
         map_.clear();
         amap.clear();
@@ -2310,7 +2305,7 @@ void ManagementAgent::importAgents(qpid::framing::Buffer& inBuf) {
     sys::Mutex::ScopedLock lock(userLock);
 
     for (l = content.begin(); l != content.end(); l++) {
-        auto_ptr<RemoteAgent> agent(new RemoteAgent(*this));
+        boost::shared_ptr<RemoteAgent> agent(new RemoteAgent(*this));
         Variant::Map map_;
         Variant::Map::const_iterator i;
 
@@ -2321,7 +2316,7 @@ void ManagementAgent::importAgents(qpid::framing::Buffer& inBuf) {
             agent->mapDecode(i->second.asMap());
 
             addObject (agent->mgmtObject, 0, false);
-            remoteAgents[agent->connectionRef] = agent.release();
+            remoteAgents[agent->connectionRef] = agent;
         }
     }
 }
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.h b/qpid/cpp/src/qpid/management/ManagementAgent.h
index d101ca1..44e3eb1 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.h
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.h
@@ -175,11 +175,7 @@ private:
         void mapDecode(const qpid::types::Variant::Map& _map);
     };
 
-    // TODO: Eventually replace string with entire reply-to structure.  reply-to
-    //       currently assumes that the exchange is "amq.direct" even though it could
-    //       in theory be specified differently.
-    typedef std::map<ObjectId, RemoteAgent*> RemoteAgentMap;
-    typedef std::vector<std::string>         ReplyToVector;
+    typedef std::map<ObjectId, boost::shared_ptr<RemoteAgent> > RemoteAgentMap;
 
     //  Storage for known schema classes:
     //
-- 
1.7.1.1

From 043f40b8dbf45d45f2342108dc977298a7afbe6a Mon Sep 17 00:00:00 2001
From: Kim van der Riet <kpvdr@apache.org>
Date: Fri, 11 Jun 2010 12:49:52 +0000
Subject: [PATCH 040/129] Bug 589683 - Broker misconfiguration causes broker stop to fail

QPID-2666: Fix for init script problem where config file has "log-to-file" set with a relative path.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953687 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 032866de5d7cccafac52faeaa333b9dae4811761)
---
 qpid/cpp/etc/qpidd |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/etc/qpidd b/qpid/cpp/etc/qpidd
index f391da3..07cbb82 100755
--- a/qpid/cpp/etc/qpidd
+++ b/qpid/cpp/etc/qpidd
@@ -72,7 +72,7 @@ start() {
 	    touch $pidfile
 	    chown qpidd.qpidd $pidfile
             [ -x /sbin/restorecon ] && /sbin/restorecon $pidfile
-	    runuser -s /bin/sh qpidd -c "/usr/sbin/$prog --check > $pidfile"
+	    runuser - -s /bin/sh qpidd -c "/usr/sbin/$prog --check > $pidfile"
 	fi
 	return $RETVAL
 }
-- 
1.7.1.1

From b3c11c4bf0a0417775763883c5576bcf2e797348 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Fri, 11 Jun 2010 21:46:57 +0000
Subject: [PATCH 041/129] Bug 601828 - QMF Agent returning STATUS_USER returns error 7 to QMF Console

Fixed a bug in which QMF error return codes were being sent back as 7 - Exception.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953885 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 2b9eb6bdbecc94d6dfdf2db148e422daf07ab2b1)
---
 qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp |   32 ++++++++--------------
 1 files changed, 12 insertions(+), 20 deletions(-)

diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
index 6a07d8c..e2a595c 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
@@ -499,8 +499,8 @@ void ManagementAgentImpl::invokeMethodRequest(const string& body, const string&
 
     if ((oid = inMap.find("_object_id")) == inMap.end() ||
         (mid = inMap.find("_method_name")) == inMap.end()) {
-        (outMap["_values"].asMap())["_status_code"] = Manageable::STATUS_PARAMETER_INVALID;
-        (outMap["_values"].asMap())["_status_text"] = Manageable::StatusText(Manageable::STATUS_PARAMETER_INVALID);
+        sendException(replyTo, cid, Manageable::StatusText(Manageable::STATUS_PARAMETER_INVALID),
+                      Manageable::STATUS_PARAMETER_INVALID);
         failed = true;
     } else {
         string methodName;
@@ -520,8 +520,8 @@ void ManagementAgentImpl::invokeMethodRequest(const string& body, const string&
 
             ManagementObjectMap::iterator iter = managementObjects.find(objId);
             if (iter == managementObjects.end() || iter->second->isDeleted()) {
-                (outMap["_values"].asMap())["_status_code"] = Manageable::STATUS_UNKNOWN_OBJECT;
-                (outMap["_values"].asMap())["_status_text"] = Manageable::StatusText(Manageable::STATUS_UNKNOWN_OBJECT);
+                sendException(replyTo, cid, Manageable::StatusText(Manageable::STATUS_UNKNOWN_OBJECT),
+                              Manageable::STATUS_UNKNOWN_OBJECT);
                 failed = true;
             } else {
                 iter->second->doMethod(methodName, inArgs, callMap);
@@ -534,33 +534,25 @@ void ManagementAgentImpl::invokeMethodRequest(const string& body, const string&
                     if (iter->first != "_status_code" && iter->first != "_status_text")
                         outMap["_arguments"].asMap()[iter->first] = iter->second;
             } else {
-                (outMap["_values"].asMap())["_status_code"] = callMap["_status_code"];
-                (outMap["_values"].asMap())["_status_text"] = callMap["_status_text"];
+                sendException(replyTo, cid, callMap["_status_text"], callMap["_status_code"]);
                 failed = true;
             }
 
         } catch(types::InvalidConversion& e) {
-            outMap.clear();
-            outMap["_values"] = Variant::Map();
-            (outMap["_values"].asMap())["_status_code"] = Manageable::STATUS_EXCEPTION;
-            (outMap["_values"].asMap())["_status_text"] = e.what();
+            sendException(replyTo, cid, e.what(), Manageable::STATUS_EXCEPTION);
             failed = true;
         }
     }
 
-    Variant::Map headers;
-    headers["method"] = "response";
-    headers["qmf.agent"] = name_address;
-    if (failed) {
-        headers["qmf.opcode"] = "_exception";
-        QPID_LOG(trace, "SENT Exception map=" << outMap);
-    } else {
+    if (!failed) {
+        Variant::Map headers;
+        headers["method"] = "response";
+        headers["qmf.agent"] = name_address;
         headers["qmf.opcode"] = "_method_response";
         QPID_LOG(trace, "SENT MethodResponse map=" << outMap);
+        MapCodec::encode(outMap, content);
+        connThreadBody.sendBuffer(content, cid, headers, "qmf.default.direct", replyTo);
     }
-
-    MapCodec::encode(outMap, content);
-    connThreadBody.sendBuffer(content, cid, headers, "qmf.default.direct", replyTo);
 }
 
 void ManagementAgentImpl::handleGetQuery(const string& body, const string& cid, const string& replyTo)
-- 
1.7.1.1

From fcf4a2aefda3d8d84b1abb0dea6d340a9fbdc546 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Thu, 3 Jun 2010 20:23:30 +0000
Subject: [PATCH 042/129] Bug 599700 - Console examples sometimes fail due to not waiting for the broker connection to complete

QPID-2644 - Console examples sometimes fail due to not waiting for the broker connection to complete
Moved 'Broker::waitForStable' from private to public, used this function in the examples to
hold off until the broker is fully connected.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951141 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 095fb80c67258ab00a2654bdd4a094f4d37ed4b8)
---
 qpid/cpp/examples/qmf-console/console.cpp |    1 +
 qpid/cpp/examples/qmf-console/ping.cpp    |    1 +
 qpid/cpp/include/qpid/console/Broker.h    |   14 +++++++-------
 3 files changed, 9 insertions(+), 7 deletions(-)

diff --git a/qpid/cpp/examples/qmf-console/console.cpp b/qpid/cpp/examples/qmf-console/console.cpp
index 5700d55..b5375b6 100644
--- a/qpid/cpp/examples/qmf-console/console.cpp
+++ b/qpid/cpp/examples/qmf-console/console.cpp
@@ -81,6 +81,7 @@ int main_int(int /*argc*/, char** /*argv*/)
     Broker* broker;
 
     broker = sm.addBroker(settings);
+    broker->waitForStable();
 
     cout << "Package List:" << endl;
     vector<string> packages;
diff --git a/qpid/cpp/examples/qmf-console/ping.cpp b/qpid/cpp/examples/qmf-console/ping.cpp
index 405c15f..fe537d4 100644
--- a/qpid/cpp/examples/qmf-console/ping.cpp
+++ b/qpid/cpp/examples/qmf-console/ping.cpp
@@ -55,6 +55,7 @@ int main_int(int /*argc*/, char** /*argv*/)
     // Add a broker connection to the session manager.
     //
     Broker* broker = sm.addBroker(connSettings);
+    broker->waitForStable();
 
     uint32_t count = 5;  // The number of echo requests we will send to the broker.
     Object::Vector list; // A container for holding objects retrieved from the broker.
diff --git a/qpid/cpp/include/qpid/console/Broker.h b/qpid/cpp/include/qpid/console/Broker.h
index af163b8..0b2d1bc 100644
--- a/qpid/cpp/include/qpid/console/Broker.h
+++ b/qpid/cpp/include/qpid/console/Broker.h
@@ -55,15 +55,16 @@ namespace console {
                                    client::ConnectionSettings& settings);
         QPID_CONSOLE_EXTERN ~Broker();
 
-        bool isConnected() const { return connected; }
-        const std::string& getError() const { return error; }
-        const std::string& getSessionId() const { return amqpSessionId; }
-        const framing::Uuid& getBrokerId() const { return brokerId; }
-        uint32_t getBrokerBank() const { return 1; }
-        void addBinding(const std::string& key) {
+        QPID_CONSOLE_EXTERN bool isConnected() const { return connected; }
+        QPID_CONSOLE_EXTERN const std::string& getError() const { return error; }
+        QPID_CONSOLE_EXTERN const std::string& getSessionId() const { return amqpSessionId; }
+        QPID_CONSOLE_EXTERN const framing::Uuid& getBrokerId() const { return brokerId; }
+        QPID_CONSOLE_EXTERN uint32_t getBrokerBank() const { return 1; }
+        QPID_CONSOLE_EXTERN void addBinding(const std::string& key) {
             connThreadBody.bindExchange("qpid.management", key);
         }
         QPID_CONSOLE_EXTERN std::string getUrl() const;
+        QPID_CONSOLE_EXTERN void waitForStable();
 
     private:
         friend class SessionManager;
@@ -117,7 +118,6 @@ namespace console {
         void received(client::Message& msg);
         void resetAgents();
         void updateAgent(const Object& object);
-        void waitForStable();
         void incOutstanding();
         void decOutstanding();
         void setBrokerId(const framing::Uuid& id) { brokerId = id; }
-- 
1.7.1.1

From 779be75603ed95682b9dcdbffa24182243d72547 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:05 +0000
Subject: [PATCH 043/129] BZ 591139: Removed unnecessary parameter from Rdma::AsynchIO::dataEvent()

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954489 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    4 ++--
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.h   |    2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 9244343..6f81450 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -42,7 +42,7 @@ namespace Rdma {
             ErrorCallback ec
     ) :
         qp(q),
-        dataHandle(*qp, boost::bind(&AsynchIO::dataEvent, this, _1), 0, 0),
+        dataHandle(*qp, boost::bind(&AsynchIO::dataEvent, this), 0, 0),
         bufferSize(size),
         recvCredit(0),
         xmitCredit(xCredit),
@@ -278,7 +278,7 @@ namespace Rdma {
         } while (true);
     }
 
-    void AsynchIO::dataEvent(qpid::sys::DispatchHandle&) {
+    void AsynchIO::dataEvent() {
         // Keep track of writable notifications
         // qpid::sys::ScopedLock<qpid::sys::Mutex> l(stateLock);
         State oldState;
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
index 0b86461..d896217 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
@@ -103,7 +103,7 @@ namespace Rdma {
         const static int FlagsMask = 0x10000000; // Mask for all flag bits - be sure to update this if you add more command bits
         const static int IgnoreData = 0x10000000; // Message contains no application data
 
-        void dataEvent(qpid::sys::DispatchHandle& handle);
+        void dataEvent();
         void processCompletions();
         void doWriteCallback();
         void doStoppedCallback();
-- 
1.7.1.1

From 39751102ca8d384c4607664ed86abfae55723289 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:08 +0000
Subject: [PATCH 044/129] BZ 591139: Trivial code simplification

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954490 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp |    4 +---
 1 files changed, 1 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
index a5f54e8..c95cda7 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
@@ -65,9 +65,7 @@ Duration fullTestDuration(TIME_INFINITE);
 vector<char> testString;
 
 void write(Rdma::AsynchIO& aio) {
-    while (aio.writable()) {
-        if (smsgs >= target)
-            return;
+    while (aio.writable() && aio.bufferAvailable() && smsgs < target) {
         Rdma::Buffer* b = aio.getBuffer();
         std::copy(testString.begin(), testString.end(), b->bytes);
         b->dataCount = msgsize;
-- 
1.7.1.1

From 97edcebbe4cba28829070f228b7da6f61bcafc3e Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:12 +0000
Subject: [PATCH 045/129] BZ 591139: Only set the draining flag when we delay calling the drained callback.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954491 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    3 +--
 1 files changed, 1 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 6f81450..32bd9cd 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -130,8 +130,6 @@ namespace Rdma {
 
     // Mark writing closed (so we don't accept any more writes or make any idle callbacks)
     void AsynchIO::drainWriteQueue(NotifyCallback nc) {
-        draining = true;
-
         State oldState;
         State newState;
         bool doReturn;
@@ -149,6 +147,7 @@ namespace Rdma {
             }
         } while (!state.boolCompareAndSwap(oldState, newState));
         if (doReturn) {
+            draining = true;
             notifyCallback = nc;
             return;
         }
-- 
1.7.1.1

From d4894bf43c8d1abc4bad633b2439502b458bb1d8 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:16 +0000
Subject: [PATCH 046/129] BZ 591139:
 In Rdma::AsynchIO::stop():
 - make sure we stop the underlying handle immediately whether or not
   we do the stopped callback now or have to defer it.

In qpid::client::RdmaConnector:
- make sure that the shutdown handler is called under all circumstances.
- make sure that the destructor doesn't delete the aio if it is
  already deleted

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954492 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/client/RdmaConnector.cpp |   19 +++++++++++++++----
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp      |    6 ++++--
 2 files changed, 19 insertions(+), 6 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/RdmaConnector.cpp b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
index 9be9e71..624f457 100644
--- a/qpid/cpp/src/qpid/client/RdmaConnector.cpp
+++ b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
@@ -162,7 +162,12 @@ namespace {
 RdmaConnector::~RdmaConnector() {
     QPID_LOG(debug, "~RdmaConnector " << identifier);
     close();
-    if (aio) aio->stop(deleteAsynchIO);
+    if (aio) {
+        aio->stop(deleteAsynchIO);
+    }
+    if (shutdownHandler) {
+        shutdownHandler->shutdown();
+    }
 }
 
 void RdmaConnector::connect(const std::string& host, int port){
@@ -244,15 +249,21 @@ void RdmaConnector::dataError(Rdma::AsynchIO&) {
     drained();
 }
 
-void RdmaConnector::stopped(Rdma::AsynchIO* aio) {
-    delete aio;
+void RdmaConnector::stopped(Rdma::AsynchIO* a) {
+    QPID_LOG(debug, "RdmaConnector::stopped " << identifier);
+    assert(!polling);
+    aio = 0;
+    delete a;
     if (shutdownHandler) {
-        shutdownHandler->shutdown();
+        ShutdownHandler* s = shutdownHandler;
+        shutdownHandler = 0;
+        s->shutdown();
     }
 }
 
 void RdmaConnector::drained() {
     QPID_LOG(debug, "RdmaConnector::drained " << identifier);
+    assert(!polling);
     if (aio) {
         aio->stop(boost::bind(&RdmaConnector::stopped, this, aio));
         aio = 0;
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 32bd9cd..e91127e 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -117,11 +117,14 @@ namespace Rdma {
             newState = SHUTDOWN;
 
         } while (!state.boolCompareAndSwap(oldState, newState));
+        
+        // Ensure we can't get any more callbacks (except for the stopped callback)
+        dataHandle.stopWatch();
+
         if (doReturn) {
             notifyCallback = nc;
             return;
         }
-        dataHandle.stopWatch();
         // Callback, but don't store it - SHUTDOWN state means callback has been called
         // we *are* allowed to delete the AsynchIO in this callback, so we have to return immediately
         // after the callback
@@ -473,7 +476,6 @@ namespace Rdma {
     }
 
     void AsynchIO::doStoppedCallback() {
-        dataHandle.stopWatch();
         NotifyCallback nc;
         nc.swap(notifyCallback);
         // Transition unconditionally to SHUTDOWN
-- 
1.7.1.1

From 7909518935fc6e164f6affa9447eb4a3cf5b8485 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:20 +0000
Subject: [PATCH 047/129] BZ 591139: Allow stopping even if we've got outstanding write buffers.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954493 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index e91127e..bd0005d 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -109,7 +109,7 @@ namespace Rdma {
         do {
             newState = oldState = state.get();
             doReturn = false;
-            if (outstandingWrites > 0 || (oldState != IDLE && oldState != DRAINED)) {
+            if (oldState != IDLE && oldState != DRAINED) {
                 doReturn = true;
                 break;
             }
-- 
1.7.1.1

From b0aacc99250bdd8c0202b667332fb17f741bca12 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:23 +0000
Subject: [PATCH 048/129] BZ 591139: Added asserts to ensure that we catch it if xmitCredit isn't sane

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954494 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index bd0005d..45295d4 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -171,6 +171,7 @@ namespace Rdma {
             }
             ++outstandingWrites;
             --xmitCredit;
+            assert(xmitCredit>=0);
         } else {
             if (fullCallback) {
                 fullCallback(*this, buff);
@@ -397,8 +398,10 @@ namespace Rdma {
                 // Get our xmitCredit if it was sent
                 bool dataPresent = true;
                 if (e.immPresent() ) {
+                    assert(xmitCredit>=0);
                     xmitCredit += (e.getImm() & ~FlagsMask);
                     dataPresent = ((e.getImm() & IgnoreData) == 0);
+                    assert(xmitCredit>0);
                 }
 
                 // if there was no data sent then the message was only to update our credit
@@ -430,6 +433,7 @@ namespace Rdma {
                         recvCredit -= creditSent;
                         ++outstandingWrites;
                         --xmitCredit;
+                        assert(xmitCredit>=0);
                     } else {
                         QPID_LOG(warning, "RDMA: qp=" << qp << ":  Unable to send unsolicited credit");
                     }
@@ -453,6 +457,9 @@ namespace Rdma {
     void AsynchIO::doWriteCallback() {
         // TODO: maybe don't call idle unless we're low on write buffers
         // Keep on calling the idle routine as long as we are writable and we got something to write last call
+
+        // Do callback even if there are no available free buffers as the application itself might be
+        // holding onto buffers
         while (writable()) {
             int xc = xmitCredit;
             idleCallback(*this);
-- 
1.7.1.1

From 7cf228a337572cb24179abfb109c8ce105725abc Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:27 +0000
Subject: [PATCH 049/129] BZ 591139: Try to avoid getting into a state where we can't send credit because we
 sent the very last buffer without any credit. So in theory when we do have
 credit to send we should have a buffer and xmit credit to do it with.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954495 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.h |   11 ++++++++++-
 1 files changed, 10 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
index d896217..655119b 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
@@ -110,8 +110,17 @@ namespace Rdma {
         void doDrainedCallback();
     };
 
+    // We're only writable if:
+    // * not draining write queue
+    // * we've got space in the transmit queue
+    // * we've got credit to transmit
+    // * if there's only 1 transmit credit we must send some credit
     inline bool AsynchIO::writable() const {
-        return (!draining && outstandingWrites < xmitBufferCount && xmitCredit > 0);
+        assert(xmitCredit>=0);
+        return !draining &&
+               outstandingWrites < xmitBufferCount &&
+               xmitCredit > 0 &&
+               ( xmitCredit > 1 || recvCredit > 0);
     }
 
     inline int AsynchIO::incompletedWrites() const {
-- 
1.7.1.1

From bd95291efa29074a75163208990fe6f0a8e828ed Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:33 +0000
Subject: [PATCH 050/129] BZ 591139: Combine Rdma::Buffer and ibv_sge needed to send it

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954496 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/client/RdmaConnector.cpp |   11 +++----
 qpid/cpp/src/qpid/sys/RdmaIOPlugin.cpp     |   12 ++++----
 qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp  |    8 ++--
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp      |   13 +-------
 qpid/cpp/src/qpid/sys/rdma/RdmaServer.cpp  |    4 +-
 qpid/cpp/src/qpid/sys/rdma/rdma_wrap.cpp   |   46 ++++++++++-----------------
 qpid/cpp/src/qpid/sys/rdma/rdma_wrap.h     |   29 ++++++++++++++---
 7 files changed, 60 insertions(+), 63 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/RdmaConnector.cpp b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
index 624f457..3b4e87d 100644
--- a/qpid/cpp/src/qpid/client/RdmaConnector.cpp
+++ b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
@@ -326,10 +326,9 @@ void RdmaConnector::writebuff(Rdma::AsynchIO&) {
     Codec* codec = securityLayer.get() ? (Codec*) securityLayer.get() : (Codec*) this;
     if (codec->canEncode()) {
         std::auto_ptr<BufferBase> buffer = std::auto_ptr<BufferBase>(aio->getBuffer());
-        size_t encoded = codec->encode(buffer->bytes, buffer->byteCount);
+        size_t encoded = codec->encode(buffer->bytes(), buffer->byteCount());
 
-        buffer->dataStart = 0;
-        buffer->dataCount = encoded;
+        buffer->dataCount(encoded);
         aio->queueWrite(buffer.release());
     }
 }
@@ -362,7 +361,7 @@ size_t RdmaConnector::encode(const char* buffer, size_t size)
 
 void RdmaConnector::readbuff(Rdma::AsynchIO&, Rdma::Buffer* buff) {
     Codec* codec = securityLayer.get() ? (Codec*) securityLayer.get() : (Codec*) this;
-    codec->decode(buff->bytes+buff->dataStart, buff->dataCount);
+    codec->decode(buff->bytes(), buff->dataCount());
 }
 
 size_t RdmaConnector::decode(const char* buffer, size_t size) 
@@ -386,9 +385,9 @@ size_t RdmaConnector::decode(const char* buffer, size_t size)
 
 void RdmaConnector::writeDataBlock(const AMQDataBlock& data) {
     Rdma::Buffer* buff = aio->getBuffer();
-    framing::Buffer out(buff->bytes, buff->byteCount);
+    framing::Buffer out(buff->bytes(), buff->byteCount());
     data.encode(out);
-    buff->dataCount = data.encodedSize();
+    buff->dataCount(data.encodedSize());
     aio->queueWrite(buff);
 }
 
diff --git a/qpid/cpp/src/qpid/sys/RdmaIOPlugin.cpp b/qpid/cpp/src/qpid/sys/RdmaIOPlugin.cpp
index e3498fa..044e6b4 100644
--- a/qpid/cpp/src/qpid/sys/RdmaIOPlugin.cpp
+++ b/qpid/cpp/src/qpid/sys/RdmaIOPlugin.cpp
@@ -108,9 +108,9 @@ void RdmaIOHandler::write(const framing::ProtocolInitiation& data)
 {
     QPID_LOG(debug, "Rdma: SENT [" << identifier << "] INIT(" << data << ")");
     Rdma::Buffer* buff = aio->getBuffer();
-    framing::Buffer out(buff->bytes, buff->byteCount);
+    framing::Buffer out(buff->bytes(), buff->byteCount());
     data.encode(out);
-    buff->dataCount = data.encodedSize();
+    buff->dataCount(data.encodedSize());
     aio->queueWrite(buff);
 }
 
@@ -135,8 +135,8 @@ void RdmaIOHandler::idle(Rdma::AsynchIO&) {
     if (codec == 0) return;
     if (codec->canEncode()) {
         Rdma::Buffer* buff = aio->getBuffer();
-        size_t encoded=codec->encode(buff->bytes, buff->byteCount);
-        buff->dataCount = encoded;
+        size_t encoded=codec->encode(buff->bytes(), buff->byteCount());
+        buff->dataCount(encoded);
         aio->queueWrite(buff);
     }
     if (codec->isClosed())
@@ -178,7 +178,7 @@ void RdmaIOHandler::readbuff(Rdma::AsynchIO&, Rdma::Buffer* buff) {
     size_t decoded = 0;
     try {
         if (codec) {
-            decoded = codec->decode(buff->bytes+buff->dataStart, buff->dataCount);
+            decoded = codec->decode(buff->bytes(), buff->dataCount());
         }else{
             // Need to start protocol processing
             initProtocolIn(buff);
@@ -191,7 +191,7 @@ void RdmaIOHandler::readbuff(Rdma::AsynchIO&, Rdma::Buffer* buff) {
 }
 
 void RdmaIOHandler::initProtocolIn(Rdma::Buffer* buff) {
-    framing::Buffer in(buff->bytes+buff->dataStart, buff->dataCount);
+    framing::Buffer in(buff->bytes(), buff->dataCount());
     framing::ProtocolInitiation protocolInit;
     size_t decoded = 0;
     if (protocolInit.decode(in)) {
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
index c95cda7..d33c609 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaClient.cpp
@@ -67,8 +67,8 @@ vector<char> testString;
 void write(Rdma::AsynchIO& aio) {
     while (aio.writable() && aio.bufferAvailable() && smsgs < target) {
         Rdma::Buffer* b = aio.getBuffer();
-        std::copy(testString.begin(), testString.end(), b->bytes);
-        b->dataCount = msgsize;
+        std::copy(testString.begin(), testString.end(), b->bytes());
+        b->dataCount(msgsize);
         aio.queueWrite(b);
         ++smsgs;
         sbytes += msgsize;
@@ -81,7 +81,7 @@ void dataError(Rdma::AsynchIO&) {
 
 void data(Poller::shared_ptr p, Rdma::AsynchIO& aio, Rdma::Buffer* b) {
     ++rmsgs;
-    rbytes += b->dataCount;
+    rbytes += b->dataCount();
 
     // When all messages have been recvd stop
     if (rmsgs < target) {
@@ -99,7 +99,7 @@ void full(Rdma::AsynchIO& a, Rdma::Buffer* b) {
 
     // Don't need to keep buffer just adjust the counts
     --smsgs;
-    sbytes -= b->dataCount;
+    sbytes -= b->dataCount();
 
     // Give buffer back
     a.returnBuffer(b);
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 45295d4..3b49e97 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -65,7 +65,6 @@ namespace Rdma {
             // Allocate recv buffer
             Buffer* b = qp->createBuffer(bufferSize);
             buffers.push_front(b);
-            b->dataCount = b->byteCount;
             qp->postRecv(b);
         }
 
@@ -74,8 +73,6 @@ namespace Rdma {
             Buffer* b = qp->createBuffer(bufferSize);
             buffers.push_front(b);
             bufferQueue.push_front(b);
-            b->dataCount = 0;
-            b->dataStart = 0;
         }
     }
 
@@ -410,8 +407,6 @@ namespace Rdma {
                 }
 
                 // At this point the buffer has been consumed so put it back on the recv queue
-                b->dataStart = 0;
-                b->dataCount = 0;
                 qp->postRecv(b);
 
                 // Received another message
@@ -425,8 +420,8 @@ namespace Rdma {
                     if (writable()) {
                         Buffer* ob = getBuffer();
                         // Have to send something as adapters hate it when you try to transfer 0 bytes
-                        *reinterpret_cast< uint32_t* >(ob->bytes) = htonl(recvCredit);
-                        ob->dataCount = sizeof(uint32_t);
+                        *reinterpret_cast< uint32_t* >(ob->bytes()) = htonl(recvCredit);
+                        ob->dataCount(sizeof(uint32_t));
 
                         int creditSent = recvCredit & ~FlagsMask;
                         qp->postSend(creditSent | IgnoreData, ob);
@@ -498,16 +493,12 @@ namespace Rdma {
         assert(!bufferQueue.empty());
         Buffer* b = bufferQueue.front();
         bufferQueue.pop_front();
-        b->dataCount = 0;
-        b->dataStart = 0;
         return b;
     }
 
     void AsynchIO::returnBuffer(Buffer* b) {
         qpid::sys::ScopedLock<qpid::sys::Mutex> l(bufferQueueLock);
         bufferQueue.push_front(b);
-        b->dataCount = 0;
-        b->dataStart = 0;
     }
 
     ConnectionManager::ConnectionManager(
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaServer.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaServer.cpp
index d42784f..9771532 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaServer.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaServer.cpp
@@ -70,8 +70,8 @@ void idle(ConRec* cr, Rdma::AsynchIO& a) {
 void data(ConRec* cr, Rdma::AsynchIO& a, Rdma::Buffer* b) {
     // Echo data back
     Rdma::Buffer* buf = a.getBuffer();
-    std::copy(b->bytes+b->dataStart, b->bytes+b->dataStart+b->dataCount, buf->bytes);
-    buf->dataCount = b->dataCount;
+    std::copy(b->bytes(), b->bytes()+b->dataCount(), buf->bytes());
+    buf->dataCount(b->dataCount());
     if (cr->queuedWrites.empty()) {
         // If can't write then full will be called and push buffer on back of queue
         a.queueWrite(buf);
diff --git a/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.cpp b/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.cpp
index 8944be2..2581aae 100644
--- a/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.cpp
@@ -50,19 +50,20 @@ namespace Rdma {
         return count;
     }
 
-    Buffer::Buffer(::ibv_pd* pd, char* const b, const int32_t s) :
-        bytes(b),
-        byteCount(s),
-        dataStart(0),
-        dataCount(0),
+    Buffer::Buffer(::ibv_pd* pd, const int32_t s) :
+        bufferSize(s),
         mr(CHECK_NULL(::ibv_reg_mr(
-        pd, bytes, byteCount,
+        pd, new char[s], s,
         ::IBV_ACCESS_LOCAL_WRITE)))
-    {}
+    {
+        sge.addr = (uintptr_t) mr->addr;
+        sge.length = 0;
+        sge.lkey = mr->lkey;
+    }
 
     Buffer::~Buffer() {
         (void) ::ibv_dereg_mr(mr);
-        delete [] bytes;
+        delete [] bytes();
     }
 
     QueuePairEvent::QueuePairEvent() :
@@ -106,7 +107,7 @@ namespace Rdma {
 
     Buffer* QueuePairEvent::getBuffer() const {
         Buffer* b = reinterpret_cast<Buffer*>(wc.wr_id);
-        b->dataCount = wc.byte_len;
+        b->dataCount(wc.byte_len);
         return b;
     }
 
@@ -157,7 +158,7 @@ namespace Rdma {
 
     // Create a buffer to use for writing
     Buffer* QueuePair::createBuffer(int s) {
-        return new Buffer(pd.get(), new char[s], s);
+        return new Buffer(pd.get(), s);
     }
 
     // Make channel non-blocking by making
@@ -213,14 +214,11 @@ namespace Rdma {
 
     void QueuePair::postRecv(Buffer* buf) {
         ::ibv_recv_wr rwr = {};
-        ::ibv_sge sge;
-
-        sge.addr = (uintptr_t) buf->bytes+buf->dataStart;
-        sge.length = buf->dataCount;
-        sge.lkey = buf->mr->lkey;
 
         rwr.wr_id = reinterpret_cast<uint64_t>(buf);
-        rwr.sg_list = &sge;
+        // We are given the whole buffer
+        buf->dataCount(buf->byteCount());
+        rwr.sg_list = &buf->sge;
         rwr.num_sge = 1;
 
         ::ibv_recv_wr* badrwr = 0;
@@ -231,16 +229,11 @@ namespace Rdma {
 
     void QueuePair::postSend(Buffer* buf) {
         ::ibv_send_wr swr = {};
-        ::ibv_sge sge;
-
-        sge.addr = (uintptr_t) buf->bytes+buf->dataStart;
-        sge.length = buf->dataCount;
-        sge.lkey = buf->mr->lkey;
 
         swr.wr_id = reinterpret_cast<uint64_t>(buf);
         swr.opcode = IBV_WR_SEND;
         swr.send_flags = IBV_SEND_SIGNALED;
-        swr.sg_list = &sge;
+        swr.sg_list = &buf->sge;
         swr.num_sge = 1;
 
         ::ibv_send_wr* badswr = 0;
@@ -251,17 +244,12 @@ namespace Rdma {
 
     void QueuePair::postSend(uint32_t imm, Buffer* buf) {
         ::ibv_send_wr swr = {};
-        ::ibv_sge sge;
-
-        sge.addr = (uintptr_t) buf->bytes+buf->dataStart;
-        sge.length = buf->dataCount;
-        sge.lkey = buf->mr->lkey;
-        swr.send_flags = IBV_SEND_SIGNALED;        
 
         swr.wr_id = reinterpret_cast<uint64_t>(buf);
         swr.imm_data = htonl(imm);
         swr.opcode = IBV_WR_SEND_WITH_IMM;
-        swr.sg_list = &sge;
+        swr.send_flags = IBV_SEND_SIGNALED;
+        swr.sg_list = &buf->sge;
         swr.num_sge = 1;
 
         ::ibv_send_wr* badswr = 0;
diff --git a/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.h b/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.h
index 5803ae5..54066d1 100644
--- a/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.h
+++ b/qpid/cpp/src/qpid/sys/rdma/rdma_wrap.h
@@ -45,19 +45,38 @@ namespace Rdma {
 
     struct Buffer {
         friend class QueuePair;
+        friend class QueuePairEvent;
 
-        char* const bytes;
-        const int32_t byteCount;
-        int32_t dataStart;
-        int32_t dataCount;
+        char* bytes() const;
+        int32_t byteCount() const;
+        int32_t dataCount() const;
+        void dataCount(int32_t);
 
-        Buffer(::ibv_pd* pd, char* const b, const int32_t s);
+        Buffer(::ibv_pd* pd, const int32_t s);
         ~Buffer();
 
     private:
+        const int32_t bufferSize;
         ::ibv_mr* mr;
+        ::ibv_sge sge;
     };
 
+    inline char* Buffer::bytes() const {
+      return (char*) sge.addr;
+    }
+
+    inline int32_t Buffer::byteCount() const {
+        return bufferSize;
+    }
+
+    inline int32_t Buffer::dataCount() const {
+        return sge.length;
+    }
+
+    inline void Buffer::dataCount(int32_t s) {
+        sge.length = s;
+    }
+
     class Connection;
 
     enum QueueDirection {
-- 
1.7.1.1

From 6bd302f9945099ce7d0d1c021b2aee44c5d6a368 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:36 +0000
Subject: [PATCH 051/129] BZ 591139: Ensure that we can't shutdown in the middle of writing a buffer

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954497 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/client/RdmaConnector.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/RdmaConnector.cpp b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
index 3b4e87d..504c5bd 100644
--- a/qpid/cpp/src/qpid/client/RdmaConnector.cpp
+++ b/qpid/cpp/src/qpid/client/RdmaConnector.cpp
@@ -320,6 +320,7 @@ void RdmaConnector::send(AMQFrame& frame) {
 // This is NOT only called in response to previously calling notifyPendingWrite
 void RdmaConnector::writebuff(Rdma::AsynchIO&) {
     // It's possible to be disconnected and be writable
+    Mutex::ScopedLock l(pollingLock);
     if (!polling)
         return;
 
-- 
1.7.1.1

From 196b1674c86d5c0fbea21ddf8f19b0c18f590d85 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:40 +0000
Subject: [PATCH 052/129] BZ 591139: Move QueuePair member in Rdma::AsynchIO to ensure that it get destroyed before
 the buffers it uses, so that there is no hardware activity using them after
 they are deleted

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954498 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    4 ++--
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.h   |    6 ++++--
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 3b49e97..25301e9 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -41,8 +41,6 @@ namespace Rdma {
             FullCallback fc,
             ErrorCallback ec
     ) :
-        qp(q),
-        dataHandle(*qp, boost::bind(&AsynchIO::dataEvent, this), 0, 0),
         bufferSize(size),
         recvCredit(0),
         xmitCredit(xCredit),
@@ -51,6 +49,8 @@ namespace Rdma {
         outstandingWrites(0),
         draining(false),
         state(IDLE),
+        qp(q),
+        dataHandle(*qp, boost::bind(&AsynchIO::dataEvent, this), 0, 0),
         readCallback(rc),
         idleCallback(ic),
         fullCallback(fc),
diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
index 655119b..4cd0e08 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.h
@@ -47,8 +47,6 @@ namespace Rdma {
         typedef boost::function2<void, AsynchIO&, Buffer*> FullCallback;
         typedef boost::function1<void, AsynchIO&> NotifyCallback;
 
-        QueuePair::intrusive_ptr qp;
-        qpid::sys::DispatchHandleRef dataHandle;
         int bufferSize;
         int recvCredit;
         int xmitCredit;
@@ -62,6 +60,10 @@ namespace Rdma {
         std::deque<Buffer*> bufferQueue;
         qpid::sys::Mutex bufferQueueLock;
         boost::ptr_deque<Buffer> buffers;
+        // The QueuePair must be after the buffers so that the connection is destroyed before the buffers
+        // are deallocated so that the hardware doesn't write into memory that's been given back.
+        QueuePair::intrusive_ptr qp;
+        qpid::sys::DispatchHandleRef dataHandle;
 
         ReadCallback readCallback;
         IdleCallback idleCallback;
-- 
1.7.1.1

From ae9ad6a317c1e9ecf47a675f32ebbeda7970d248 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 14 Jun 2010 14:50:44 +0000
Subject: [PATCH 053/129] BZ 591139: Allow entry into notifyPendingWrite() if already stopped as it is too hard
 to eliminate a race that can cause this, and it is essentially harmless if
 ignored

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954499 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
index 25301e9..845e84e 100644
--- a/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
+++ b/qpid/cpp/src/qpid/sys/rdma/RdmaIO.cpp
@@ -210,8 +210,8 @@ namespace Rdma {
                 newState = NOTIFY_WRITE;
                 break;
             case SHUTDOWN:
-                // This is not allowed - we can't make any more writes as we shut the connection down.
-                assert(oldState!=SHUTDOWN);
+                // We can get here because it is too hard to eliminate all races of stop() and notifyPendingWrite()
+                // just do nothing.
                 doReturn = true;
             case DRAINED:
                 // This is not allowed - we can't make any more writes as we're draining the write queue.
-- 
1.7.1.1

From 0050474676ddfd57fc10e5b845dd085f5841aec4 Mon Sep 17 00:00:00 2001
From: Stephen D. Huston <shuston@apache.org>
Date: Wed, 19 May 2010 21:28:38 +0000
Subject: [PATCH 054/129] Correct class/struct reference; resolves compile warning on Windows.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@946407 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 0f5cd165647af0c5d0791bad309c249bc0996af1)
---
 qpid/cpp/include/qpid/Address.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/include/qpid/Address.h b/qpid/cpp/include/qpid/Address.h
index 71da7b2..57c9139 100755
--- a/qpid/cpp/include/qpid/Address.h
+++ b/qpid/cpp/include/qpid/Address.h
@@ -25,7 +25,7 @@
 #include <string>
 
 namespace qpid {
-namespace client { class ConnectionSettings; }
+namespace client { struct ConnectionSettings; }
 
 
 /**
-- 
1.7.1.1

From 512db9306e1ac6cf8f05f7a646d36f282f88293e Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 25 May 2010 15:13:08 +0000
Subject: [PATCH 055/129] QPID-2617: Fix the windows build for modified method signature

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@948072 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 14862cf97c47355ba21e96429c73848a4d2f6f64)
---
 .../src/qpid/broker/windows/SaslAuthenticator.cpp  |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp b/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
index 642be29..608a8f7 100644
--- a/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
+++ b/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
@@ -68,7 +68,7 @@ bool SaslAuthenticator::available(void)
 }
 
 // Initialize the SASL mechanism; throw if it fails.
-void SaslAuthenticator::init(const std::string& /*saslName*/)
+void SaslAuthenticator::init(const std::string& /*saslName*/, const std::string& /*saslConfig*/)
 {
     return;
 }
-- 
1.7.1.1

From 088dea32ededd4c4e205202c7733f3db08846a1c Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Fri, 28 May 2010 18:09:10 +0000
Subject: [PATCH 056/129] Bug 603805 - .NET bindings for the C++ Messaging API

QPID-2628 - Patch from Chuck Rolke

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@949245 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 9e522de1ececed29fa9c0a02caa535c4f235b486)
---
 qpid/cpp/bindings/qpid/dotnet/ReadMe.txt           |   33 +-
 .../csharp.direct.receiver.cs                      |   19 +-
 .../csharp.direct.receiver.csproj                  |   12 +-
 .../csharp.direct.sender/csharp.direct.sender.cs   |   15 +-
 .../csharp.direct.sender.csproj                    |   12 +-
 .../Properties/AssemblyInfo.cs                     |   54 ++
 .../csharp.map.callback.receiver.cs                |  280 +++++++++++
 .../csharp.map.callback.receiver.csproj            |   69 +++
 .../Properties/AssemblyInfo.cs                     |   54 ++
 .../csharp.map.callback.sender.cs                  |  146 ++++++
 .../csharp.map.callback.sender.csproj              |   66 +++
 .../csharp.map.receiver/csharp.map.receiver.csproj |   16 +-
 .../csharp.map.receiver/csharp.map.recevier.cs     |    4 +-
 .../csharp.map.sender/csharp.map.sender.csproj     |   12 +-
 .../qpid/dotnet/org.apache.qpid.messaging.sln      |   44 ++
 qpid/cpp/bindings/qpid/dotnet/src/Address.cpp      |  186 +++++++
 qpid/cpp/bindings/qpid/dotnet/src/Address.h        |   89 ++++
 qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp   |  194 +++++++-
 qpid/cpp/bindings/qpid/dotnet/src/Connection.h     |   21 +-
 qpid/cpp/bindings/qpid/dotnet/src/Duration.h       |   65 ++-
 qpid/cpp/bindings/qpid/dotnet/src/Message.cpp      |  515 +++++---------------
 qpid/cpp/bindings/qpid/dotnet/src/Message.h        |   82 ++--
 qpid/cpp/bindings/qpid/dotnet/src/QpidException.h  |   38 ++
 qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h    |    1 +
 qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h  |   75 +++
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp     |  145 +++++-
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.h       |   20 +-
 qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp       |   29 +-
 qpid/cpp/bindings/qpid/dotnet/src/Sender.h         |   33 +-
 qpid/cpp/bindings/qpid/dotnet/src/Session.cpp      |  305 ++++++++++--
 qpid/cpp/bindings/qpid/dotnet/src/Session.h        |   47 ++-
 .../bindings/qpid/dotnet/src/TypeTranslator.cpp    |  411 ++++++++++++++++
 qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h |   70 +++
 qpid/cpp/bindings/qpid/dotnet/src/app.rc           |    1 +
 .../qpid/dotnet/src/org.apache.qpid.messaging.rc   |  101 ++++
 .../dotnet/src/org.apache.qpid.messaging.vcproj    |   34 +-
 qpid/cpp/bindings/qpid/dotnet/src/qpid.snk         |  Bin 0 -> 596 bytes
 qpid/cpp/bindings/qpid/dotnet/src/resource.h       |   22 -
 qpid/cpp/bindings/qpid/dotnet/src/resource1.h      |   14 +
 .../src/sessionreceiver/Properties/AssemblyInfo.cs |   55 ++
 ...rg.apache.qpid.messaging.sessionreceiver.csproj |   65 +++
 .../dotnet/src/sessionreceiver/sessionreceiver.cs  |  133 +++++
 .../dotnet/test/messaging.test/messaging.test.cs   |   62 +++-
 .../test/messaging.test/messaging.test.csproj      |   18 +-
 44 files changed, 2997 insertions(+), 670 deletions(-)
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/Address.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/qpid.snk
 delete mode 100644 qpid/cpp/bindings/qpid/dotnet/src/resource.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/resource1.h
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs

diff --git a/qpid/cpp/bindings/qpid/dotnet/ReadMe.txt b/qpid/cpp/bindings/qpid/dotnet/ReadMe.txt
index 66ac7ae..faa1b79 100644
--- a/qpid/cpp/bindings/qpid/dotnet/ReadMe.txt
+++ b/qpid/cpp/bindings/qpid/dotnet/ReadMe.txt
@@ -3,31 +3,46 @@ Qpid.cpp.bindings.qpid.dotnet binding package.
 1. Features
 ===========
 
-This binding package is a .NET Interop wrapper around the Qpid Messaging interface.
-It exposes the Messaging interface through a series of managed code classes that
-may be used by any .NET language.
+A. This binding package provides a .NET Interop wrapper around the C++ 
+   Qpid Messaging interface. It exposes the Messaging interface through 
+   a series of managed code classes that may be used by any .NET language.
+
+B. A sessionreceiver assembly provides session callback functionality
+   above the C++ layer.
 
 2. Prerequisites
 ================
 
-1. A build of the Qpid C++ libraries is available. 
+A. A build of the Qpid C++ libraries is available. 
 
-2. Refer to this library using environment variable QPID_BUILD_ROOT.
+B. Refer to this library using environment variable QPID_BUILD_ROOT.
 
    for example: SET QPID_BUILD_ROOT=D:\users\submitter\svn\qpid\cpp
 
 3. Building the solution
 ========================
 
-1. Build the solution.
+A. The solution is cpp\bindings\qpid\dotnet\org.apache.qpid.messaging.sln
+
+B. Build the solution (Debug only - Release is not set up yet).
 
-4. Runing the examples
+C. Project output goes to %QPID_BUILD_ROOT%\src\Debug. This puts all the
+   solution artifacts is the same directory as the C++ DLLs.
+   
+
+4. Running the examples
 ======================
 
-CWIP
+A. csharp.direct.receiver
+B. csharp.direct.sender
+C. csharp.map.receiver
+D. csharp.map.sender
+E. csharp.map.callback.receiver
+F. csharp.map.callback.sender
+
 
 5. Running the tests
 ====================
 
-CWIP
+A. messaging.test
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
index 6cc2a5e..4888023 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
@@ -37,7 +37,20 @@ namespace CSharpDirect
         {
             String host = "localhost:5672";
             String addr = "amq.direct/key";
-            int    nMsg = 10;
+            Int32 nMsg = 10;
+
+            if (args.Length > 0)
+                host = args[0];
+            if (args.Length > 1)
+                addr = args[1];
+            if (args.Length > 2)
+                nMsg = Convert.ToInt32(args[2]);
+
+            Console.WriteLine("csharp.direct.receiver");
+            Console.WriteLine("host : {0}", host);
+            Console.WriteLine("addr : {0}", addr);
+            Console.WriteLine("nMsg : {0}", nMsg);
+            Console.WriteLine();
 
             Connection conn = new Connection(host);
 
@@ -52,7 +65,7 @@ namespace CSharpDirect
 
                 Session sess = conn.createSession();
 
-                Duration dur = new Duration(1000 * 3600 * 24); // Wait one day
+                Duration dura = new Duration(3600000); // wait forever
 
                 Receiver rcv = sess.createReceiver(addr);
 
@@ -62,7 +75,7 @@ namespace CSharpDirect
                 {
                     try
                     {
-                        Message msg2 = rcv.fetch(dur);
+                        Message msg2 = rcv.fetch(dura);
                         Console.WriteLine("Rcvd msg {0} : {1}", i, msg2.getContent());
                     }
                     catch (Exception e)
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
index 8cb4826..7bfcfb8 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
@@ -17,7 +17,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
@@ -31,10 +31,6 @@
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <ItemGroup>
-    <Reference Include="org.apache.qpid.messagingd, Version=1.0.3779.23054, Culture=neutral, PublicKeyToken=679e1f50b62dbace, processorArchitecture=x86">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\bin\Debug\org.apache.qpid.messagingd.dll</HintPath>
-    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
@@ -52,6 +48,12 @@
     <Compile Include="csharp.direct.receiver.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
index bf49787..1fe56aa 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
@@ -33,7 +33,20 @@ namespace csharp.direct.sender
         {
             String host = "localhost:5672";
             String addr = "amq.direct/key";
-            int nMsg = 10;
+            Int32 nMsg = 10;
+
+            if (args.Length > 0)
+                host = args[0];
+            if (args.Length > 1)
+                addr = args[1];
+            if (args.Length > 2)
+                nMsg = Convert.ToInt32(args[2]);
+
+            Console.WriteLine("csharp.direct.sender");
+            Console.WriteLine("host : {0}", host);
+            Console.WriteLine("addr : {0}", addr);
+            Console.WriteLine("nMsg : {0}", nMsg);
+            Console.WriteLine();
 
             Connection conn = new Connection(host);
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
index f109d64..7ff92e1 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
@@ -17,7 +17,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
@@ -31,10 +31,6 @@
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <ItemGroup>
-    <Reference Include="org.apache.qpid.messagingd, Version=1.0.3779.23054, Culture=neutral, PublicKeyToken=679e1f50b62dbace, processorArchitecture=x86">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\bin\Debug\org.apache.qpid.messagingd.dll</HintPath>
-    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
@@ -52,6 +48,12 @@
     <Compile Include="csharp.direct.sender.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..8e2add1
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/Properties/AssemblyInfo.cs
@@ -0,0 +1,54 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.map.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.map.receiver")]
+[assembly: AssemblyCopyright("Copyright   2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("002049f9-41c5-420f-9ff6-45bb652dded6")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
new file mode 100644
index 0000000..e7294c6
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
@@ -0,0 +1,280 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Collections.Generic;
+using org.apache.qpid.messaging;
+using org.apache.qpid.messaging.sessionreceiver;
+
+namespace org.apache.qpid.messaging.examples
+{
+    /// <summary>
+    /// A class with functions to display structured messages.
+    /// </summary>
+    public static class MessageViewer
+    {
+        /// <summary>
+        /// A Function to display a amqp/map message packaged as a Dictionary.
+        /// </summary>
+        /// <param name="dict">The AMQP map</param>
+        /// <param name="level">Nested depth</param>
+        public static void ShowDictionary(Dictionary<string, object> dict, int level)
+        {
+            foreach (KeyValuePair<string, object> kvp in dict)
+            {
+                Console.Write(new string(' ', level * 4));
+
+                if (QpidTypeCheck.ObjectIsMap(kvp.Value))
+                {
+                    Console.WriteLine("Key: {0}, Value: Dictionary", kvp.Key);
+                    ShowDictionary((Dictionary<string, object>)kvp.Value, level + 1);
+                }
+                else if (QpidTypeCheck.ObjectIsList(kvp.Value))
+                {
+                    Console.WriteLine("Key: {0}, Value: List", kvp.Key);
+                    ShowList((List<object>)kvp.Value, level + 1);
+                }
+                else
+                    Console.WriteLine("Key: {0}, Value: {1}, Type: {2}",
+                        kvp.Key, kvp.Value, kvp.Value.GetType().ToString());
+            }
+        }
+
+        /// <summary>
+        /// A function to display a ampq/list message packaged as a List.
+        /// </summary>
+        /// <param name="list">The AMQP list</param>
+        /// <param name="level">Nested depth</param>
+        public static void ShowList(List<object> list, int level)
+        {
+            foreach (object obj in list)
+            {
+                Console.Write(new string(' ', level * 4));
+
+                if (QpidTypeCheck.ObjectIsMap(obj))
+                {
+                    Console.WriteLine("Dictionary");
+                    ShowDictionary((Dictionary<string, object>)obj, level + 1);
+                }
+                else if (QpidTypeCheck.ObjectIsList(obj))
+                {
+                    Console.WriteLine("List");
+                    ShowList((List<object>)obj, level + 1);
+                }
+                else
+                    Console.WriteLine("Value: {0}, Type: {1}",
+                        obj.ToString(), obj.GetType().ToString());
+            }
+        }
+
+        /// <summary>
+        /// A function to diplay a Message. The native Object type is
+        /// decomposed into AMQP types.
+        /// </summary>
+        /// <param name="message">The Message</param>
+        public static void ShowMessage(Message message)
+        {
+            if ("amqp/map" == message.getContentType())
+            {
+                Console.WriteLine("Received a Dictionary");
+                Dictionary<string, object> content = new Dictionary<string, object>();
+                message.getContent(content);
+                ShowDictionary(content, 0);
+            }
+            else if ("amqp/list" == message.getContentType())
+            {
+                Console.WriteLine("Received a List");
+                List<object> content = new List<object>();
+                message.getContent(content);
+                ShowList(content, 0);
+            }
+            else
+            {
+                Console.WriteLine("Received a String");
+                Console.WriteLine(message.getContent());
+            }
+        }
+    }
+
+
+
+    /// <summary>
+    /// A model class to demonstrate how a user may use the Qpid Messaging
+    /// interface to receive Session messages using a callback.
+    /// </summary>
+    class ReceiverProcess : ISessionReceiver
+    {
+        UInt32 messagesReceived = 0;
+
+        /// <summary>
+        /// SessionReceiver implements the ISessionReceiver interface.
+        /// It is the callback function that receives all messages for a Session.
+        /// It may be called any time server is running.
+        /// It is always called on server's private thread.
+        /// </summary>
+        /// <param name="receiver">The Receiver associated with the message.</param>
+        /// <param name="message">The Message</param>
+        public void SessionReceiver(Receiver receiver, Message message)
+        {
+            //
+            // Indicate message reception
+            //
+            Console.WriteLine("--- Message {0}", ++messagesReceived);
+
+            //
+            // Display the received message
+            //
+            MessageViewer.ShowMessage(message);
+
+            //
+            // Acknowledge the receipt of all received messages.
+            //
+            receiver.getSession().acknowledge();
+        }
+
+
+        /// <summary>
+        /// Usage
+        /// </summary>
+        /// <param name="url">Connection target</param>
+        /// <param name="addr">Address: broker exchange + routing key</param>
+        /// <param name="nSec">n seconds to keep callback open</param>
+        static void usage(string url, string addr, int nSec)
+        {
+
+            Console.WriteLine("usage: {0} [url  [addr [nSec]]]",
+                System.Diagnostics.Process.GetCurrentProcess().ProcessName);
+            Console.WriteLine();
+            Console.WriteLine("A program to connect to a broker and receive");
+            Console.WriteLine("messages from a named exchange with a routing key.");
+            Console.WriteLine("The receiver uses a session callback and keeps the callback");
+            Console.WriteLine("server open for so many seconds.");
+            Console.WriteLine("The details of the message body's types and values are shown.");
+            Console.WriteLine();
+            Console.WriteLine(" url  = target address for 'new Connection(url)'");
+            Console.WriteLine(" addr = address for 'session.createReceiver(addr)'");
+            Console.WriteLine(" nSec = time in seconds to keep the receiver callback open");
+            Console.WriteLine();
+            Console.WriteLine("Default values:");
+            Console.WriteLine("  {0} {1} {2} {3}",
+                System.Diagnostics.Process.GetCurrentProcess().ProcessName,
+                url, addr, nSec);
+        }
+
+
+        /// <summary>
+        /// A function to illustrate how to open a Session callback and
+        /// receive messages.
+        /// </summary>
+        /// <param name="args">Main program arguments</param>
+        public void TestProgram(string[] args)
+        {
+            string url = "amqp:tcp:localhost:5672";
+            string addr = "amq.direct/map_example";
+            int nSec = 30;
+
+            if (1 == args.Length)
+            {
+                if (args[0].Equals("-h") || args[0].Equals("-H") || args[0].Equals("/?"))
+                {
+                    usage(url, addr, nSec);
+                    return;
+                }
+            }
+
+            if (args.Length > 0)
+                url = args[0];
+            if (args.Length > 1)
+                addr = args[1];
+            if (args.Length > 2)
+                nSec = System.Convert.ToInt32(args[2]);
+
+            //
+            // Create and open an AMQP connection to the broker URL
+            //
+            Connection connection = new Connection(url);
+            connection.open();
+
+            //
+            // Create a session.
+            //
+            Session session = connection.createSession();
+
+            //
+            // Receive through callback
+            //
+            // Create callback server and implicitly start it
+            //
+            sessionreceiver.server cbServer =
+                new sessionreceiver.server(session, this);
+
+            //
+            // The callback server is running and executing callbacks on a
+            // separate thread.
+            //
+
+            //
+            // Create a receiver for the direct exchange using the
+            // routing key "map_example".
+            //
+            Receiver receiver = session.createReceiver(addr);
+
+            //
+            // Establish a capacity
+            //
+            receiver.setCapacity(100);
+
+            //
+            // Wait so many seconds for messages to arrive.
+            //
+            System.Threading.Thread.Sleep(nSec * 1000);   // in mS
+
+            //
+            // Stop the callback server.
+            //
+            cbServer.close();
+
+            //
+            // Close the receiver and the connection.
+            //
+            receiver.close();
+            connection.close();
+        }
+    }
+
+
+    class MapCallbackReceiverMain
+    {
+        /// <summary>
+        /// Main program
+        /// </summary>
+        /// <param name="args">Main prgram args</param>
+        static void Main(string[] args)
+        {
+            // Invoke 'TestProgram' as non-static class.
+            ReceiverProcess mainProc = new ReceiverProcess();
+
+            mainProc.TestProgram(args);
+
+        }
+    }
+}
+
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
new file mode 100644
index 0000000..e8aae4b
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{68A43817-2358-4A31-8FDF-FE21722BFBCF}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.map.callback.receiver</RootNamespace>
+    <AssemblyName>csharp.map.callback.receiver</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.map.callback.receiver.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\src\sessionreceiver\org.apache.qpid.messaging.sessionreceiver.csproj">
+      <Project>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</Project>
+      <Name>org.apache.qpid.messaging.sessionreceiver</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..1f84944
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/Properties/AssemblyInfo.cs
@@ -0,0 +1,54 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.map.sender")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.map.sender")]
+[assembly: AssemblyCopyright("Copyright   2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("1eec2eca-adbd-4394-8b01-f4c4645bb122")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
new file mode 100644
index 0000000..a097267
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
@@ -0,0 +1,146 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using org.apache.qpid.messaging;
+
+namespace org.apache.qpid.messaging.examples
+{
+    class MapSender
+    {
+        //
+        // usage
+        //
+        static void usage(string url, string addr, UInt32 count)
+        {
+
+            Console.WriteLine("usage: {0} [url  [addr [count]]]",
+                System.Diagnostics.Process.GetCurrentProcess().ProcessName);
+            Console.WriteLine();
+            Console.WriteLine("A program to connect to a broker and send N");
+            Console.WriteLine("messages to a named exchange with a routing key.");
+            Console.WriteLine();
+            Console.WriteLine(" url = target address for 'new Connection(url)'");
+            Console.WriteLine(" addr = address for 'session.createReceiver(addr)'");
+            Console.WriteLine(" count = number of messages to send");
+            Console.WriteLine();
+            Console.WriteLine("Default values:");
+            Console.WriteLine("  {0} {1} {2} {3}",
+                System.Diagnostics.Process.GetCurrentProcess().ProcessName,
+                url, addr, count);
+        }
+
+        
+        //
+        // TestProgram
+        //
+        public void TestProgram(string[] args)
+        {
+            string url = "amqp:tcp:localhost:5672";
+            string addr = "amq.direct/map_example";
+            UInt32 count = 1;
+
+            if (1 == args.Length)
+            {
+                if (args[0].Equals("-h") || args[0].Equals("-H") || args[0].Equals("/?"))
+                {
+                    usage(url, addr, count);
+                    return;
+                }
+            }
+
+            if (args.Length > 0)
+                url = args[0];
+            if (args.Length > 1)
+                addr = args[1];
+            if (args.Length > 2)
+                count = System.Convert.ToUInt32(args[2]);
+
+            
+            //
+            // Create and open an AMQP connection to the broker URL
+            //
+            Connection connection = new Connection(url);
+            connection.open();
+
+            //
+            // Create a session and a sender to the direct exchange using the
+            // routing key "map_example".
+            //
+            Session session = connection.createSession();
+            Sender sender = session.createSender(addr);
+
+            //
+            // Create structured content for the message.  This example builds a
+            // map of items including a nested map and a list of values.
+            //
+            Dictionary<string, object> content = new Dictionary<string, object>();
+            Dictionary<string, object> subMap = new Dictionary<string, object>();
+            List<object> colors = new List<object>();
+
+            content["id"] = 987654321;
+            content["name"] = "Widget";
+            content["percent"] = 0.99;
+
+            subMap["name"] = "Smith";
+            subMap["number"] = 354;
+
+            content["nested"] = subMap;
+
+            colors.Add("red");
+            colors.Add("green");
+            colors.Add("white");
+
+            content["colors"] = colors;
+
+            //
+            // Construct a message with the map content and send it synchronously
+            // via the sender.
+            //
+            Message message = new Message(content);
+            for (UInt32 i = 0; i<count; i++)
+                sender.send(message, true);
+
+            //
+            // Close the connection.
+            //
+            connection.close();
+        }
+    }
+
+    class MapSenderMain
+    {
+        //
+        // Main
+        //
+        static void Main(string[] args)
+        {
+            // Invoke 'TestProgram' as non-static class.
+            MapSender mainProc = new MapSender();
+
+            mainProc.TestProgram(args);
+
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
new file mode 100644
index 0000000..5089737
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
@@ -0,0 +1,66 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{12F1C14F-5C7D-4075-9BAE-C091394FF99A}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.map.callback.sender</RootNamespace>
+    <AssemblyName>csharp.map.callback.sender</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.map.callback.sender.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
index a491274..380e33b 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
@@ -17,7 +17,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
@@ -31,10 +31,6 @@
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <ItemGroup>
-    <Reference Include="org.apache.qpid.messagingd, Version=1.0.3786.14109, Culture=neutral, PublicKeyToken=7e57166074abee8c, processorArchitecture=x86">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\bin\Debug\org.apache.qpid.messagingd.dll</HintPath>
-    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
@@ -52,6 +48,16 @@
     <Compile Include="csharp.map.recevier.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\..\src\sessionreceiver\org.apache.qpid.messaging.sessionreceiver.csproj">
+      <Project>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</Project>
+      <Name>org.apache.qpid.messaging.sessionreceiver</Name>
+    </ProjectReference>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
index 461708e..9a425c0 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
@@ -29,8 +29,8 @@ namespace org.apache.qpid.messaging.examples
     {
         static void Main(string[] args)
         {
-//            string url = "amqp:tcp:localhost:5672";
-            string url = "10.16.18.254:5672";
+            string url = "amqp:tcp:localhost:5672";
+//            string url = "10.16.18.254:5672";
             if (args.Length > 0)
                 url = args[0];
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
index d647509..4482e6a 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
@@ -17,7 +17,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
@@ -31,10 +31,6 @@
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <ItemGroup>
-    <Reference Include="org.apache.qpid.messagingd, Version=1.0.3786.14109, Culture=neutral, PublicKeyToken=7e57166074abee8c, processorArchitecture=x86">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\bin\Debug\org.apache.qpid.messagingd.dll</HintPath>
-    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
@@ -52,6 +48,12 @@
     <Compile Include="csharp.map.sender.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
diff --git a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
index 0619727..8b0b3fd 100644
--- a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
+++ b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
@@ -28,8 +28,20 @@ EndProject
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "StructuredMessage", "StructuredMessage", "{E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}"
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.sender", "examples\csharp.map.sender\csharp.map.sender.csproj", "{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}"
+	ProjectSection(ProjectDependencies) = postProject
+		{AA5A3B83-5F98-406D-A01C-5A921467A57D} = {AA5A3B83-5F98-406D-A01C-5A921467A57D}
+	EndProjectSection
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.receiver", "examples\csharp.map.receiver\csharp.map.receiver.csproj", "{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}"
+	ProjectSection(ProjectDependencies) = postProject
+		{AA5A3B83-5F98-406D-A01C-5A921467A57D} = {AA5A3B83-5F98-406D-A01C-5A921467A57D}
+	EndProjectSection
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "org.apache.qpid.messaging.sessionreceiver", "src\sessionreceiver\org.apache.qpid.messaging.sessionreceiver.csproj", "{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.callback.receiver", "examples\csharp.map.callback.receiver\csharp.map.callback.receiver.csproj", "{68A43817-2358-4A31-8FDF-FE21722BFBCF}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.callback.sender", "examples\csharp.map.callback.sender\csharp.map.callback.sender.csproj", "{12F1C14F-5C7D-4075-9BAE-C091394FF99A}"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -101,6 +113,36 @@ Global
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Win32.ActiveCfg = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Any CPU.Build.0 = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Mixed Platforms.Build.0 = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Win32.ActiveCfg = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Any CPU.Build.0 = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Mixed Platforms.Build.0 = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Win32.ActiveCfg = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Any CPU.Build.0 = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Mixed Platforms.Build.0 = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Win32.ActiveCfg = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -114,5 +156,7 @@ Global
 		{AF2FBC78-266C-430C-BC29-9477AB596A36} = {39E9D1BF-3A0B-4D86-BF6B-F463E1A2245A}
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 	EndGlobalSection
 EndGlobal
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
new file mode 100644
index 0000000..8b48a20
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
@@ -0,0 +1,186 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+#include <windows.h>
+#include <msclr\lock.h>
+#include <oletx2xa.h>
+#include <string>
+#include <limits>
+
+#include "qpid/messaging/Address.h"
+
+#include "Address.h"
+#include "QpidMarshal.h"
+#include "QpidTypeCheck.h"
+#include "TypeTranslator.h"
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+    /// <summary>
+    /// Address is a managed wrapper for a qpid::messaging::Address
+    /// </summary>
+
+    // Create empty
+    Address::Address() :
+        addressp(new ::qpid::messaging::Address(QpidMarshal::ToNative("")))
+    {
+    }
+
+    // Create string address
+    Address::Address(System::String ^ address) :
+        addressp(new ::qpid::messaging::Address(QpidMarshal::ToNative(address)))
+    {
+    }
+
+    // Create with options
+    Address::Address(System::String ^ name, 
+                     System::String ^ subject,
+                     System::Collections::Generic::Dictionary<
+                         System::String ^, System::Object ^> ^ options) :
+        addressp(new ::qpid::messaging::Address())
+    {
+        setName(name);
+        setSubject(subject);
+        setOptions(options);
+        setType("");
+    }
+
+
+    Address::Address(System::String ^ name, 
+                     System::String ^ subject,
+                     System::Collections::Generic::Dictionary<
+                         System::String ^, System::Object ^> ^ options,
+                     System::String ^ type) :
+        addressp(new ::qpid::messaging::Address())
+    {
+        setName(name);
+        setSubject(subject);
+        setOptions(options);
+        setType(type);
+    }
+
+
+    // Create from received address
+    Address::Address(::qpid::messaging::Address * addrp) :
+        addressp(addrp)
+    {
+    }
+
+    // Destructor
+    Address::~Address()
+    {
+        Cleanup();
+    }
+
+
+    // Finalizer
+    Address::!Address()
+    {
+        Cleanup();
+    }
+
+
+    // Destroys kept object
+    // TODO: add lock
+    void Address::Cleanup()
+    {
+        if (NULL != addressp)
+        {
+            delete addressp;
+            addressp = NULL;
+        }
+    }
+
+
+    //
+    // name
+    //
+    System::String ^ Address::getName()
+    {
+        return gcnew System::String(addressp->getName().c_str());
+    }
+
+    void Address::setName(System::String ^ name)
+    {
+        addressp->::qpid::messaging::Address::setName(QpidMarshal::ToNative(name));
+    }
+
+    //
+    // subject
+    //
+    System::String ^ Address::getSubject()
+    {
+        return gcnew System::String(addressp->getSubject().c_str());
+    }
+
+    void Address::setSubject(System::String ^ subject)
+    {
+        addressp->setName(QpidMarshal::ToNative(subject));
+    }
+
+    //
+    // options
+    //
+    System::Collections::Generic::Dictionary<
+        System::String ^, System::Object ^> ^ Address::getOptions()
+    {
+        ::qpid::types::Variant::Map map;
+        System::Collections::Generic::Dictionary<
+            System::String ^, System::Object ^> ^ newMap = 
+            gcnew System::Collections::Generic::Dictionary<
+                  System::String ^, System::Object ^>;
+        map = addressp->getOptions();
+        TypeTranslator::NativeToManaged(newMap, map);
+        return newMap;
+    }
+
+
+    void Address::setOptions(System::Collections::Generic::Dictionary<
+                        System::String ^, System::Object ^> ^ options)
+    {
+        ::qpid::types::Variant::Map map;
+        TypeTranslator::ManagedToNative(map, options);
+        addressp->setOptions(map);
+    }
+
+    //
+    // type
+    //
+    System::String ^ Address::getType()
+    {
+        return gcnew System::String(addressp->getType().c_str());
+    }
+
+
+    void Address::setType(System::String ^ type)
+    {
+        addressp->setName(QpidMarshal::ToNative(type));
+    }
+
+    //
+    // str
+    //
+    System::String ^ Address::str()
+    {
+        return gcnew System::String(addressp->str().c_str());
+    }
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.h b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
new file mode 100644
index 0000000..72eed76
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
@@ -0,0 +1,89 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+#pragma once
+
+#include <windows.h>
+#include <msclr\lock.h>
+#include <oletx2xa.h>
+#include <string>
+#include <limits>
+
+#include "qpid/messaging/Address.h"
+
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+    /// <summary>
+    /// Address is a managed wrapper for a qpid::messaging::Address
+    /// </summary>
+
+    public ref class Address
+    {
+    private:
+        // Kept object deletion code
+        void Cleanup();
+
+    public:
+        // The kept object in the Messaging C++ DLL
+        ::qpid::messaging::Address * addressp;
+
+        Address();
+        
+        Address(System::String ^ address);
+
+        Address(System::String ^ name,
+                System::String ^ subject,
+                System::Collections::Generic::Dictionary<
+                    System::String ^, System::Object ^> ^ options);
+                
+        Address(System::String ^ name,
+                System::String ^ subject,
+                System::Collections::Generic::Dictionary<
+                    System::String ^, System::Object ^> ^ options,
+                System::String ^ type);
+
+        // Create from received address
+        Address(::qpid::messaging::Address * addrp);
+
+        ~Address();
+        !Address();
+//        Address(const Address % rhs);
+
+        System::String ^ getName();
+        void setName(System::String ^ name);
+
+        System::String ^ getSubject();
+        void setSubject(System::String ^ subject);
+
+        System::Collections::Generic::Dictionary<
+            System::String ^, System::Object ^> ^ getOptions();
+
+        void setOptions(System::Collections::Generic::Dictionary<
+                            System::String ^, System::Object ^> ^ options);
+
+        System::String ^ getType();
+        void setType(System::String ^ type);
+
+        System::String ^ str();
+    };
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
index 58b93f6..4936e18 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
@@ -25,10 +25,13 @@
 
 #include "qpid/messaging/Connection.h"
 #include "qpid/messaging/Session.h"
+#include "qpid/messaging/exceptions.h"
 
 #include "QpidMarshal.h"
 #include "Connection.h"
 #include "Session.h"
+#include "QpidException.h"
+#include "TypeTranslator.h"
 
 namespace org {
 namespace apache {
@@ -39,12 +42,25 @@ namespace messaging {
     /// Connection is a managed wrapper for a qpid::messaging::Connection
     /// </summary>
 
-    // Public constructor
+    // constructors
     Connection::Connection(System::String ^ url) :
         connectionp(new ::qpid::messaging::Connection(QpidMarshal::ToNative(url)))
     {
     }
 
+
+    Connection::Connection(System::String ^ url,
+                           System::Collections::Generic::Dictionary<
+                               System::String ^, System::Object ^> ^ options) :
+        connectionp(new ::qpid::messaging::Connection(QpidMarshal::ToNative(url)))
+    {
+        for each (System::Collections::Generic::KeyValuePair<System::String^, System::Object^> kvp in options)
+        {
+            setOption(kvp.Key, kvp.Value);
+        }
+    }
+
+
     Connection::Connection(System::String ^ url, System::String ^ options) :
         connectionp(new ::qpid::messaging::Connection(QpidMarshal::ToNative(url),
                     QpidMarshal::ToNative(options)))
@@ -77,39 +93,185 @@ namespace messaging {
         }
     }
 
-    Session ^ Connection::createSession()
+
+    void Connection::setOption(System::String ^ name, System::Object ^ value)
     {
-        return createSession("");
+        ::qpid::types::Variant entryValue;
+        TypeTranslator::ManagedToNativeObject(value, entryValue);
+        std::string entryName = QpidMarshal::ToNative(name);
+        connectionp->::qpid::messaging::Connection::setOption(entryName, entryValue);
     }
 
+    void Connection::open()
+    {
+        connectionp->open();
+    }
 
-    Session ^ Connection::createSession(System::String ^ name)
+    System::Boolean Connection::isOpen()
     {
-        // allocate native session
-        ::qpid::messaging::Session * sessionp = new ::qpid::messaging::Session;
+        return connectionp->isOpen();
+    }
 
-        // create native session
-        *sessionp = connectionp->createSession(QpidMarshal::ToNative(name));
+    void Connection::close()
+    {
+        connectionp->close();
+    }
+
+    //
+    // createTransactionalSession()
+    //
+    Session ^ Connection::createTransactionalSession()
+    {
+        return createTransactionalSession("");
+    }
+
+
+    Session ^ Connection::createTransactionalSession(System::String ^ name)
+    {
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Session * sessionp     = NULL;
+        Session                    ^ newSession   = nullptr;
 
-        // create managed session
-        Session ^ newSession = gcnew Session(sessionp, this);
+        try
+        {
+            // allocate native session
+            sessionp = new ::qpid::messaging::Session ;
+
+            // create native session
+            *sessionp = connectionp->createTransactionalSession(QpidMarshal::ToNative(name));
+
+            // create managed session
+            newSession = gcnew Session(sessionp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Connection::createTransactionalSession unknown error");
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+                throw newException;
+            }
+        }
 
         return newSession;
     }
 
 
-    void Connection::open()
+    //
+    // createSession()
+    //
+    Session ^ Connection::createSession()
     {
-        connectionp->open();
+        return createSession("");
     }
 
-    bool Connection::isOpen()
+
+    Session ^ Connection::createSession(System::String ^ name)
     {
-        return connectionp->isOpen();
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Session * sessionp     = NULL;
+        Session                    ^ newSession   = nullptr;
+
+        try
+        {
+            // allocate native session
+            sessionp = new ::qpid::messaging::Session ;
+
+            // create native session
+            *sessionp = connectionp->createSession(QpidMarshal::ToNative(name));
+
+            // create managed session
+            newSession = gcnew Session(sessionp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Connection::createSession unknown error");
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+                throw newException;
+            }
+        }
+
+        return newSession;
     }
 
-    void Connection::close()
+
+    Session ^ Connection::getSession(System::String ^ name)
     {
-        connectionp->close();
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Session * sess         = NULL;
+        Session                    ^ newSession   = nullptr;
+      
+        try
+        {
+            const std::string n = QpidMarshal::ToNative(name);
+
+            *sess = connectionp->::qpid::messaging::Connection::getSession(n);
+            
+            newSession = gcnew Session(sess, this);
+        }
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Connection::getSession unknown error");
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sess != NULL)
+                {
+                    delete sess;
+                }
+                throw newException;
+            }
+        }
+
+        return newSession;
     }
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
index e16cb1e..894a96d 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
@@ -50,14 +50,29 @@ namespace messaging {
 
     public:
         Connection(System::String ^ url);
+
+        Connection(System::String ^ url, 
+                   System::Collections::Generic::Dictionary<
+                       System::String ^, System::Object ^> ^ options);
+
         Connection(System::String ^ url, System::String ^ options);
         ~Connection();
         !Connection();
 
-        Session ^ createSession();
-        Session ^ createSession(System::String ^ name);
+        void setOption(System::String ^ name, System::Object ^ value);
+
         void open();
-        bool isOpen();
+        System::Boolean isOpen();
         void close();
+
+        // createTransactionalSession()
+        Session ^ createTransactionalSession();
+        Session ^ createTransactionalSession(System::String ^ name);
+
+        // createSession()
+        Session ^ createSession();
+        Session ^ createSession(System::String ^ name);
+
+        Session ^ getSession(System::String ^ name);
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Duration.h b/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
index 9b763a7..b7d2bf1 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
@@ -25,8 +25,6 @@
 #include <string>
 #include <limits>
 
-#include "qpid/messaging/Duration.h"
-
 namespace org {
 namespace apache {
 namespace qpid {
@@ -34,34 +32,59 @@ namespace messaging {
 
     /// <summary>
     /// Duration is a time interval in milliseconds.
-    /// It is a managed wrapper for a ::qpid::messaging::Duration
+    /// It is a managed equivalent of ::qpid::messaging::Duration
     /// </summary>
 
     public ref class Duration
     {
     private:
-        // Experimental constructor
-        Duration(const ::qpid::messaging::Duration *);
-
-        // Kept object deletion code
-        void Cleanup();
+        System::UInt64 milliseconds;
 
     public:
-        Duration(System::UInt64 milliseconds);
-        ~Duration();
-        !Duration();
 
-        // The kept object in the Messaging C++ DLL
-        const ::qpid::messaging::Duration * durationp;
+        Duration(const Duration % rhs) :
+            milliseconds(rhs.milliseconds)
+        {
+        };
+
+        explicit Duration(System::UInt64 mS) : 
+            milliseconds(mS) {};
+        
+        Duration()                           : 
+            milliseconds(System::UInt64::MaxValue) {};
+
+        property System::UInt64 Milliseconds
+        {
+            System::UInt64 get () { return milliseconds; }
+        }
+
+        static Duration ^ operator * (Duration ^ dur, const System::UInt64 multiplier)
+        {
+            Duration ^ result = gcnew Duration(dur->Milliseconds * multiplier);
+            return result;
+        }
 
-        System::UInt64 getMilliseconds();
+        static Duration ^ operator * (const System::UInt64 multiplier, Duration ^ dur)
+        {
+            Duration ^ result = gcnew Duration(multiplier * dur->Milliseconds);
+            return result;
+        }
+    };
+
+    public ref class DurationConstants
+    {
+    public:
+        static Duration ^ FORVER;
+        static Duration ^ IMMEDIATE;
+        static Duration ^ SECOND;
+        static Duration ^ MINUTE;
 
-        // Return value(s) for constant durations
-        // NOTE: These return the duration mS and not a Duration 
-        //       object like the C++ code gets.
-        System::UInt64 FOREVER();
-        System::UInt64 IMMEDIATE();
-        System::UInt64 SECOND();
-        System::UInt64 MINUTE();
+        static DurationConstants()
+        {
+            FORVER    = gcnew Duration();
+            IMMEDIATE = gcnew Duration(0);
+            SECOND    = gcnew Duration(1000);
+            MINUTE    = gcnew Duration(60000);
+        }
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
index 9c28e72..193a2eb 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
@@ -29,7 +29,12 @@
 #include "qpid/types/Variant.h"
 
 #include "QpidMarshal.h"
+#include "Address.h"
+#include "Duration.h"
 #include "Message.h"
+#include "QpidTypeCheck.h"
+#include "QpidException.h"
+#include "TypeTranslator.h"
 
 namespace org {
 namespace apache {
@@ -40,38 +45,26 @@ namespace messaging {
     /// Message is a managed wrapper for a ::qpid::messaging::Message
     /// </summary>
 
-    // This constructor is used to create a message from bytes to put into the message
-    Message::Message(System::String ^ bytes) :
-        aVMap(gcnew VMap()),
-        aVList(gcnew VList()),
-        pVMapType(aVMap.GetType()),
-        pVListType(aVList.GetType()),
-        messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative(bytes)))
+    // Create empty message
+    Message::Message() :
+        messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative("")))
     {
     }
 
-    // This constructor creates a message from a native received message
-    Message::Message(::qpid::messaging::Message * msgp) :
-        aVMap(gcnew VMap()),
-        aVList(gcnew VList()),
-        pVMapType(aVMap.GetType()),
-        pVListType(aVList.GetType()),
-        messagep(msgp)
+    // Create from string
+    Message::Message(System::String ^ string) :
+        messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative(string)))
     {
     }
 
-
+    // Create from object
     Message::Message(System::Object ^ objp) :
-        aVMap(gcnew VMap()),
-        aVList(gcnew VList()),
-        pVMapType(aVMap.GetType()),
-        pVListType(aVList.GetType()),
         messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative("")))
     {
         ::qpid::types::Variant * variantp  = 0;
         std::string            * variantsp = 0;
 
-        if (objIsMap(objp))
+        if (QpidTypeCheck::ObjectIsMap(objp))
         {
             // Create a mapped message using given dictionary
 
@@ -79,7 +72,7 @@ namespace messaging {
             ::qpid::types::Variant::Map newMap;
 
             // Add the map variables to the map
-            Encode(newMap, (VMap ^)objp);
+            TypeTranslator::ManagedToNative(newMap, (QpidMap ^)objp);
 
             // Set message content type
             messagep->setContentType("ampq/map");
@@ -87,7 +80,7 @@ namespace messaging {
             // Insert the map into the message
             ::qpid::messaging::encode(newMap, *messagep, QpidMarshal::ToNative("amqp/map"));
         }
-        else if (objIsList(objp))
+        else if (QpidTypeCheck::ObjectIsList(objp))
         {
             // Create a list message using given list
 
@@ -95,7 +88,7 @@ namespace messaging {
             ::qpid::types::Variant::List newList;
 
             // Add the list variables to the list
-            Encode(newList, (VList ^)objp);
+            TypeTranslator::ManagedToNative(newList, (QpidList ^)objp);
 
             // Set message content type
             messagep->setContentType("ampq/list");
@@ -110,6 +103,12 @@ namespace messaging {
         }
     }
 
+    // Create from received message
+    Message::Message(::qpid::messaging::Message * msgp) :
+        messagep(msgp)
+    {
+    }
+
 
     // Destructor
     Message::~Message()
@@ -125,6 +124,7 @@ namespace messaging {
     }
 
     // Copy constructor
+    // TODO: prevent copy
     Message::Message(const Message % rhs)
     {
         messagep      = rhs.messagep;
@@ -143,209 +143,25 @@ namespace messaging {
 
 
     //
-    // The given object is a Dictionary.
-    // Add its elements to the qpid map.
+    // ReplyTo
     //
-    void Message::Encode(::qpid::types::Variant::Map & theMapp,
-                         VMap ^ theObjp)
+    void Message::setReplyTo(Address ^ address)
     {
-        // iterate the items, converting each to a variant and adding to the map
-        for each (System::Collections::Generic::KeyValuePair<System::String^, System::Object^> kvp in theObjp)
-        {
-            if (objIsMap(kvp.Value))
-            {
-                // Recurse on inner map
-                // Allocate a map
-                ::qpid::types::Variant::Map newMap;
-
-                // Add the map variables to the map
-                Encode(newMap, (VMap ^)kvp.Value);
-
-                // Create a variant entry for the inner map
-                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
-
-                // Get map's name
-                std::string entryName = QpidMarshal::ToNative(kvp.Key);
-
-                // Add inner map to outer map
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, *newVariantp));
-            }
-            else if (objIsList(kvp.Value))
-            {
-                // Recurse on inner list
-                // Allocate a list
-                ::qpid::types::Variant::List newList;
-
-                // Add the List variables to the list
-                Encode(newList, (VList ^)kvp.Value);
-
-                // Create a variant entry for the inner map
-                ::qpid::types::Variant::List newVariant(newList);
-
-                //std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newList));
-
-                // Get list's name
-                std::string entryName = QpidMarshal::ToNative(kvp.Key);
-
-                // Add inner list to outer map
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, newVariant));
-            }
-            else
-            {
-                // Add a simple native type to map
-                ::qpid::types::Variant entryValue;
-                EncodeObject(kvp.Value, entryValue);
-                std::string entryName = QpidMarshal::ToNative(kvp.Key);
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, entryValue));
-            }
-        }
+        messagep->setReplyTo(*(address->addressp));
     }
 
-
-
-    //
-    // The given object is a List.
-    // Add its elements to the qpid list.
-    //
-    void Message::Encode(::qpid::types::Variant::List & theListp,
-                         VList ^ theObjp)
+    Address ^ Message::getReplyTo()
     {
-        // iterate the items, converting each to a variant and adding to the map
-        for each (System::Object ^ listObj in theObjp)
-        {
-            if (objIsMap(listObj))
-            {
-                // Recurse on inner map
-                // Allocate a map
-                ::qpid::types::Variant::Map newMap;
-
-                // Add the map variables to the map
-                Encode(newMap, (VMap ^)listObj);
-
-                // Create a variant entry for the inner map
-                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
-
-                // Add inner map to outer list
-                theListp.push_back(*newVariantp);
-            }
-            else if (objIsList(listObj))
-            {
-                // Recurse on inner list
-                // Allocate a list
-                ::qpid::types::Variant::List newList;
-
-                // Add the List variables to the list
-                Encode(newList, (VList ^)listObj);
-
-                // Create a variant entry for the inner list
-                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newList));
-
-                // Add inner list to outer list
-                theListp.push_back(*newVariantp);
-            }
-            else
-            {
-                // Add a simple native type to list
-                ::qpid::types::Variant entryValue;
-                EncodeObject(listObj, entryValue);
-                theListp.push_back(entryValue);
-            }
-        }
-    }
+        const ::qpid::messaging::Address & addrp =
+            messagep->::qpid::messaging::Message::getReplyTo();
 
+        return gcnew Address(const_cast<::qpid::messaging::Address *>(&addrp));
+    }
 
 
     //
-    // Returns a variant representing simple native type object.
-    // Not to be called for Map/List objects.
+    // Subject
     //
-    void Message::EncodeObject(System::Object ^ theObjp, 
-                               ::qpid::types::Variant & targetp)
-    {
-        System::Type     ^ typeP    = (*theObjp).GetType();
-        System::TypeCode   typeCode = System::Type::GetTypeCode( typeP );
-
-        switch (typeCode)
-        {
-        case System::TypeCode::Boolean :
-            targetp = System::Convert::ToBoolean(theObjp);
-            break;
-
-        case System::TypeCode::Byte :
-            targetp = System::Convert::ToByte(theObjp);
-            break;
-
-        case System::TypeCode::UInt16 :
-            targetp = System::Convert::ToUInt16(theObjp);
-            break;
-
-        case System::TypeCode::UInt32 :
-            targetp = System::Convert::ToUInt32(theObjp);
-            break;
-
-        case System::TypeCode::UInt64 :
-            targetp = System::Convert::ToUInt64(theObjp);
-            break;
-
-        case System::TypeCode::Char :
-        case System::TypeCode::SByte :
-            targetp = System::Convert::ToSByte(theObjp);
-            break;
-
-        case System::TypeCode::Int16 :
-            targetp = System::Convert::ToInt16(theObjp);
-            break;
-
-        case System::TypeCode::Int32 :
-            targetp = System::Convert::ToInt32(theObjp);
-            break;
-
-        case System::TypeCode::Int64 :
-            targetp = System::Convert::ToInt64(theObjp);
-            break;
-
-        case System::TypeCode::Single :
-            targetp = System::Convert::ToSingle(theObjp);
-            break;
-
-        case System::TypeCode::Double :
-            targetp = System::Convert::ToDouble(theObjp);
-            break;
-
-        case System::TypeCode::String :
-            {
-                std::string      rString;
-                System::String ^ rpString;
-
-                rpString = System::Convert::ToString(theObjp);
-                rString = QpidMarshal::ToNative(rpString);
-                targetp = rString;
-				targetp.setEncoding(QpidMarshal::ToNative("utf8"));
-            }
-            break;
-
-            
-        default:
-
-            throw gcnew System::NotImplementedException();
-
-        }
-    }
-
-
-    // Properties...
-
-    //void Message::setReplyTo(System::String ^ address)
-    //{
-    //    messagep->setReplyTo(QpidMarshal::ToNative(address));
-    //}
-
-    //System::String ^ Message::getReplyTo()
-    //{
-    //    return gcnew String(messagep->getReplyTo().c_str());
-    //}
-
-
     void Message::setSubject(System::String ^ subject)
     {
         messagep->setSubject(QpidMarshal::ToNative(subject));
@@ -357,6 +173,9 @@ namespace messaging {
     }
     
 
+    //
+    // ContentType
+    //
     void Message::setContentType(System::String ^ ct)
     {
         messagep->setContentType(QpidMarshal::ToNative(ct));
@@ -368,6 +187,9 @@ namespace messaging {
     }
     
     
+    //
+    // MessageId
+    //
     void Message::setMessageId(System::String ^ mId)
     {
         messagep->setMessageId(QpidMarshal::ToNative(mId));
@@ -379,6 +201,9 @@ namespace messaging {
     }
     
     
+    //
+    // UserId
+    //
     void Message::setUserId(System::String ^ uId)
     {
         messagep->setUserId(QpidMarshal::ToNative(uId));
@@ -390,6 +215,9 @@ namespace messaging {
     }
     
     
+    //
+    // CorrelationId
+    //
     void Message::setCorrelationId(System::String ^ cId)
     {
         messagep->setCorrelationId(QpidMarshal::ToNative(cId));
@@ -401,6 +229,9 @@ namespace messaging {
     }
     
 
+    //
+    // Priority
+    //
     void Message::setPriority(unsigned char priority)
     {
         messagep->setPriority(priority);
@@ -412,8 +243,22 @@ namespace messaging {
     }
     
 
-    //void setTtl(Duration ttl);
-    //Duration getTtl();
+    //
+    // Ttl
+    //
+    void Message::setTtl(Duration ^ ttl)
+    {
+        ::qpid::messaging::Duration dur(ttl->Milliseconds);
+
+        messagep->setTtl(dur);
+    }
+    
+    Duration ^ Message::getTtl()
+    {
+        Duration ^ dur = gcnew Duration(messagep->getTtl().getMilliseconds());
+
+        return dur;
+    }
 
     void Message::setDurable(bool durable)
     {
@@ -437,11 +282,22 @@ namespace messaging {
     }
 
 
-    //System::String ^ Message::getProperties()
-    //{
-    //    pqid::types::Variant::Map * mapp = new
-    //    return gcnew String(messagep->getReplyTo().c_str());
-    //}
+    System::Collections::Generic::Dictionary<
+            System::String^, System::Object^> ^ Message::getProperties()
+    {
+        ::qpid::types::Variant::Map map;
+
+        map = messagep->getProperties();
+
+        System::Collections::Generic::Dictionary<
+            System::String^, System::Object^> ^ dict =
+            gcnew System::Collections::Generic::Dictionary<
+                      System::String^, System::Object^> ;
+
+        TypeTranslator::NativeToManaged(dict, map);
+
+        return dict;
+    }
 
 
     void Message::setContent(System::String ^ content)
@@ -468,100 +324,7 @@ namespace messaging {
         
         ::qpid::messaging::decode(*messagep, map, QpidMarshal::ToNative("amqp/map"));
 
-        Decode(dict, map);
-    }
-
-
-    // Given a user Dictionary and a qpid map,
-    //   extract the qpid elements and put them into the dictionary.
-    //
-    void Message::Decode(VMap ^ dict, ::qpid::types::Variant::Map & map)
-    {
-        // For each object in the message map, 
-        //  create a .NET object and add it to the dictionary.
-        for (::qpid::types::Variant::Map::const_iterator i = map.begin(); i != map.end(); ++i) {
-            // Get the name
-            System::String ^ elementName = gcnew String(i->first.c_str());
-
-            ::qpid::types::Variant     variant = i->second;
-            ::qpid::types::VariantType vType   = variant.getType();
-
-            switch (vType)
-            {
-            case ::qpid::types::VAR_BOOL:
-                dict[elementName] = variant.asBool();
-                break;
-                
-            case ::qpid::types::VAR_UINT8:
-                dict[elementName] = variant.asUint8();
-                break;
-                
-            case ::qpid::types::VAR_UINT16:
-                dict[elementName] = variant.asUint16();
-                break;
-                
-            case ::qpid::types::VAR_UINT32:
-                dict[elementName] = variant.asUint32();
-                break;
-                
-            case ::qpid::types::VAR_UINT64:
-                dict[elementName] = variant.asUint64();
-                break;
-                
-            case ::qpid::types::VAR_INT8:
-                dict[elementName] = variant.asInt8();
-                break;
-                
-            case ::qpid::types::VAR_INT16:
-                dict[elementName] = variant.asInt16();
-                break;
-                
-            case ::qpid::types::VAR_INT32:
-                dict[elementName] = variant.asInt32();
-                break;
-                
-            case ::qpid::types::VAR_INT64:
-                dict[elementName] = variant.asInt64();
-                break;
-                
-            case ::qpid::types::VAR_FLOAT:
-                dict[elementName] = variant.asFloat();
-                break;
-                
-            case ::qpid::types::VAR_DOUBLE:
-                dict[elementName] = variant.asDouble();
-                break;
-                
-            case ::qpid::types::VAR_STRING:
-                {
-                    System::String ^ elementValue = gcnew System::String(variant.asString().c_str());
-                    dict[elementName] = elementValue;
-                    break;
-                }
-            case ::qpid::types::VAR_MAP:
-                {
-                    VMap ^ newDict = gcnew VMap();
-
-                    Decode (newDict, variant.asMap());
-
-                    dict[elementName] = newDict;
-                    break;
-                }
-
-            case ::qpid::types::VAR_LIST:
-                {
-                    VList ^ newList = gcnew VList();
-
-                    Decode (newList, variant.asList());
-
-                    dict[elementName] = newList;
-                    break;
-                }
-                
-            case ::qpid::types::VAR_UUID:
-                break;
-            }
-        }
+        TypeTranslator::NativeToManaged(dict, map);
     }
 
 
@@ -571,99 +334,43 @@ namespace messaging {
     void Message::getContent(System::Collections::Generic::List<
                         System::Object^> ^ list)
     {
-        // Extract the message map from the message
-        ::qpid::types::Variant::List vList;
+        // allocate a native messaging::List
+        ::qpid::types::Variant::List nativeList;
         
-        ::qpid::messaging::decode(*messagep, vList, QpidMarshal::ToNative("amqp/list"));
+        // Extract the list from the message in native format
+        ::qpid::messaging::decode(*messagep, nativeList, QpidMarshal::ToNative("amqp/list"));
 
-        Decode(list, vList);
+        // translate native list into user's managed list
+        TypeTranslator::NativeToManaged(list, nativeList);
     }
 
-
-    void Message::Decode(VList ^ vList, ::qpid::types::Variant::List & qpidList)
+    //
+    // User wants content as bytes.
+    // result array must be correct size already
+    //
+    void Message::getRaw(array<System::Byte> ^ arr)
     {
-        // For each object in the message map, 
-        //  create a .NET object and add it to the dictionary.
-        for (::qpid::types::Variant::List::const_iterator i = qpidList.begin(); i != qpidList.end(); ++i) 
+        System::UInt32 size = messagep->getContentSize();
+     
+        if (0 == size)
+            throw gcnew QpidException("Message::getRaw - message size is zero");
+
+        if (arr->Length != size)
+            throw gcnew QpidException("Message::getRaw - receive buffer is too small");
+
+        const char * ptr = messagep->getContentPtr();
+
+        // TODO: System::Runtime::InteropServices::Marshal::Copy(ptr, arr, 0, size);
+
+        for (UInt32 i = 0; i < size; i++)
         {
-            ::qpid::types::Variant     variant = *i;
-            ::qpid::types::VariantType vType   = variant.getType();
-
-            switch (vType)
-            {
-            case ::qpid::types::VAR_BOOL:
-                (*vList).Add(variant.asBool());
-                break;
-                
-            case ::qpid::types::VAR_UINT8:
-                (*vList).Add(variant.asUint8());
-                break;
-                
-            case ::qpid::types::VAR_UINT16:
-                (*vList).Add(variant.asUint16());
-                break;
-                
-            case ::qpid::types::VAR_UINT32:
-                (*vList).Add(variant.asUint32());
-                break;
-                
-            case ::qpid::types::VAR_UINT64:
-                (*vList).Add(variant.asUint64());
-                break;
-                
-            case ::qpid::types::VAR_INT8:
-                (*vList).Add(variant.asInt8());
-                break;
-                
-            case ::qpid::types::VAR_INT16:
-                (*vList).Add(variant.asInt16());
-                break;
-                
-            case ::qpid::types::VAR_INT32:
-                (*vList).Add(variant.asInt32());
-                break;
-                
-            case ::qpid::types::VAR_INT64:
-                (*vList).Add(variant.asInt64());
-                break;
-                
-            case ::qpid::types::VAR_FLOAT:
-                (*vList).Add(variant.asFloat());
-                break;
-                
-            case ::qpid::types::VAR_DOUBLE:
-                (*vList).Add(variant.asDouble());
-                break;
-                
-            case ::qpid::types::VAR_STRING:
-                {
-                    System::String ^ elementValue = gcnew System::String(variant.asString().c_str());
-                    (*vList).Add(elementValue);
-                    break;
-                }
-            case ::qpid::types::VAR_MAP:
-                {
-                    VMap ^ newDict = gcnew VMap();
-
-                    Decode (newDict, variant.asMap());
-
-                    (*vList).Add(newDict);
-                    break;
-                }
-
-            case ::qpid::types::VAR_LIST:
-                {
-                    VList ^ newList = gcnew VList();
-
-                    Decode (newList, variant.asList());
-
-                    (*vList).Add(newList);
-                    break;
-                }
-                
-            case ::qpid::types::VAR_UUID:
-                break;
-            }
+            arr[i] = ptr[i];
         }
     }
+
+
+    System::UInt64 Message::getContentSize()
+    {
+        return messagep->getContentSize();
+    }
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.h b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
index c308fdf..ab06588 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
@@ -31,14 +31,8 @@ namespace apache {
 namespace qpid {
 namespace messaging {
 
-typedef System::Collections::Generic::Dictionary<
-            System::String^, 
-            System::Object^> 
-                VMap;
-
-typedef System::Collections::Generic::List<
-            System::Object^> 
-                VList;
+    ref class Address;
+    ref class Duration;
 
     /// <summary>
     /// Message is a managed wrapper for a ::qpid::messaging::Message
@@ -51,51 +45,20 @@ typedef System::Collections::Generic::List<
         // Kept object deletion code
         void Cleanup();
 
-        bool objIsMap (System::Object ^ op)
-        { 
-            return (*op).GetType() == pVMapType;
-        }
-
-        bool objIsList(System::Object ^ op)
-        { 
-            return (*op).GetType() == pVListType;
-        }
-
-        // The given object is a Dictionary.
-        // Add its elements to the qpid map.
-        void Encode(::qpid::types::Variant::Map & theMapp,
-                    VMap ^ theObjp);
-
-        // The given object is a List.
-        // Add its elements to the qpid list.
-        void Encode(::qpid::types::Variant::List & theListp,
-                    VList ^ theObjp);
-
-        // Returns a variant representing simple native type object.
-        // Not to be called for Map/List objects.
-        void EncodeObject(System::Object ^ theObjp,
-                          ::qpid::types::Variant & targetp);
-
-
-        void Decode(VMap ^ dict, ::qpid::types::Variant::Map & map);
-
-        void Decode(VList ^ vList, ::qpid::types::Variant::List & qpidList);
-
-
-        // map and list for type comparison
-        VMap  aVMap;
-        VList aVList;
-        System::Type ^ pVMapType;
-        System::Type ^ pVListType;
-
     public:
+        // Create empty message
+        Message();
+
         // Create from String
-        Message(System::String ^ bytes);
+        Message(System::String ^ string);
 
         // Create from object
         Message(System::Object ^ obj);
 
-        // Create reference copy
+        // TODO: Create from bytes
+        // Message(System::Byte [] ^ bytes);
+
+        // Create from received message
         Message(::qpid::messaging::Message * msgp);
 
         ~Message();
@@ -107,8 +70,8 @@ typedef System::Collections::Generic::List<
         // The kept object in the Messaging C++ DLL
         ::qpid::messaging::Message * messagep;
 
-        //void setReplyTo(System::String ^ address);
-        //System::String ^ getReplyTo();
+        void setReplyTo(Address ^ address);
+        Address ^ getReplyTo();
 
         void setSubject(System::String ^ subject);
         System::String ^ getSubject();
@@ -128,8 +91,8 @@ typedef System::Collections::Generic::List<
         void setPriority(unsigned char priority);
         unsigned char getPriority();
 
-        //void setTtl(Duration ttl);
-        //Duration getTtl();
+        void setTtl(Duration ^ ttl);
+        Duration ^ getTtl();
 
         void setDurable(bool durable);
         bool getDurable();
@@ -137,17 +100,32 @@ typedef System::Collections::Generic::List<
         bool getRedelivered();
         void setRedelivered(bool redelivered);
 
-        //System::String ^ getProperties();
+        System::Collections::Generic::Dictionary<
+            System::String^, System::Object^> ^ getProperties();
 
         void setContent(System::String ^ content);
 
+        //TODO:: void setContent(Bytes{} bytes, offset, length);
+
+        // get content as string
         System::String ^ getContent();
 
+        // get content as dictionary
         void getContent(System::Collections::Generic::Dictionary<
                             System::String^, 
                             System::Object^> ^ dict);
 
+        // get content as map
         void getContent(System::Collections::Generic::List<
                             System::Object^> ^);
+
+        // get content as bytes
+        void getRaw(cli::array<System::Byte> ^ arr);
+
+        System::UInt64 getContentSize();
+
+        //TODO: EncodingException
+
+        // Note: encode/decode functions are in TypeTranslator
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
new file mode 100644
index 0000000..eecc545
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
@@ -0,0 +1,38 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+#pragma once
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+using namespace System;
+
+public ref class QpidException : System::Exception
+{
+ public:
+
+ QpidException() : System::Exception() {}
+ QpidException(String^ estring) : System::Exception(estring) {}
+
+};
+
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
index 7667db8..7b52346 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
@@ -37,6 +37,7 @@ public:
 
     /// <summary>
     /// Convert managed String into native UTF8-encoded string
+    /// TODO: figure out some encoding other that UTF-8
     /// </summary>
 
     static std::string ToNative (System::String^ managed) 
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
new file mode 100644
index 0000000..2e87c3e
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
@@ -0,0 +1,75 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+#pragma once
+
+#include <windows.h>
+#include <msclr\lock.h>
+#include <oletx2xa.h>
+#include <string>
+#include <limits>
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+    /// <summary>
+    /// QpidTypeCheck determines if a given managed object represents
+    /// a qpid type per the scheme presented by the messaging DLL.
+    ///
+    // The supported mapping is:
+    /// * a managed Dictionary and a Qpid Messaging Map
+    /// * a managed List       and a Qpid Messaging List
+    /// </summary>
+
+    typedef System::Collections::Generic::Dictionary<
+                System::String^, 
+                System::Object^> 
+                    QpidMap;
+
+    typedef System::Collections::Generic::List<
+                System::Object^> 
+                    QpidList;
+
+    private ref class QpidTypeCheckConstants
+    {
+    public:
+        static System::Type const ^ const mapTypeP = System::Type::GetType(
+            "System.Collections.Generic.Dictionary`2[System.String,System.Object]");
+        static System::Type const ^ const listTypeP = System::Type::GetType(
+            "System.Collections.Generic.List`1[System.Object]");
+    };
+
+
+    public ref class QpidTypeCheck
+    {
+
+    public:
+
+        static bool ObjectIsMap (System::Object ^ object)
+        { 
+            return (*object).GetType() == QpidTypeCheckConstants::mapTypeP;
+        }
+
+        static bool ObjectIsList(System::Object ^ object)
+        { 
+            return (*object).GetType() == QpidTypeCheckConstants::listTypeP;
+        }
+    };
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
index 3902ea7..d647315 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
@@ -26,11 +26,13 @@
 #include "qpid/messaging/Receiver.h"
 #include "qpid/messaging/Session.h"
 #include "qpid/messaging/Message.h"
+#include "qpid/messaging/exceptions.h"
 
 #include "Receiver.h"
 #include "Session.h"
 #include "Message.h"
 #include "Duration.h"
+#include "QpidException.h"
 
 namespace org {
 namespace apache {
@@ -82,56 +84,163 @@ namespace messaging {
         }
     }
 
+    //
+    // get(message)
+    //
     bool Receiver::get(Message ^ mmsgp)
     {
-        return receiverp->Receiver::get(*((*mmsgp).messagep));
+        return get(mmsgp, DurationConstants::FORVER);
     }
 
     bool Receiver::get(Message ^ mmsgp, Duration ^ durationp)
     {
-        return receiverp->Receiver::get(*((*mmsgp).messagep),
-                                        *((*durationp).durationp));
+        ::qpid::messaging::Duration dur((*durationp).Milliseconds);
+
+        return receiverp->Receiver::get(*(mmsgp->messagep), dur);
     }
 
+    //
+    // message = get()
+    //
+    Message ^ Receiver::get()
+    {
+        return get(DurationConstants::FORVER);
+    }
+
+
     Message ^ Receiver::get(Duration ^ durationp)
     {
-        // allocate a message
-        ::qpid::messaging::Message * msgp = new ::qpid::messaging::Message;
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Message * msgp         = NULL;
+        Message                    ^ newMessage   = nullptr;
 
-        // get the message
-        *msgp = receiverp->::qpid::messaging::Receiver::get(*((*durationp).durationp));
+        try
+        {
+            // allocate a message
+            msgp = new ::qpid::messaging::Message;
+
+            // translate the duration
+            ::qpid::messaging::Duration dur((*durationp).Milliseconds);
 
-        // create new managed message with received message embedded in it
-        Message ^ newMessage = gcnew Message(msgp);
+            // get the message
+            *msgp = receiverp->::qpid::messaging::Receiver::get(dur);
+
+            // create new managed message with received message embedded in it
+            newMessage = gcnew Message(msgp);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Receiver:get unknown error");
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (msgp != NULL)
+                {
+                    delete msgp;
+                }
+
+                throw newException;
+            }
+        }
 
         return newMessage;
     }
 
+    //
+    // fetch(message)
+    //
     bool Receiver::fetch(Message ^ mmsgp)
     {
-        return receiverp->::qpid::messaging::Receiver::fetch(*((*mmsgp).messagep));
+        return fetch(mmsgp, DurationConstants::FORVER);
     }
 
     bool Receiver::fetch(Message ^ mmsgp, Duration ^ durationp)
     {
-        return receiverp->::qpid::messaging::Receiver::fetch(*((*mmsgp).messagep),
-                                          *((*durationp).durationp));
+        ::qpid::messaging::Duration dur((*durationp).Milliseconds);
+
+        return receiverp->::qpid::messaging::Receiver::fetch(*((*mmsgp).messagep), dur);
     }
     
+
+    //
+    // message = fetch()
+    //
+
+    Message ^ Receiver::fetch()
+    {
+        return fetch(DurationConstants::FORVER);
+    }
+
     Message ^ Receiver::fetch(Duration ^ durationp)
     {
-        // allocate a message
-        ::qpid::messaging::Message * msgp = new ::qpid::messaging::Message;
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Message * msgp         = NULL;
+         Message                   ^ newMessage   = nullptr;
+
+        try
+        {
+            // allocate a message
+            ::qpid::messaging::Message * msgp = new ::qpid::messaging::Message;
+
+            // translate the duration
+            ::qpid::messaging::Duration dur((*durationp).Milliseconds);
+
+            // get the message
+            *msgp = receiverp->::qpid::messaging::Receiver::fetch(dur);
+
+            // create new managed message with received message embedded in it
+            newMessage = gcnew Message(msgp);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Receiver:fetch unknown error");
 
-        // get the message
-        *msgp = receiverp->::qpid::messaging::Receiver::fetch(*((*durationp).durationp));
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (msgp != NULL)
+                {
+                    delete msgp;
+                }
 
-        // create new managed message with received message embedded in it
-        Message ^ newMessage = gcnew Message(msgp);
+                throw newException;
+            }
+        }
 
         return newMessage;
     }
 
+    void Receiver::setCapacity(System::UInt32 capacity)
+    {
+        receiverp->setCapacity(capacity);
+    }
+
     System::UInt32 Receiver::getCapacity()
     {
         return receiverp->getCapacity();
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
index ef2cf1a..26d0402 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
@@ -51,33 +51,39 @@ namespace messaging {
     public ref class Receiver
     {
     private:
-        // The kept object in the Messaging C++ DLL
-        ::qpid::messaging::Receiver * receiverp;
-
         // The session that created this Receiver
         Session ^ parentSession;
 
-        // Kept object lifetime flag
-        bool disposed;
-
         // Kept object deletion code
         void Cleanup();
 
     public:
+        // The kept object in the Messaging C++ DLL
+        ::qpid::messaging::Receiver * receiverp;
+
         Receiver(::qpid::messaging::Receiver * r,
             Session ^ sessRef);
         ~Receiver();
         !Receiver();
         Receiver(const Receiver ^ rhs);
 
+        // get(message)
         bool get(Message ^ mmsgp);
         bool get(Message ^ mmsgp, Duration ^ durationp);
+
+        // message = get()
+        Message ^ get();
         Message ^ get(Duration ^ durationp);
 
+        // fetch(message)
         bool fetch(Message ^ mmsgp);
-        bool fetch(Message ^ mmsgp, Duration ^ durationp);
+        bool fetch(Message ^ mmsgp, Duration ^ duration);
+
+        // message = fetch()
+        Message ^ fetch();
         Message ^ fetch(Duration ^ durationp);
 
+        void setCapacity(System::UInt32 capacity);
         System::UInt32 getCapacity();
         System::UInt32 getAvailable();
         System::UInt32 getUnsettled();
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
index 0550995..1708359 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
@@ -28,7 +28,6 @@
 #include "qpid/messaging/Message.h"
 
 #include "Sender.h"
-#include "Session.h"
 #include "Message.h"
 
 namespace org {
@@ -79,9 +78,12 @@ namespace messaging {
         }
     }
 
+    //
+    // send(msg)
+    //
     void Sender::send(Message ^ mmsgp)
     {
-        senderp->::qpid::messaging::Sender::send(*((*mmsgp).messagep));
+        send(mmsgp, false);
     }
 
     void Sender::send(Message ^ mmsgp, bool sync)
@@ -89,29 +91,10 @@ namespace messaging {
         senderp->::qpid::messaging::Sender::send(*((*mmsgp).messagep), sync);
     }
 
-    void Sender::setCapacity(System::UInt32 capacity)
-    {
-        senderp->setCapacity(capacity);
-    }
-
-    System::UInt32 Sender::getCapacity()
-    {
-        return senderp->getCapacity();
-    }
-
-    System::UInt32 Sender::getUnsettled()
-    {
-        return senderp->getUnsettled();
-    }
-
-    System::UInt32 Sender::getAvailable()
-    {
-        return senderp->getAvailable();
-    }
 
-    System::String ^ Sender::getName()
+    void Sender::close()
     {
-        return gcnew System::String(senderp->getName().c_str());
+        senderp->close();
     }
 
     Session ^ Sender::getSession()
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
index 482d434..17f7e82 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
@@ -65,13 +65,36 @@ namespace messaging {
         !Sender();
         Sender(const Sender % rhs);
 
+        // send(message)
         void send(Message ^ mmsgp);
         void send(Message ^ mmsgp, bool sync);
-        void setCapacity(System::UInt32 capacity);
-        System::UInt32 getCapacity();
-        System::UInt32 getUnsettled();
-        System::UInt32 getAvailable();
-        System::String ^ getName();
+
+        void close();
+
+        property System::UInt32 Capacity
+        {
+            System::UInt32 get () { return senderp->getCapacity(); }
+            void set (System::UInt32 capacity) { senderp->setCapacity(capacity); }
+        }
+
+        property System::UInt32 Unsettled
+        {
+            System::UInt32 get () { return senderp->getUnsettled(); }
+        }
+
+        property System::UInt32 Available
+        {
+            System::UInt32 get () { return senderp->getAvailable(); }
+        }
+
+        property System::String ^ Name
+        {
+            System::String ^ get ()
+            {
+                return gcnew System::String(senderp->getName().c_str());
+            }
+        }
+
         Session ^ getSession();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
index 04db529..c070f10 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
@@ -24,6 +24,7 @@
 #include <limits>
 
 #include "qpid/messaging/Session.h"
+#include "qpid/messaging/exceptions.h"
 
 #include "QpidMarshal.h"
 #include "Session.h"
@@ -31,6 +32,8 @@
 #include "Duration.h"
 #include "Receiver.h"
 #include "Sender.h"
+#include "Message.h"
+#include "QpidException.h"
 
 namespace org {
 namespace apache {
@@ -65,7 +68,7 @@ namespace messaging {
     // copy constructor
     Session::Session(const Session % rhs)
     {
-        sessionp          = rhs.sessionp;
+        sessionp = rhs.sessionp;
         parentConnectionp = rhs.parentConnectionp;
     }
 
@@ -98,7 +101,7 @@ namespace messaging {
 
     void Session::acknowledge()
     {
-        sessionp->acknowledge();
+        acknowledge(false);
     }
 
     void Session::acknowledge(bool sync)
@@ -106,9 +109,19 @@ namespace messaging {
         sessionp->acknowledge(sync);
     }
 
+    void Session::reject(Message ^ message)
+    {
+        sessionp->::qpid::messaging::Session::reject(*(message->messagep));
+    }
+
+    void Session::release(Message ^ message)
+    {
+        sessionp->::qpid::messaging::Session::release(*(message->messagep));
+    }
+
     void Session::sync()
     {
-        sessionp->sync();
+        sync(true);
     }
 
     void Session::sync(bool block)
@@ -116,67 +129,291 @@ namespace messaging {
         sessionp->sync(block);
     }
 
-    System::UInt32 Session::getReceivable()
+    // next(receiver)
+    bool Session::nextReceiver(Receiver ^ rcvr)
     {
-        return sessionp->getReceivable();
+        return nextReceiver(rcvr, DurationConstants::FORVER);
     }
 
-    System::UInt32 Session::getUnsettledAcks()
+    bool Session::nextReceiver(Receiver ^ rcvr, Duration ^ timeout)
     {
-        return sessionp->getUnsettledAcks();
+        System::Exception           ^ newException = nullptr;
+
+        try
+        {
+            ::qpid::messaging::Duration dur(timeout->Milliseconds);
+
+            return sessionp->nextReceiver(*(rcvr->receiverp), dur);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            if (errmsg = "No message to fetch")
+            {
+                // on timeout return null
+                return false;
+            }
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Session::nextReceiver unknown error");
+
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+
+                throw newException;
+            }
+        }
+        return true;
     }
 
-    //bool Session::nextReceiver(Receiver)
-    //{
-    //    sessionp->nextReceiver(Receiver)
-    //}
+    // receiver = next()
+    Receiver ^ Session::nextReceiver()
+    {
+        return nextReceiver(DurationConstants::FORVER);
+    }
 
-    //bool Session::nextReceiver(Receiver, Duration timeout)
-    //{
-    //    sessionp->nextReceiver();
-    //}
+    Receiver ^ Session::nextReceiver(Duration ^ timeout)
+    {
+        System::Exception           ^ newException = nullptr;
 
-    //Receiver Session::nextReceiver(Duration timeout)
-    //{
-    //}
+        try
+        {
+            ::qpid::messaging::Duration dur(timeout->Milliseconds);
+            ::qpid::messaging::Receiver * rcvr = new ::qpid::messaging::Receiver;
+
+            *rcvr = sessionp->::qpid::messaging::Session::nextReceiver(dur);
+
+            Receiver ^ newRcvr = gcnew Receiver(rcvr, this);
+
+            return newRcvr;
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            if (errmsg = "No message to fetch")
+            {
+                // on timeout return null
+                return nullptr;
+            }
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Session::nextReceiver unknown error");
+
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+
+                throw newException;
+            }
+        }
+        return nullptr;
+    }
 
 
     Sender ^ Session::createSender  (System::String ^ address)
     {
-        // allocate a native sender
-        ::qpid::messaging::Sender * senderp = new ::qpid::messaging::Sender;
+        System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Sender  * senderp         = NULL;
+        Sender                     ^ newSender       = nullptr;
+
+        try
+        {
+            // allocate a native sender
+            ::qpid::messaging::Sender * senderp = new ::qpid::messaging::Sender ;
 
-        // create the sender
-        *senderp = sessionp->::qpid::messaging::Session::createSender(QpidMarshal::ToNative(address));
+            // create the sender
+            *senderp = sessionp->::qpid::messaging::Session::createSender(QpidMarshal::ToNative(address));
 
-        // create a managed sender
-        Sender ^ newSender = gcnew Sender(senderp, this);
+            // create a managed sender
+            newSender = gcnew Sender(senderp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Session::createSender unknown error");
+
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (senderp != NULL)
+                {
+                    delete senderp;
+                }
+
+                throw newException;
+            }
+        }
 
         return newSender;
     }
 
     Receiver ^ Session::createReceiver(System::String ^ address)
     {
-        // allocate a native receiver
-        ::qpid::messaging::Receiver * receiverp = new ::qpid::messaging::Receiver;
+        System::Exception           ^ newException = nullptr;
+        ::qpid::messaging::Receiver * receiverp    = NULL;
+        Receiver                    ^ newReceiver  = nullptr;
+
+        try
+        {
+            // allocate a native receiver
+            receiverp = new ::qpid::messaging::Receiver;
+
+            // create the receiver
+            *receiverp = sessionp->createReceiver(QpidMarshal::ToNative(address));
+
+            // create a managed receiver
+            newReceiver = gcnew Receiver(receiverp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Session::createReceiver unknown error");
+
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+
+                throw newException;
+            }
+        }
+
+        return newReceiver;
+    }
+
+
+    Receiver ^ Session::createReceiver()
+    {
+        System::Exception           ^ newException = nullptr;
+        ::qpid::messaging::Receiver * receiverp    = NULL;
+        Receiver                    ^ newReceiver  = nullptr;
 
-        // create the receiver
-        *receiverp = sessionp->createReceiver(QpidMarshal::ToNative(address));
+        try
+        {
+            // allocate a native receiver
+            receiverp = new ::qpid::messaging::Receiver;
 
-        // create a managed receiver
-        Receiver ^ newReceiver = gcnew Receiver(receiverp, this);
+            // create a managed receiver
+            newReceiver = gcnew Receiver(receiverp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        catch (const std::exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        } 
+        catch ( ... )
+        {
+            newException = gcnew QpidException("Session::createReceiver unknown error");
+
+        }
+        finally
+        {
+            // Clean up and throw on caught exceptions
+            if (newException != nullptr)
+            {
+                if (sessionp != NULL)
+                {
+                    delete sessionp;
+                }
+
+                throw newException;
+            }
+        }
 
         return newReceiver;
     }
 
-    Connection ^ Session::getConnection()
+
+    Sender ^ Session::getSender(System::String ^ name)
     {
-        return parentConnectionp;
+        ::qpid::messaging::Sender * sender = new ::qpid::messaging::Sender;
+
+        *sender = sessionp->::qpid::messaging::Session::getSender(QpidMarshal::ToNative(name));
+
+        Sender ^ newSender = gcnew Sender(sender, this);
+
+        return newSender;
+    }
+
+
+
+    Receiver ^ Session::getReceiver(System::String ^ name)
+    {
+        ::qpid::messaging::Receiver * receiver = new ::qpid::messaging::Receiver;
+
+        *receiver = sessionp->::qpid::messaging::Session::getReceiver(QpidMarshal::ToNative(name));
+
+        Receiver ^ newReceiver = gcnew Receiver(receiver, this);
+
+        return newReceiver;
     }
 
-    bool Session::hasError()
+
+
+    Connection ^ Session::getConnection()
     {
-        return sessionp->hasError();
+        return parentConnectionp;
     }
 
     void Session::checkError()
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.h b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
index 3d1230e..3212f05 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
@@ -49,6 +49,7 @@ namespace messaging {
     ref class Duration;
     ref class Receiver;
     ref class Sender;
+    ref class Message;
 
     public ref class Session
     {
@@ -74,20 +75,44 @@ namespace messaging {
         void rollback();
         void acknowledge();
         void acknowledge(bool sync);
-        //void reject(Message);
-        //void release(Message);
+        void reject(Message ^);
+        void release(Message ^);
         void sync();
         void sync(bool block);
-        System::UInt32 getReceivable();
-        System::UInt32 getUnsettledAcks();
-        //bool nextReceiver(Receiver);
-        //bool nextReceiver(Receiver, Duration timeout);
-        //Receiver nextReceiver(Duration timeout);
-        //bool nextReceiver()
-        Sender     ^ createSender  (System::String ^ address);
-        Receiver   ^ createReceiver(System::String ^ address);
+
+        property System::UInt32 Receivable
+        {
+            System::UInt32 get () { return sessionp->getReceivable(); }
+        }
+
+        property System::UInt32 UnsetledAcks
+        {
+            System::UInt32 get () { return sessionp->getUnsettledAcks(); }
+        }
+
+        // next(receiver)
+        bool nextReceiver(Receiver ^);
+        bool nextReceiver(Receiver ^, Duration ^ timeout);
+
+        // receiver = next()
+        Receiver ^ nextReceiver();
+        Receiver ^ nextReceiver(Duration ^ timeout);
+
+
+        Sender   ^ createSender  (System::String ^ address);
+        Receiver ^ createReceiver(System::String ^ address);
+        Receiver ^ createReceiver();
+
+        Sender   ^ getSender(System::String ^ name);
+        Receiver ^ getReceiver(System::String ^ name);
+
         Connection ^ getConnection();
-        bool hasError();
+
+        property System::Boolean HasError
+        {
+            System::Boolean get () { return sessionp->hasError(); }
+        }
+
         void checkError();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
new file mode 100644
index 0000000..3fbe1e2
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
@@ -0,0 +1,411 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+#include <windows.h>
+#include <msclr\lock.h>
+#include <oletx2xa.h>
+#include <typeinfo.h>
+#include <string>
+#include <limits>
+#include <iostream>
+
+#include "TypeTranslator.h"
+#include "QpidTypeCheck.h"
+#include "QpidMarshal.h"
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+    /// <summary>
+    /// Translate between managed and native types.
+    /// </summary>
+
+    //
+    // The given object is a Dictionary.
+    // Add its elements to the qpid map.
+    //
+    void TypeTranslator::ManagedToNative(::qpid::types::Variant::Map & theMapp,
+                         QpidMap ^ theObjp)
+    {
+        // iterate the items, converting each to a variant and adding to the map
+        for each (System::Collections::Generic::KeyValuePair<System::String^, System::Object^> kvp in theObjp)
+        {
+            if (QpidTypeCheck::ObjectIsMap(kvp.Value))
+            {
+                // Recurse on inner map
+                // Allocate a map
+                ::qpid::types::Variant::Map newMap;
+
+                // Add the map variables to the map
+                ManagedToNative(newMap, (QpidMap ^)kvp.Value);
+
+                // Create a variant entry for the inner map
+                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
+
+                // Get map's name
+                std::string entryName = QpidMarshal::ToNative(kvp.Key);
+
+                // Add inner map to outer map
+                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, *newVariantp));
+            }
+            else if (QpidTypeCheck::ObjectIsList(kvp.Value))
+            {
+                // Recurse on inner list
+                // Allocate a list
+                ::qpid::types::Variant::List newList;
+
+                // Add the List variables to the list
+                ManagedToNative(newList, (QpidList ^)kvp.Value);
+
+                // Create a variant entry for the inner map
+                ::qpid::types::Variant::List newVariant(newList);
+
+                //std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newList));
+
+                // Get list's name
+                std::string entryName = QpidMarshal::ToNative(kvp.Key);
+
+                // Add inner list to outer map
+                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, newVariant));
+            }
+            else
+            {
+                // Add a simple native type to map
+                ::qpid::types::Variant entryValue;
+                ManagedToNativeObject(kvp.Value, entryValue);
+                std::string entryName = QpidMarshal::ToNative(kvp.Key);
+                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, entryValue));
+            }
+        }
+    }
+
+
+
+    //
+    // The given object is a List.
+    // Add its elements to the qpid list.
+    //
+    void TypeTranslator::ManagedToNative(::qpid::types::Variant::List & theListp,
+                         QpidList ^ theObjp)
+    {
+        // iterate the items, converting each to a variant and adding to the map
+        for each (System::Object ^ listObj in theObjp)
+        {
+            if (QpidTypeCheck::ObjectIsMap(listObj))
+            {
+                // Recurse on inner map
+                // Allocate a map
+                ::qpid::types::Variant::Map newMap;
+
+                // Add the map variables to the map
+                ManagedToNative(newMap, (QpidMap ^)listObj);
+
+                // Create a variant entry for the inner map
+                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
+
+                // Add inner map to outer list
+                theListp.push_back(*newVariantp);
+            }
+            else if (QpidTypeCheck::ObjectIsList(listObj))
+            {
+                // Recurse on inner list
+                // Allocate a list
+                ::qpid::types::Variant::List newList;
+
+                // Add the List variables to the list
+                ManagedToNative(newList, (QpidList ^)listObj);
+
+                // Create a variant entry for the inner list
+                std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newList));
+
+                // Add inner list to outer list
+                theListp.push_back(*newVariantp);
+            }
+            else
+            {
+                // Add a simple native type to list
+                ::qpid::types::Variant entryValue;
+                ManagedToNativeObject(listObj, entryValue);
+                theListp.push_back(entryValue);
+            }
+        }
+    }
+
+
+
+    //
+    // Returns a variant representing simple native type object.
+    // Not to be called for Map/List objects.
+    //
+    void TypeTranslator::ManagedToNativeObject(System::Object ^ theObjp, 
+                               ::qpid::types::Variant & targetp)
+    {
+        System::Type     ^ typeP    = (*theObjp).GetType();
+        System::TypeCode   typeCode = System::Type::GetTypeCode( typeP );
+
+        switch (typeCode)
+        {
+        case System::TypeCode::Boolean :
+            targetp = System::Convert::ToBoolean(theObjp);
+            break;
+
+        case System::TypeCode::Byte :
+            targetp = System::Convert::ToByte(theObjp);
+            break;
+
+        case System::TypeCode::UInt16 :
+            targetp = System::Convert::ToUInt16(theObjp);
+            break;
+
+        case System::TypeCode::UInt32 :
+            targetp = System::Convert::ToUInt32(theObjp);
+            break;
+
+        case System::TypeCode::UInt64 :
+            targetp = System::Convert::ToUInt64(theObjp);
+            break;
+
+        case System::TypeCode::Char :
+        case System::TypeCode::SByte :
+            targetp = System::Convert::ToSByte(theObjp);
+            break;
+
+        case System::TypeCode::Int16 :
+            targetp = System::Convert::ToInt16(theObjp);
+            break;
+
+        case System::TypeCode::Int32 :
+            targetp = System::Convert::ToInt32(theObjp);
+            break;
+
+        case System::TypeCode::Int64 :
+            targetp = System::Convert::ToInt64(theObjp);
+            break;
+
+        case System::TypeCode::Single :
+            targetp = System::Convert::ToSingle(theObjp);
+            break;
+
+        case System::TypeCode::Double :
+            targetp = System::Convert::ToDouble(theObjp);
+            break;
+
+        case System::TypeCode::String :
+            {
+                std::string      rString;
+                System::String ^ rpString;
+
+                rpString = System::Convert::ToString(theObjp);
+                rString = QpidMarshal::ToNative(rpString);
+                targetp = rString;
+                targetp.setEncoding(QpidMarshal::ToNative("utf8"));
+            }
+            break;
+
+            
+        default:
+
+            throw gcnew System::NotImplementedException();
+
+        }
+    }
+
+
+    // Given a user Dictionary and a qpid map,
+    //   extract the qpid elements and put them into the dictionary.
+    //
+    void TypeTranslator::NativeToManaged(QpidMap ^ dict, ::qpid::types::Variant::Map & map)
+    {
+        // For each object in the message map, 
+        //  create a .NET object and add it to the dictionary.
+        for (::qpid::types::Variant::Map::const_iterator i = map.begin(); i != map.end(); ++i) {
+            // Get the name
+            System::String ^ elementName = gcnew String(i->first.c_str());
+
+            ::qpid::types::Variant     variant = i->second;
+            ::qpid::types::VariantType vType   = variant.getType();
+
+            switch (vType)
+            {
+            case ::qpid::types::VAR_BOOL:
+                dict[elementName] = variant.asBool();
+                break;
+                
+            case ::qpid::types::VAR_UINT8:
+                dict[elementName] = variant.asUint8();
+                break;
+                
+            case ::qpid::types::VAR_UINT16:
+                dict[elementName] = variant.asUint16();
+                break;
+                
+            case ::qpid::types::VAR_UINT32:
+                dict[elementName] = variant.asUint32();
+                break;
+                
+            case ::qpid::types::VAR_UINT64:
+                dict[elementName] = variant.asUint64();
+                break;
+                
+            case ::qpid::types::VAR_INT8:
+                dict[elementName] = variant.asInt8();
+                break;
+                
+            case ::qpid::types::VAR_INT16:
+                dict[elementName] = variant.asInt16();
+                break;
+                
+            case ::qpid::types::VAR_INT32:
+                dict[elementName] = variant.asInt32();
+                break;
+                
+            case ::qpid::types::VAR_INT64:
+                dict[elementName] = variant.asInt64();
+                break;
+                
+            case ::qpid::types::VAR_FLOAT:
+                dict[elementName] = variant.asFloat();
+                break;
+                
+            case ::qpid::types::VAR_DOUBLE:
+                dict[elementName] = variant.asDouble();
+                break;
+                
+            case ::qpid::types::VAR_STRING:
+                {
+                    System::String ^ elementValue = gcnew System::String(variant.asString().c_str());
+                    dict[elementName] = elementValue;
+                    break;
+                }
+            case ::qpid::types::VAR_MAP:
+                {
+                    QpidMap ^ newDict = gcnew QpidMap();
+
+                    NativeToManaged(newDict, variant.asMap());
+
+                    dict[elementName] = newDict;
+                    break;
+                }
+
+            case ::qpid::types::VAR_LIST:
+                {
+                    QpidList ^ newList = gcnew QpidList();
+
+                    NativeToManaged(newList, variant.asList());
+
+                    dict[elementName] = newList;
+                    break;
+                }
+                
+            case ::qpid::types::VAR_UUID:
+                break;
+            }
+        }
+    }
+
+
+    void TypeTranslator::NativeToManaged(QpidList ^ vList, ::qpid::types::Variant::List & qpidList)
+    {
+        // For each object in the message map, 
+        //  create a .NET object and add it to the dictionary.
+        for (::qpid::types::Variant::List::const_iterator i = qpidList.begin(); i != qpidList.end(); ++i) 
+        {
+            ::qpid::types::Variant     variant = *i;
+            ::qpid::types::VariantType vType   = variant.getType();
+
+            switch (vType)
+            {
+            case ::qpid::types::VAR_BOOL:
+                (*vList).Add(variant.asBool());
+                break;
+                
+            case ::qpid::types::VAR_UINT8:
+                (*vList).Add(variant.asUint8());
+                break;
+                
+            case ::qpid::types::VAR_UINT16:
+                (*vList).Add(variant.asUint16());
+                break;
+                
+            case ::qpid::types::VAR_UINT32:
+                (*vList).Add(variant.asUint32());
+                break;
+                
+            case ::qpid::types::VAR_UINT64:
+                (*vList).Add(variant.asUint64());
+                break;
+                
+            case ::qpid::types::VAR_INT8:
+                (*vList).Add(variant.asInt8());
+                break;
+                
+            case ::qpid::types::VAR_INT16:
+                (*vList).Add(variant.asInt16());
+                break;
+                
+            case ::qpid::types::VAR_INT32:
+                (*vList).Add(variant.asInt32());
+                break;
+                
+            case ::qpid::types::VAR_INT64:
+                (*vList).Add(variant.asInt64());
+                break;
+                
+            case ::qpid::types::VAR_FLOAT:
+                (*vList).Add(variant.asFloat());
+                break;
+                
+            case ::qpid::types::VAR_DOUBLE:
+                (*vList).Add(variant.asDouble());
+                break;
+                
+            case ::qpid::types::VAR_STRING:
+                {
+                    System::String ^ elementValue = gcnew System::String(variant.asString().c_str());
+                    (*vList).Add(elementValue);
+                    break;
+                }
+            case ::qpid::types::VAR_MAP:
+                {
+                    QpidMap ^ newDict = gcnew QpidMap();
+
+                    NativeToManaged(newDict, variant.asMap());
+
+                    (*vList).Add(newDict);
+                    break;
+                }
+
+            case ::qpid::types::VAR_LIST:
+                {
+                    QpidList ^ newList = gcnew QpidList();
+
+                    NativeToManaged(newList, variant.asList());
+
+                    (*vList).Add(newList);
+                    break;
+                }
+                
+            case ::qpid::types::VAR_UUID:
+                break;
+            }
+        }
+    }
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
new file mode 100644
index 0000000..7ffba69
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
@@ -0,0 +1,70 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+#pragma once
+
+#include <windows.h>
+#include <msclr\lock.h>
+#include <oletx2xa.h>
+#include <string>
+#include <limits>
+
+#include "qpid/types/Variant.h"
+
+#include "QpidTypeCheck.h"
+
+namespace org {
+namespace apache {
+namespace qpid {
+namespace messaging {
+
+    /// <summary>
+    /// TypeTranslator provides codec between .NET Dictionary/List and
+    /// qpid messaging Map/List.
+    /// </summary>
+
+    public ref class TypeTranslator
+    {
+
+    public:
+        // The given object is a Dictionary.
+        // Add its elements to the qpid map.
+        static void ManagedToNative(::qpid::types::Variant::Map & theMapp,
+                                    QpidMap ^ theObjp);
+
+        // The given object is a List.
+        // Add its elements to the qpid list.
+        static void ManagedToNative(::qpid::types::Variant::List & theListp,
+                                    QpidList ^ theObjp);
+
+        // The given object is a simple native type (not a Dictionary or List)
+        // Returns a variant representing simple native type object.
+        static void ManagedToNativeObject(System::Object ^ theObjp,
+                                          ::qpid::types::Variant & targetp);
+
+        // Given a Dictionary,
+        // Return its values in a Qpid map
+        static void NativeToManaged(QpidMap ^ dict, 
+                                    ::qpid::types::Variant::Map & map);
+
+        // Given a List,
+        // Return its values in a Qpid list
+        static void NativeToManaged(QpidList ^ vList, 
+                                    ::qpid::types::Variant::List & qpidList);
+    };
+}}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/app.rc b/qpid/cpp/bindings/qpid/dotnet/src/app.rc
index b3f0d67..8c1d640 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/app.rc
+++ b/qpid/cpp/bindings/qpid/dotnet/src/app.rc
@@ -20,6 +20,7 @@
 
 LANGUAGE 9, 1
 #pragma code_page(1252)
+1           ICON         "app.ico"
 
 #ifdef APSTUDIO_INVOKED
 /////////////////////////////////////////////////////////////////////////////
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
new file mode 100644
index 0000000..0e47bae
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
@@ -0,0 +1,101 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include "resource1.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.S.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE 
+BEGIN
+    "resource1.h\0"
+END
+
+2 TEXTINCLUDE 
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION 1,3,0,1
+ PRODUCTVERSION 1,3,0,1
+ FILEFLAGSMASK 0x17L
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x4L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "FileDescription", "org"
+            VALUE "FileVersion", "1, 3, 0, 1"
+            VALUE "InternalName", "org"
+            VALUE "LegalCopyright", "Copyright (C) 2010"
+            VALUE "OriginalFilename", "org.apache.qpid.messaging"
+            VALUE "ProductName", "org"
+            VALUE "ProductVersion", "1, 3, 0, 1"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
+
+#endif    // English (U.S.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
index e8e4bc6..3f5861b 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
+++ b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
@@ -44,7 +44,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions=" /Zm1000 /wd4244 /wd4800 /wd4355"
 				Optimization="0"
-				AdditionalIncludeDirectories="&quot;$(QPID_BUILD_ROOT)\include&quot;;&quot;$(QPID_BUILD_ROOT)\src&quot;"
+				AdditionalIncludeDirectories="&quot;$(ProjectDir)..\..\..\..\include&quot;;&quot;$(ProjectDir)..\..\..\..\src&quot;"
 				PreprocessorDefinitions="WIN32;_WINDOWS;_DEBUG;WIN32_LEAN_AND_MEAN"
 				RuntimeLibrary="3"
 				UsePrecompiledHeader="0"
@@ -63,12 +63,13 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalOptions=" /STACK:10000000 /machine:I386"
-				AdditionalDependencies="$(QPID_BUILD_ROOT)\src\Debug\qpidclientd.lib $(QPID_BUILD_ROOT)\src\Debug\qpidcommond.lib"
-				OutputFile="$(OutDir)\org.apache.qpid.messagingd.dll"
+				AdditionalDependencies="$(ProjectDir)..\..\..\..\src\Debug\qpidclientd.lib $(ProjectDir)..\..\..\..\src\Debug\qpidcommond.lib $(ProjectDir)..\..\..\..\src\Debug\qpidmessagingd.lib"
+				OutputFile="$(ProjectDir)..\..\..\..\src\$(ConfigurationName)\org.apache.qpid.messagingd.dll"
 				LinkIncremental="1"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				TargetMachine="1"
+				KeyFile="qpid.snk"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -90,6 +91,7 @@
 			/>
 			<Tool
 				Name="VCPostBuildEventTool"
+				CommandLine=""
 			/>
 		</Configuration>
 		<Configuration
@@ -188,15 +190,15 @@
 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
 			>
 			<File
-				RelativePath=".\AssemblyInfo.cpp"
+				RelativePath=".\Address.cpp"
 				>
 			</File>
 			<File
-				RelativePath=".\Connection.cpp"
+				RelativePath=".\AssemblyInfo.cpp"
 				>
 			</File>
 			<File
-				RelativePath=".\Duration.cpp"
+				RelativePath=".\Connection.cpp"
 				>
 			</File>
 			<File
@@ -215,6 +217,10 @@
 				RelativePath=".\Session.cpp"
 				>
 			</File>
+			<File
+				RelativePath=".\TypeTranslator.cpp"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="Header Files"
@@ -222,6 +228,10 @@
 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
 			>
 			<File
+				RelativePath=".\Address.h"
+				>
+			</File>
+			<File
 				RelativePath=".\Connection.h"
 				>
 			</File>
@@ -238,6 +248,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\QpidTypeCheck.h"
+				>
+			</File>
+			<File
 				RelativePath=".\Receiver.h"
 				>
 			</File>
@@ -249,6 +263,10 @@
 				RelativePath=".\Session.h"
 				>
 			</File>
+			<File
+				RelativePath=".\TypeTranslator.h"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="Resource Files"
@@ -260,11 +278,11 @@
 				>
 			</File>
 			<File
-				RelativePath=".\app.rc"
+				RelativePath=".\org.apache.qpid.messaging.rc"
 				>
 			</File>
 			<File
-				RelativePath=".\resource.h"
+				RelativePath=".\resource1.h"
 				>
 			</File>
 		</Filter>
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/qpid.snk b/qpid/cpp/bindings/qpid/dotnet/src/qpid.snk
new file mode 100644
index 0000000000000000000000000000000000000000..9faafd8f8bcde4666d3d04ada613d558b88a4d63
GIT binary patch
literal 596
zcmV-a0;~N80ssI2Bme+XQ$aES1ONa50096^^`MWdGN!jS0N0v=XF>)TkGMUKij(GS
zk^5v;aslfD5l|?AJY4W_&86)|iNjW?e}{VsyCg^+b#k@Mwd=v-|Ca#XRFnr%Cl9Zy
zi3=ARq^&{Mg!9!5XdbG}M2u-Z23fP!`H$eTl!XPh#l4`$jb=l+(RbibtMlpR99_9L
z6D}ZJ$!xE=BfqaoLw!Fb778;Wjz4Mrea^SXeONi}?eD?S9)$uYJ9h4=^vQb8EY~!+
z)NmrOXNYSyY~$OT#h%sdR@`i~oa$L%3(Pe7L{IBzMB4BRoe&78;s1oWzPXW8z?~>c
z9*#(+Omu#Pg!^x?3y_m+qdBTRGtSpNLg*Wlrp971+~IB_Q$S?kQs-jwrx5FV3=?fG
z#)Bkh?(sIlmM$7G5~Khu`>f~f5g-Q7YhfdUuanG2;V*{2wRGk|A9$V4PvA$%e`8z*
zM1P~@E2kG~!2w3eDaZ(hXr(atQd1gJeT&IYE{EucH|djR%cyV^nl++tuS$^(b$*pn
zicc-|z;+x~kkVOAogm*z>#GzS^-X8-Z518e=&J`=omRPfYNZilEz%dnAJB?^BEVhg
z?_!Z`TB<BPg16X-?AB|Qf!VsyvdOth`nnN#{5#`xV)X6dv;)wpkcX_Hgmx_?QEqY3
z=HuEnU@sT#mx8R($}5PzaA-n?iFS<9wHpGcv5qlSU-u%ibYB}1Hb1HA=a~V1a87oz
iqGF&hjKv=gHC_6=_UsQpKT_VY&^zh>YDMdbw`8bdEF>2I

literal 0
HcmV?d00001

diff --git a/qpid/cpp/bindings/qpid/dotnet/src/resource.h b/qpid/cpp/bindings/qpid/dotnet/src/resource.h
deleted file mode 100644
index e2f4735..0000000
--- a/qpid/cpp/bindings/qpid/dotnet/src/resource.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
-* Licensed to the Apache Software Foundation (ASF) under one
-* or more contributor license agreements.  See the NOTICE file
-* distributed with this work for additional information
-* regarding copyright ownership.  The ASF licenses this file
-* to you under the Apache License, Version 2.0 (the
-* "License"); you may not use this file except in compliance
-* with the License.  You may obtain a copy of the License at
-*
-*   http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the License is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-* KIND, either express or implied.  See the License for the
-* specific language governing permissions and limitations
-* under the License.
-*/
-
-//{{NO_DEPENDENCIES}}
-// Microsoft Visual C++ generated include file.
-// Used by app.rc
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/resource1.h b/qpid/cpp/bindings/qpid/dotnet/src/resource1.h
new file mode 100644
index 0000000..96a2cb7
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/resource1.h
@@ -0,0 +1,14 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by org.apache.qpid.messaging.rc
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        101
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1001
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..57f83ad
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
@@ -0,0 +1,55 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("org.apache.qpid.messaging.sessionreceiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("org.apache.qpid.messaging.sessionreceiver")]
+[assembly: AssemblyCopyright("Copyright   2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("e18f363a-a9b0-4251-8f3c-de0e9d9d6827")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
new file mode 100644
index 0000000..0021a15
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
@@ -0,0 +1,65 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.30729</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>org.apache.qpid.messaging.sessionreceiver</RootNamespace>
+    <AssemblyName>org.apache.qpid.messaging.sessionreceiver</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="sessionreceiver.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs
new file mode 100644
index 0000000..73956ec
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs
@@ -0,0 +1,133 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using org.apache.qpid.messaging;
+
+namespace org.apache.qpid.messaging.sessionreceiver
+{
+    /// <summary>
+    /// ISessionReceiver interface defines the callback for users to supply.
+    /// Once established this callback will receive all messages for all 
+    /// receivers defined by the current session.
+    /// Users are expected not to 'fetch' or 'get' messages by any other means.
+    /// Users must acknowledge() the Session's messages either in the callback
+    /// function or by some other scheme.
+    /// </summary>
+
+    public interface ISessionReceiver
+    {
+        void SessionReceiver(Receiver receiver, Message message);
+    }
+
+    
+    /// <summary>
+    /// eventEngine - wait for messages from the underlying C++ code.
+    /// When available get them and deliver them via callback to our 
+    /// client through the ISessionReceiver interface.
+    /// This class consumes the thread that calls the Run() function.
+    /// </summary>
+
+    internal class eventEngine
+    {
+        private Session          session;
+        private ISessionReceiver callback;
+        private bool             keepRunning;
+
+        public eventEngine(Session theSession, ISessionReceiver thecallback)
+        {
+            this.session  = theSession;
+            this.callback = thecallback;
+        }
+
+        /// <summary>
+        /// Function to call Session's nextReceiver, discover messages,
+        /// and to deliver messages through the callback.
+        /// </summary>
+        public void open()
+        {
+            Receiver rcvr = session.createReceiver();
+            Message  msg;
+
+            keepRunning = true;
+            while (keepRunning)
+            {
+                if (session.nextReceiver(rcvr, DurationConstants.SECOND))
+                {
+                    if (keepRunning)
+                    {
+                        msg = rcvr.fetch(DurationConstants.SECOND);
+                        this.callback.SessionReceiver(rcvr, msg);
+                    }
+                }
+                //else
+                //    receive timed out
+                //    eventEngine exits the nextReceiver() function periodically
+                //    in order to test the keepRunning flag
+            }
+            // Private thread is now exiting.
+        }
+
+        /// <summary>
+        /// Function to stop the eventEngine. Private thread will exit within
+        /// one second.
+        /// </summary>
+        public void close()
+        {
+            keepRunning = false;
+        }
+    }
+
+
+    /// <summary>
+    /// server is the class that users instantiate to connect a SessionReceiver
+    /// callback to the stream of received messages received on a Session.
+    /// </summary>
+    public class server
+    {
+        private eventEngine ee;
+
+        /// <summary>
+        /// Constructor for the server.
+        /// </summary>
+        /// <param name="session">The Session whose messages are collected.</param>
+        /// <param name="callback">The user function call with each message.</param>
+        /// 
+        public server(Session session, ISessionReceiver callback)
+        {
+            ee = new eventEngine(session, callback);
+
+            new System.Threading.Thread(
+                new System.Threading.ThreadStart(ee.open)).Start();
+        }
+
+        /// <summary>
+        /// Function to stop the server.
+        /// </summary>
+        public void close()
+        {
+            ee.close();
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
index 63a8548..5d16172 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
@@ -12,27 +12,77 @@ namespace org.apache.qpid.messaging
         {
             //
             // Duration test - stub until proper nunit tests are ready...
-            //
+
             Duration myDuration = new Duration(1234);
 
             Console.WriteLine("Duration should be : 1234, is : {0}",
-                            myDuration.getMilliseconds());
+                            myDuration.Milliseconds);
 
             Console.WriteLine("Duration FOREVER should be : 1.8x10^19 (realbig), is : {0}",
-                            myDuration.FOREVER());
+                            DurationConstants.FORVER.Milliseconds);
 
             Console.WriteLine("Duration IMMEDIATE should be : 0, is : {0}",
-                            myDuration.IMMEDIATE());
+                            DurationConstants.IMMEDIATE.Milliseconds);
 
             Console.WriteLine("Duration SECOND should be : 1,000, is : {0}",
-                            myDuration.SECOND());
+                            DurationConstants.SECOND.Milliseconds);
 
             Console.WriteLine("Duration MINUTE should be : 60,000, is : {0}",
-                            myDuration.MINUTE());
+                            DurationConstants.MINUTE.Milliseconds);
+
+            Duration isInfinite = new Duration();
 
+            Console.WriteLine("Duration() should be : realbig, is : {0}",
+                            isInfinite.Milliseconds);
+
+            Duration fiveMinutes = new Duration(DurationConstants.MINUTE.Milliseconds * 5);
+            Console.WriteLine("Duration 5MINUTE should be : 300,000, is : {0}",
+                            fiveMinutes.Milliseconds);
+
+            Duration fiveSec = DurationConstants.SECOND * 5;
+            Console.WriteLine("Duration 5SECOND should be : 5,000 is : {0}",
+                            fiveSec.Milliseconds);
             //
             // and so on
             //
+
+            Dictionary<string, object> dx = new Dictionary<string, object>();
+
+            Console.WriteLine("Dictionary.GetType() {0}", dx.GetType());
+
+            //
+            // Address test
+            //
+            Address aEmpty = new Address();
+            Address aStr   = new Address("rare");
+
+            Dictionary<string, object> options = new Dictionary<string,object>();
+            options["one"] = 1;
+            options["two"] = "two";
+
+            Address aSubj = new Address("rare2", "subj", options);
+
+            Address aType = new Address ("check3", "subj", options, "hot");
+
+            Console.WriteLine("aEmpty : {0}", aEmpty.str());
+            Console.WriteLine("aStr   : {0}", aStr.str());
+            Console.WriteLine("aSubj  : {0}", aSubj.str());
+            Console.WriteLine("aType  : {0}", aType.str());
+
+            //
+            // Raw message data retrieval
+            //
+
+            Message m2 = new Message("rarey");
+            UInt64 m2Size = m2.getContentSize();
+
+
+            byte[] myRaw = new byte [m2Size];
+
+            m2.getRaw(myRaw);
+            Console.WriteLine("Got raw array size {0}", m2Size);
+            for (UInt64 i = 0; i < m2Size; i++)
+                Console.Write("{0} ", myRaw[i].ToString());
         }
     }
 }
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
index 0c9d6af..08c0147 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
@@ -17,7 +17,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
@@ -31,10 +31,6 @@
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <ItemGroup>
-    <Reference Include="org.apache.qpid.messagingd, Version=1.0.3779.23054, Culture=neutral, PublicKeyToken=679e1f50b62dbace, processorArchitecture=x86">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\bin\Debug\org.apache.qpid.messagingd.dll</HintPath>
-    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
@@ -52,6 +48,12 @@
     <Compile Include="messaging.test.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>org.apache.qpid.messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
@@ -60,4 +62,10 @@
   <Target Name="AfterBuild">
   </Target>
   -->
+  <PropertyGroup>
+    <PostBuildEvent>
+    </PostBuildEvent>
+    <PreBuildEvent>
+    </PreBuildEvent>
+  </PropertyGroup>
 </Project>
-- 
1.7.1.1

From 9a0ba6962caad7e88d67d14b7464a95b24267b7b Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Thu, 3 Jun 2010 14:14:50 +0000
Subject: [PATCH 057/129] Bug 603805 - .NET bindings for the C++ Messaging API

QPID-2589 - Build DLLs and EXEs usable on both 32 and 64-bit architectures.
Patch from Chuck Rolke.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@951003 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 48ba23e0718fd809ef7a6b5b686c484a56c9d003)
---
 .../csharp.direct.receiver.csproj                  |   18 +++++++++-
 .../csharp.direct.sender.csproj                    |   18 +++++++++-
 .../csharp.map.callback.receiver.csproj            |   18 +++++++++-
 .../csharp.map.callback.sender.csproj              |   19 +++++++++-
 .../csharp.map.receiver/csharp.map.receiver.csproj |   18 +++++++++-
 .../csharp.map.sender/csharp.map.sender.csproj     |   18 +++++++++-
 .../qpid/dotnet/org.apache.qpid.messaging.sln      |   37 ++++++++++++++++++++
 .../dotnet/src/org.apache.qpid.messaging.vcproj    |   14 ++++----
 ...rg.apache.qpid.messaging.sessionreceiver.csproj |   18 +++++++++-
 .../test/messaging.test/messaging.test.csproj      |   18 +++++++++-
 10 files changed, 181 insertions(+), 15 deletions(-)

diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
index 7bfcfb8..96b4540 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
index 7ff92e1..4543222 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
index e8aae4b..24b5cd4 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
index 5089737..26f2c5b 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
@@ -26,11 +26,28 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
index 380e33b..06017fb 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
index 4482e6a..a3a2ac2 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
index 8b0b3fd..5cd4b1a 100644
--- a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
+++ b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
@@ -48,9 +48,11 @@ Global
 		Debug|Any CPU = Debug|Any CPU
 		Debug|Mixed Platforms = Debug|Mixed Platforms
 		Debug|Win32 = Debug|Win32
+		Debug|x86 = Debug|x86
 		Release|Any CPU = Release|Any CPU
 		Release|Mixed Platforms = Release|Mixed Platforms
 		Release|Win32 = Release|Win32
+		Release|x86 = Release|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|Any CPU.ActiveCfg = Debug|Win32
@@ -58,91 +60,126 @@ Global
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|Mixed Platforms.Build.0 = Debug|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|Win32.ActiveCfg = Debug|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|Win32.Build.0 = Debug|Win32
+		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|x86.ActiveCfg = Debug|Win32
+		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Debug|x86.Build.0 = Debug|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|Any CPU.ActiveCfg = Release|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|Mixed Platforms.ActiveCfg = Release|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|Mixed Platforms.Build.0 = Release|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|Win32.ActiveCfg = Release|Win32
 		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|Win32.Build.0 = Release|Win32
+		{AA5A3B83-5F98-406D-A01C-5A921467A57D}.Release|x86.ActiveCfg = Release|Win32
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|x86.ActiveCfg = Debug|x86
+		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Debug|x86.Build.0 = Debug|x86
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|Any CPU.Build.0 = Release|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|Win32.ActiveCfg = Release|Any CPU
+		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|x86.ActiveCfg = Release|x86
+		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}.Release|x86.Build.0 = Release|x86
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|x86.ActiveCfg = Debug|x86
+		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Debug|x86.Build.0 = Debug|x86
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|Any CPU.Build.0 = Release|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|Win32.ActiveCfg = Release|Any CPU
+		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|x86.ActiveCfg = Release|x86
+		{52F880E7-D677-4C91-8516-D679CE0F46A8}.Release|x86.Build.0 = Release|x86
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|x86.ActiveCfg = Debug|x86
+		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Debug|x86.Build.0 = Debug|x86
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|Any CPU.Build.0 = Release|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|Win32.ActiveCfg = Release|Any CPU
+		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|x86.ActiveCfg = Release|x86
+		{AF2FBC78-266C-430C-BC29-9477AB596A36}.Release|x86.Build.0 = Release|x86
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|x86.ActiveCfg = Debug|x86
+		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Debug|x86.Build.0 = Debug|x86
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|Any CPU.Build.0 = Release|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|Win32.ActiveCfg = Release|Any CPU
+		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|x86.ActiveCfg = Release|x86
+		{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}.Release|x86.Build.0 = Release|x86
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|x86.ActiveCfg = Debug|x86
+		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Debug|x86.Build.0 = Debug|x86
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Any CPU.Build.0 = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|Win32.ActiveCfg = Release|Any CPU
+		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|x86.ActiveCfg = Release|x86
+		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}.Release|x86.Build.0 = Release|x86
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|x86.ActiveCfg = Debug|x86
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Debug|x86.Build.0 = Debug|x86
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Any CPU.Build.0 = Release|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|Win32.ActiveCfg = Release|Any CPU
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|x86.ActiveCfg = Release|x86
+		{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}.Release|x86.Build.0 = Release|x86
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|x86.ActiveCfg = Debug|x86
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Debug|x86.Build.0 = Debug|x86
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Any CPU.Build.0 = Release|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|Win32.ActiveCfg = Release|Any CPU
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|x86.ActiveCfg = Release|x86
+		{68A43817-2358-4A31-8FDF-FE21722BFBCF}.Release|x86.Build.0 = Release|x86
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|Win32.ActiveCfg = Debug|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|x86.ActiveCfg = Debug|x86
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Debug|x86.Build.0 = Debug|x86
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Any CPU.Build.0 = Release|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Mixed Platforms.Build.0 = Release|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Win32.ActiveCfg = Release|Any CPU
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|x86.ActiveCfg = Release|x86
+		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|x86.Build.0 = Release|x86
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
index 3f5861b..7c31781 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
+++ b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
@@ -18,8 +18,8 @@
 	<Configurations>
 		<Configuration
 			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)\bin\$(ConfigurationName)"
-			IntermediateDirectory="$(SolutionDir)\obj\$(ConfigurationName)"
+			OutputDirectory="$(ProjectDir)\bin\$(ConfigurationName)"
+			IntermediateDirectory="$(ProjectDir)\obj\$(ConfigurationName)"
 			ConfigurationType="2"
 			CharacterSet="1"
 			ManagedExtensions="1"
@@ -96,8 +96,8 @@
 		</Configuration>
 		<Configuration
 			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)\bin\$(ConfigurationName)"
-			IntermediateDirectory="$(SolutionDir)\obj\$(ConfigurationName)"
+			OutputDirectory="$(ProjectDir)\bin\$(ConfigurationName)"
+			IntermediateDirectory="$(ProjectDir)\obj\$(ConfigurationName)"
 			ConfigurationType="2"
 			CharacterSet="1"
 			ManagedExtensions="1"
@@ -122,7 +122,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions=" /Zm1000 /wd4244 /wd4800 /wd4355"
 				Optimization="0"
-				AdditionalIncludeDirectories="&quot;$(QPID_BUILD_ROOT)\include&quot;;&quot;$(QPID_BUILD_ROOT)\src&quot;"
+				AdditionalIncludeDirectories="&quot;$(ProjectDir)..\..\..\..\include&quot;;&quot;$(ProjectDir)..\..\..\..\src&quot;"
 				PreprocessorDefinitions="WIN32;_WINDOWS;NDEBUG;WIN32_LEAN_AND_MEAN"
 				RuntimeLibrary="3"
 				UsePrecompiledHeader="0"
@@ -141,8 +141,8 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalOptions=" /STACK:10000000 /machine:I386"
-				AdditionalDependencies="$(QPID_BUILD_ROOT)\src\Release\qpidclient.lib $(QPID_BUILD_ROOT)\src\Release\qpidcommon.lib"
-				OutputFile="$(OutDir)\org.apache.qpid.messaging.dll"
+				AdditionalDependencies="$(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidclient.lib $(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidcommon.lib $(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidmessaging.lib"
+				OutputFile="$(ProjectDir)..\..\..\..\src\$(ConfigurationName)\org.apache.qpid.messaging.dll"
 				LinkIncremental="1"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
index 0021a15..04ddc17 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
index 08c0147..5dddc59 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
@@ -25,11 +25,27 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core">
-- 
1.7.1.1

From 49e8840023c526ed951f8bf7e97570e883399375 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Wed, 9 Jun 2010 11:59:38 +0000
Subject: [PATCH 058/129] Bug 603805 - .NET bindings for the C++ Messaging API

QPID-2589 Cleanup pass to address function naming, capitalization rules, change Qpid messaging 'list' representation from List<> to Collection<>,
some exception cleanup.
Patch from Chuck Rolke

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@952968 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit fdd9fd62edc6b304ce36090d38fdfc07ca0205fa)
---
 .../csharp.direct.receiver.cs                      |   16 +-
 .../csharp.direct.sender/csharp.direct.sender.cs   |   14 +-
 .../csharp.map.callback.receiver.cs                |   47 ++--
 .../csharp.map.callback.sender.cs                  |   19 +-
 .../csharp.map.receiver/csharp.map.recevier.cs     |   21 +-
 .../csharp.map.sender/csharp.map.sender.cs         |   17 +-
 qpid/cpp/bindings/qpid/dotnet/src/Address.cpp      |   50 ++--
 qpid/cpp/bindings/qpid/dotnet/src/Address.h        |   34 ++--
 qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp   |  128 ++++++-----
 qpid/cpp/bindings/qpid/dotnet/src/Connection.h     |   30 ++--
 qpid/cpp/bindings/qpid/dotnet/src/Duration.h       |   29 ++-
 qpid/cpp/bindings/qpid/dotnet/src/Message.cpp      |   99 ++++----
 qpid/cpp/bindings/qpid/dotnet/src/Message.h        |   75 ++++---
 qpid/cpp/bindings/qpid/dotnet/src/QpidException.h  |   16 +-
 qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h    |   11 +-
 qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h  |   31 ++-
 qpid/cpp/bindings/qpid/dotnet/src/ReadMe.txt       |    8 +-
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp     |   99 ++++-----
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.h       |   61 +++---
 qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp       |   22 +-
 qpid/cpp/bindings/qpid/dotnet/src/Sender.h         |   18 +-
 qpid/cpp/bindings/qpid/dotnet/src/Session.cpp      |  243 ++++++++------------
 qpid/cpp/bindings/qpid/dotnet/src/Session.h        |   48 ++--
 .../bindings/qpid/dotnet/src/TypeTranslator.cpp    |  122 +++++-----
 qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h |   47 ++--
 .../qpid/dotnet/src/org.apache.qpid.messaging.rc   |    6 +-
 .../dotnet/src/org.apache.qpid.messaging.vcproj    |    6 +-
 .../src/sessionreceiver/Properties/AssemblyInfo.cs |    4 +-
 .../dotnet/src/sessionreceiver/sessionreceiver.cs  |   38 ++--
 .../dotnet/test/messaging.test/messaging.test.cs   |   16 +-
 30 files changed, 689 insertions(+), 686 deletions(-)

diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
index 4888023..98531eb 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
@@ -23,7 +23,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
 namespace CSharpDirect
 {
@@ -54,20 +54,20 @@ namespace CSharpDirect
 
             Connection conn = new Connection(host);
 
-            conn.open();
+            conn.Open();
 
-            if (!conn.isOpen())
+            if (!conn.IsOpen())
             {
                 Console.WriteLine("Failed to open connection to host : {0}", host);
             }
             else
             {
 
-                Session sess = conn.createSession();
+                Session sess = conn.CreateSession();
 
                 Duration dura = new Duration(3600000); // wait forever
 
-                Receiver rcv = sess.createReceiver(addr);
+                Receiver rcv = sess.CreateReceiver(addr);
 
                 Message msg = new Message("");
 
@@ -75,8 +75,8 @@ namespace CSharpDirect
                 {
                     try
                     {
-                        Message msg2 = rcv.fetch(dura);
-                        Console.WriteLine("Rcvd msg {0} : {1}", i, msg2.getContent());
+                        Message msg2 = rcv.Fetch(dura);
+                        Console.WriteLine("Rcvd msg {0} : {1}", i, msg2.GetContent());
                     }
                     catch (Exception e)
                     {
@@ -84,7 +84,7 @@ namespace CSharpDirect
                     }
                 }
 
-                conn.close();
+                conn.Close();
             }
         }
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
index 1fe56aa..71ab75c 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
@@ -23,7 +23,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
 namespace csharp.direct.sender
 {
@@ -50,26 +50,26 @@ namespace csharp.direct.sender
 
             Connection conn = new Connection(host);
 
-            conn.open();
+            conn.Open();
 
-            if (!conn.isOpen())
+            if (!conn.IsOpen())
             {
                 Console.WriteLine("Failed to open connection to host : {0}", host);
             }
             else
             {
-                Session sess = conn.createSession();
+                Session sess = conn.CreateSession();
 
-                Sender snd = sess.createSender(addr);
+                Sender snd = sess.CreateSender(addr);
 
                 for (int i = 0; i < nMsg; i++)
                 {
                     Message msg = new Message(String.Format("Test Message {0}", i));
 
-                    snd.send(msg);
+                    snd.Send(msg);
                 }
 
-                conn.close();
+                conn.Close();
             }
         }
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
index e7294c6..2ef7854 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
@@ -21,10 +21,11 @@
 
 using System;
 using System.Collections.Generic;
-using org.apache.qpid.messaging;
-using org.apache.qpid.messaging.sessionreceiver;
+using System.Collections.ObjectModel;
+using Org.Apache.Qpid.Messaging;
+using Org.Apache.Qpid.Messaging.SessionReceiver;
 
-namespace org.apache.qpid.messaging.examples
+namespace Org.Apache.Qpid.Messaging.Examples
 {
     /// <summary>
     /// A class with functions to display structured messages.
@@ -50,7 +51,7 @@ namespace org.apache.qpid.messaging.examples
                 else if (QpidTypeCheck.ObjectIsList(kvp.Value))
                 {
                     Console.WriteLine("Key: {0}, Value: List", kvp.Key);
-                    ShowList((List<object>)kvp.Value, level + 1);
+                    ShowList((Collection<object>)kvp.Value, level + 1);
                 }
                 else
                     Console.WriteLine("Key: {0}, Value: {1}, Type: {2}",
@@ -63,7 +64,7 @@ namespace org.apache.qpid.messaging.examples
         /// </summary>
         /// <param name="list">The AMQP list</param>
         /// <param name="level">Nested depth</param>
-        public static void ShowList(List<object> list, int level)
+        public static void ShowList(Collection<object> list, int level)
         {
             foreach (object obj in list)
             {
@@ -77,7 +78,7 @@ namespace org.apache.qpid.messaging.examples
                 else if (QpidTypeCheck.ObjectIsList(obj))
                 {
                     Console.WriteLine("List");
-                    ShowList((List<object>)obj, level + 1);
+                    ShowList((Collection<object>)obj, level + 1);
                 }
                 else
                     Console.WriteLine("Value: {0}, Type: {1}",
@@ -92,24 +93,24 @@ namespace org.apache.qpid.messaging.examples
         /// <param name="message">The Message</param>
         public static void ShowMessage(Message message)
         {
-            if ("amqp/map" == message.getContentType())
+            if ("amqp/map" == message.GetContentType())
             {
                 Console.WriteLine("Received a Dictionary");
                 Dictionary<string, object> content = new Dictionary<string, object>();
-                message.getContent(content);
+                message.GetContent(content);
                 ShowDictionary(content, 0);
             }
-            else if ("amqp/list" == message.getContentType())
+            else if ("amqp/list" == message.GetContentType())
             {
                 Console.WriteLine("Received a List");
-                List<object> content = new List<object>();
-                message.getContent(content);
+                Collection<object> content = new Collection<object>();
+                message.GetContent(content);
                 ShowList(content, 0);
             }
             else
             {
                 Console.WriteLine("Received a String");
-                Console.WriteLine(message.getContent());
+                Console.WriteLine(message.GetContent());
             }
         }
     }
@@ -147,7 +148,7 @@ namespace org.apache.qpid.messaging.examples
             //
             // Acknowledge the receipt of all received messages.
             //
-            receiver.getSession().acknowledge();
+            receiver.GetSession().Acknowledge();
         }
 
 
@@ -170,7 +171,7 @@ namespace org.apache.qpid.messaging.examples
             Console.WriteLine("The details of the message body's types and values are shown.");
             Console.WriteLine();
             Console.WriteLine(" url  = target address for 'new Connection(url)'");
-            Console.WriteLine(" addr = address for 'session.createReceiver(addr)'");
+            Console.WriteLine(" addr = address for 'session.CreateReceiver(addr)'");
             Console.WriteLine(" nSec = time in seconds to keep the receiver callback open");
             Console.WriteLine();
             Console.WriteLine("Default values:");
@@ -211,20 +212,20 @@ namespace org.apache.qpid.messaging.examples
             // Create and open an AMQP connection to the broker URL
             //
             Connection connection = new Connection(url);
-            connection.open();
+            connection.Open();
 
             //
             // Create a session.
             //
-            Session session = connection.createSession();
+            Session session = connection.CreateSession();
 
             //
             // Receive through callback
             //
             // Create callback server and implicitly start it
             //
-            sessionreceiver.server cbServer =
-                new sessionreceiver.server(session, this);
+            SessionReceiver.CallbackServer cbServer =
+                new SessionReceiver.CallbackServer(session, this);
 
             //
             // The callback server is running and executing callbacks on a
@@ -235,12 +236,12 @@ namespace org.apache.qpid.messaging.examples
             // Create a receiver for the direct exchange using the
             // routing key "map_example".
             //
-            Receiver receiver = session.createReceiver(addr);
+            Receiver receiver = session.CreateReceiver(addr);
 
             //
             // Establish a capacity
             //
-            receiver.setCapacity(100);
+            receiver.SetCapacity(100);
 
             //
             // Wait so many seconds for messages to arrive.
@@ -250,13 +251,13 @@ namespace org.apache.qpid.messaging.examples
             //
             // Stop the callback server.
             //
-            cbServer.close();
+            cbServer.Close();
 
             //
             // Close the receiver and the connection.
             //
-            receiver.close();
-            connection.close();
+            receiver.Close();
+            connection.Close();
         }
     }
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
index a097267..761ac0a 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
@@ -21,11 +21,12 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.ObjectModel;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
-namespace org.apache.qpid.messaging.examples
+namespace Org.Apache.Qpid.Messaging.Examples
 {
     class MapSender
     {
@@ -42,7 +43,7 @@ namespace org.apache.qpid.messaging.examples
             Console.WriteLine("messages to a named exchange with a routing key.");
             Console.WriteLine();
             Console.WriteLine(" url = target address for 'new Connection(url)'");
-            Console.WriteLine(" addr = address for 'session.createReceiver(addr)'");
+            Console.WriteLine(" addr = address for 'session.CreateReceiver(addr)'");
             Console.WriteLine(" count = number of messages to send");
             Console.WriteLine();
             Console.WriteLine("Default values:");
@@ -82,14 +83,14 @@ namespace org.apache.qpid.messaging.examples
             // Create and open an AMQP connection to the broker URL
             //
             Connection connection = new Connection(url);
-            connection.open();
+            connection.Open();
 
             //
             // Create a session and a sender to the direct exchange using the
             // routing key "map_example".
             //
-            Session session = connection.createSession();
-            Sender sender = session.createSender(addr);
+            Session session = connection.CreateSession();
+            Sender sender = session.CreateSender(addr);
 
             //
             // Create structured content for the message.  This example builds a
@@ -97,7 +98,7 @@ namespace org.apache.qpid.messaging.examples
             //
             Dictionary<string, object> content = new Dictionary<string, object>();
             Dictionary<string, object> subMap = new Dictionary<string, object>();
-            List<object> colors = new List<object>();
+            Collection<object> colors = new Collection<object>();
 
             content["id"] = 987654321;
             content["name"] = "Widget";
@@ -120,12 +121,12 @@ namespace org.apache.qpid.messaging.examples
             //
             Message message = new Message(content);
             for (UInt32 i = 0; i<count; i++)
-                sender.send(message, true);
+                sender.Send(message, true);
 
             //
             // Close the connection.
             //
-            connection.close();
+            connection.Close();
         }
     }
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
index 9a425c0..41ed9f3 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
@@ -21,16 +21,15 @@
 
 using System;
 using System.Collections.Generic;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
-namespace org.apache.qpid.messaging.examples
+namespace Org.Apache.Qpid.Messaging.examples
 {
     class MapReceiver
     {
         static void Main(string[] args)
         {
             string url = "amqp:tcp:localhost:5672";
-//            string url = "10.16.18.254:5672";
             if (args.Length > 0)
                 url = args[0];
 
@@ -38,37 +37,37 @@ namespace org.apache.qpid.messaging.examples
             // Create and open an AMQP connection to the broker URL
             //
             Connection connection = new Connection(url);
-            connection.open();
+            connection.Open();
 
             //
             // Create a session and a receiver fir the direct exchange using the
             // routing key "map_example".
             //
-            Session session = connection.createSession();
-            Receiver receiver = session.createReceiver("amq.direct/map_example");
+            Session session = connection.CreateSession();
+            Receiver receiver = session.CreateReceiver("amq.direct/map_example");
 
             //
             // Fetch the message from the broker (wait indefinitely by default)
             //
-            Message message = receiver.fetch(new Duration(60000));
+            Message message = receiver.Fetch(new Duration(60000));
 
             //
             // Extract the structured content from the message.
             //
             Dictionary<string, object> content = new Dictionary<string, object>();
-            message.getContent(content);
+            message.GetContent(content);
             Console.WriteLine("Received: {0}", content);
 
             //
             // Acknowledge the receipt of all received messages.
             //
-            session.acknowledge();
+            session.Acknowledge();
 
             //
             // Close the receiver and the connection.
             //
-            receiver.close();
-            connection.close();
+            receiver.Close();
+            connection.Close();
         }
     }
 }
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
index 2890367..d1ccc65 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
@@ -21,11 +21,12 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.ObjectModel;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
-namespace org.apache.qpid.messaging.examples
+namespace Org.Apache.Qpid.Messaging.examples
 {
     class MapSender
     {
@@ -39,14 +40,14 @@ namespace org.apache.qpid.messaging.examples
             // Create and open an AMQP connection to the broker URL
             //
             Connection connection = new Connection(url);
-            connection.open();
+            connection.Open();
 
             //
             // Create a session and a sender to the direct exchange using the
             // routing key "map_example".
             //
-            Session session = connection.createSession();
-            Sender sender = session.createSender("amq.direct/map_example");
+            Session session = connection.CreateSession();
+            Sender sender = session.CreateSender("amq.direct/map_example");
 
             //
             // Create structured content for the message.  This example builds a
@@ -54,7 +55,7 @@ namespace org.apache.qpid.messaging.examples
             //
             Dictionary<string, object> content = new Dictionary<string, object>();
             Dictionary<string, object> subMap = new Dictionary<string, object>();
-            List<object> colors = new List<object>();
+            Collection<object> colors = new Collection<object>();
 
             content["id"] = 987654321;
             content["name"] = "Widget";
@@ -76,12 +77,12 @@ namespace org.apache.qpid.messaging.examples
             // via the sender.
             //
             Message message = new Message(content);
-            sender.send(message, true);
+            sender.Send(message, true);
 
             //
             // Close the connection.
             //
-            connection.close();
+            connection.Close();
         }
     }
 }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
index 8b48a20..f0bbe13 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
@@ -30,10 +30,10 @@
 #include "QpidTypeCheck.h"
 #include "TypeTranslator.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Address is a managed wrapper for a qpid::messaging::Address
@@ -58,10 +58,10 @@ namespace messaging {
                          System::String ^, System::Object ^> ^ options) :
         addressp(new ::qpid::messaging::Address())
     {
-        setName(name);
-        setSubject(subject);
-        setOptions(options);
-        setType("");
+        SetName(name);
+        SetSubject(subject);
+        SetOptions(options);
+        SetType("");
     }
 
 
@@ -72,10 +72,10 @@ namespace messaging {
                      System::String ^ type) :
         addressp(new ::qpid::messaging::Address())
     {
-        setName(name);
-        setSubject(subject);
-        setOptions(options);
-        setType(type);
+        SetName(name);
+        SetSubject(subject);
+        SetOptions(options);
+        SetType(type);
     }
 
 
@@ -114,12 +114,12 @@ namespace messaging {
     //
     // name
     //
-    System::String ^ Address::getName()
+    System::String ^ Address::GetName()
     {
         return gcnew System::String(addressp->getName().c_str());
     }
 
-    void Address::setName(System::String ^ name)
+    void Address::SetName(System::String ^ name)
     {
         addressp->::qpid::messaging::Address::setName(QpidMarshal::ToNative(name));
     }
@@ -127,21 +127,21 @@ namespace messaging {
     //
     // subject
     //
-    System::String ^ Address::getSubject()
+    System::String ^ Address::GetSubject()
     {
         return gcnew System::String(addressp->getSubject().c_str());
     }
 
-    void Address::setSubject(System::String ^ subject)
+    void Address::SetSubject(System::String ^ subject)
     {
-        addressp->setName(QpidMarshal::ToNative(subject));
+        addressp->setSubject(QpidMarshal::ToNative(subject));
     }
 
     //
     // options
     //
     System::Collections::Generic::Dictionary<
-        System::String ^, System::Object ^> ^ Address::getOptions()
+        System::String ^, System::Object ^> ^ Address::GetOptions()
     {
         ::qpid::types::Variant::Map map;
         System::Collections::Generic::Dictionary<
@@ -149,37 +149,37 @@ namespace messaging {
             gcnew System::Collections::Generic::Dictionary<
                   System::String ^, System::Object ^>;
         map = addressp->getOptions();
-        TypeTranslator::NativeToManaged(newMap, map);
+        TypeTranslator::NativeToManaged(map, newMap);
         return newMap;
     }
 
 
-    void Address::setOptions(System::Collections::Generic::Dictionary<
+    void Address::SetOptions(System::Collections::Generic::Dictionary<
                         System::String ^, System::Object ^> ^ options)
     {
         ::qpid::types::Variant::Map map;
-        TypeTranslator::ManagedToNative(map, options);
+        TypeTranslator::ManagedToNative(options, map);
         addressp->setOptions(map);
     }
 
     //
     // type
     //
-    System::String ^ Address::getType()
+    System::String ^ Address::GetType()
     {
         return gcnew System::String(addressp->getType().c_str());
     }
 
 
-    void Address::setType(System::String ^ type)
+    void Address::SetType(System::String ^ type)
     {
         addressp->setName(QpidMarshal::ToNative(type));
     }
 
     //
-    // str
+    // ToString
     //
-    System::String ^ Address::str()
+    System::String ^ Address::ToStr()
     {
         return gcnew System::String(addressp->str().c_str());
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.h b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
index 72eed76..60e24da 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Address.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
@@ -27,11 +27,10 @@
 
 #include "qpid/messaging/Address.h"
 
-
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Address is a managed wrapper for a qpid::messaging::Address
@@ -43,10 +42,10 @@ namespace messaging {
         // Kept object deletion code
         void Cleanup();
 
-    public:
         // The kept object in the Messaging C++ DLL
         ::qpid::messaging::Address * addressp;
 
+    public:
         Address();
         
         Address(System::String ^ address);
@@ -69,21 +68,26 @@ namespace messaging {
         !Address();
 //        Address(const Address % rhs);
 
-        System::String ^ getName();
-        void setName(System::String ^ name);
+        property ::qpid::messaging::Address * NativeAddress
+        {
+            ::qpid::messaging::Address * get () { return addressp; }
+        }
+
+        System::String ^ GetName();
+        void SetName(System::String ^ name);
 
-        System::String ^ getSubject();
-        void setSubject(System::String ^ subject);
+        System::String ^ GetSubject();
+        void SetSubject(System::String ^ subject);
 
         System::Collections::Generic::Dictionary<
-            System::String ^, System::Object ^> ^ getOptions();
+            System::String ^, System::Object ^> ^ GetOptions();
 
-        void setOptions(System::Collections::Generic::Dictionary<
+        void SetOptions(System::Collections::Generic::Dictionary<
                             System::String ^, System::Object ^> ^ options);
 
-        System::String ^ getType();
-        void setType(System::String ^ type);
+        System::String ^ GetType();
+        void SetType(System::String ^ type);
 
-        System::String ^ str();
+        System::String ^ ToStr();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
index 4936e18..590cc5e 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
@@ -33,10 +33,10 @@
 #include "QpidException.h"
 #include "TypeTranslator.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Connection is a managed wrapper for a qpid::messaging::Connection
@@ -56,7 +56,7 @@ namespace messaging {
     {
         for each (System::Collections::Generic::KeyValuePair<System::String^, System::Object^> kvp in options)
         {
-            setOption(kvp.Key, kvp.Value);
+            SetOption(kvp.Key, kvp.Value);
         }
     }
 
@@ -94,7 +94,7 @@ namespace messaging {
     }
 
 
-    void Connection::setOption(System::String ^ name, System::Object ^ value)
+    void Connection::SetOption(System::String ^ name, System::Object ^ value)
     {
         ::qpid::types::Variant entryValue;
         TypeTranslator::ManagedToNativeObject(value, entryValue);
@@ -102,31 +102,31 @@ namespace messaging {
         connectionp->::qpid::messaging::Connection::setOption(entryName, entryValue);
     }
 
-    void Connection::open()
+    void Connection::Open()
     {
         connectionp->open();
     }
 
-    System::Boolean Connection::isOpen()
+    System::Boolean Connection::IsOpen()
     {
         return connectionp->isOpen();
     }
 
-    void Connection::close()
+    void Connection::Close()
     {
         connectionp->close();
     }
 
     //
-    // createTransactionalSession()
+    // CreateTransactionalSession()
     //
-    Session ^ Connection::createTransactionalSession()
+    Session ^ Connection::CreateTransactionalSession()
     {
-        return createTransactionalSession("");
+        return CreateTransactionalSession("");
     }
 
 
-    Session ^ Connection::createTransactionalSession(System::String ^ name)
+    Session ^ Connection::CreateTransactionalSession(System::String ^ name)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Session * sessionp     = NULL;
@@ -148,42 +148,44 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Connection::createTransactionalSession unknown error");
-        }
         finally
         {
             // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
-                throw newException;
+                if (newSession != nullptr)
+				{
+					delete newSession;
+				}
+				else
+				{
+	                if (sessionp != NULL)
+		            {
+			            delete sessionp;
+				    }
+				}
             }
         }
 
-        return newSession;
+        if (newException != nullptr)
+        {
+            throw newException;
+        }
+
+		return newSession;
     }
 
 
     //
-    // createSession()
+    // CreateSession()
     //
-    Session ^ Connection::createSession()
+    Session ^ Connection::CreateSession()
     {
-        return createSession("");
+        return CreateSession("");
     }
 
 
-    Session ^ Connection::createSession(System::String ^ name)
+    Session ^ Connection::CreateSession(System::String ^ name)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Session * sessionp     = NULL;
@@ -205,33 +207,35 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Connection::createSession unknown error");
-        }
         finally
         {
             // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
-                throw newException;
+				if (newSession != nullptr)
+				{
+					delete newSession;
+				}
+				else
+				{
+					if (sessionp != NULL)
+					{
+						delete sessionp;
+					}
+				}
             }
         }
 
+		if (nullptr != newException) 
+		{
+			throw newException;
+		}
+
         return newSession;
     }
 
 
-    Session ^ Connection::getSession(System::String ^ name)
+    Session ^ Connection::GetSession(System::String ^ name)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Session * sess         = NULL;
@@ -250,28 +254,30 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Connection::getSession unknown error");
-        }
         finally
         {
             // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
-                if (sess != NULL)
-                {
-                    delete sess;
-                }
-                throw newException;
+				if (newSession != nullptr)
+				{
+					delete newSession;
+				}
+				else
+				{
+					if (sess != NULL)
+					{
+						delete sess;
+					}
+				}
             }
         }
 
+		if (nullptr != newException) 
+		{
+			throw newException;
+		}
+
         return newSession;
     }
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
index 894a96d..e93e078 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
@@ -28,10 +28,10 @@
 #include "qpid/messaging/Connection.h"
 #include "qpid/messaging/Session.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Connection is a managed wrapper for a qpid::messaging::Connection
@@ -59,20 +59,20 @@ namespace messaging {
         ~Connection();
         !Connection();
 
-        void setOption(System::String ^ name, System::Object ^ value);
+        void SetOption(System::String ^ name, System::Object ^ value);
 
-        void open();
-        System::Boolean isOpen();
-        void close();
+        void Open();
+        System::Boolean IsOpen();
+        void Close();
 
-        // createTransactionalSession()
-        Session ^ createTransactionalSession();
-        Session ^ createTransactionalSession(System::String ^ name);
+        // CreateTransactionalSession()
+        Session ^ CreateTransactionalSession();
+        Session ^ CreateTransactionalSession(System::String ^ name);
 
-        // createSession()
-        Session ^ createSession();
-        Session ^ createSession(System::String ^ name);
+        // CreateSession()
+        Session ^ CreateSession();
+        Session ^ CreateSession(System::String ^ name);
 
-        Session ^ getSession(System::String ^ name);
+        Session ^ GetSession(System::String ^ name);
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Duration.h b/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
index b7d2bf1..8bbfa56 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Duration.h
@@ -25,17 +25,17 @@
 #include <string>
 #include <limits>
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Duration is a time interval in milliseconds.
     /// It is a managed equivalent of ::qpid::messaging::Duration
     /// </summary>
 
-    public ref class Duration
+    public ref class Duration sealed
     {
     private:
         System::UInt64 milliseconds;
@@ -69,10 +69,25 @@ namespace messaging {
             Duration ^ result = gcnew Duration(multiplier * dur->Milliseconds);
             return result;
         }
-    };
 
-    public ref class DurationConstants
+        static Duration ^ Multiply (Duration ^ dur, const System::UInt64 multiplier)
+        {
+            Duration ^ result = gcnew Duration(dur->Milliseconds * multiplier);
+            return result;
+        }
+
+        static Duration ^ Multiply (const System::UInt64 multiplier, Duration ^ dur)
+        {
+            Duration ^ result = gcnew Duration(multiplier * dur->Milliseconds);
+            return result;
+        }
+	};
+
+    public ref class DurationConstants sealed
     {
+	private:
+		DurationConstants::DurationConstants() {}
+
     public:
         static Duration ^ FORVER;
         static Duration ^ IMMEDIATE;
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
index 193a2eb..3f748f1 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
@@ -36,10 +36,10 @@
 #include "QpidException.h"
 #include "TypeTranslator.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Message is a managed wrapper for a ::qpid::messaging::Message
@@ -52,19 +52,16 @@ namespace messaging {
     }
 
     // Create from string
-    Message::Message(System::String ^ string) :
-        messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative(string)))
+    Message::Message(System::String ^ theStr) :
+        messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative(theStr)))
     {
     }
 
     // Create from object
-    Message::Message(System::Object ^ objp) :
+    Message::Message(System::Object ^ theValue) :
         messagep(new ::qpid::messaging::Message(QpidMarshal::ToNative("")))
     {
-        ::qpid::types::Variant * variantp  = 0;
-        std::string            * variantsp = 0;
-
-        if (QpidTypeCheck::ObjectIsMap(objp))
+        if (QpidTypeCheck::ObjectIsMap(theValue))
         {
             // Create a mapped message using given dictionary
 
@@ -72,7 +69,7 @@ namespace messaging {
             ::qpid::types::Variant::Map newMap;
 
             // Add the map variables to the map
-            TypeTranslator::ManagedToNative(newMap, (QpidMap ^)objp);
+            TypeTranslator::ManagedToNative((QpidMap ^)theValue, newMap);
 
             // Set message content type
             messagep->setContentType("ampq/map");
@@ -80,7 +77,7 @@ namespace messaging {
             // Insert the map into the message
             ::qpid::messaging::encode(newMap, *messagep, QpidMarshal::ToNative("amqp/map"));
         }
-        else if (QpidTypeCheck::ObjectIsList(objp))
+        else if (QpidTypeCheck::ObjectIsList(theValue))
         {
             // Create a list message using given list
 
@@ -88,7 +85,7 @@ namespace messaging {
             ::qpid::types::Variant::List newList;
 
             // Add the list variables to the list
-            TypeTranslator::ManagedToNative(newList, (QpidList ^)objp);
+            TypeTranslator::ManagedToNative((QpidList ^)theValue, newList);
 
             // Set message content type
             messagep->setContentType("ampq/list");
@@ -99,7 +96,7 @@ namespace messaging {
         else
         {
             // Create a binary string message
-            messagep->setContent(QpidMarshal::ToNative(objp->ToString()));
+            messagep->setContent(QpidMarshal::ToNative(theValue->ToString()));
         }
     }
 
@@ -145,12 +142,12 @@ namespace messaging {
     //
     // ReplyTo
     //
-    void Message::setReplyTo(Address ^ address)
+    void Message::SetReplyTo(Address ^ address)
     {
-        messagep->setReplyTo(*(address->addressp));
+        messagep->setReplyTo(*(address->NativeAddress));
     }
 
-    Address ^ Message::getReplyTo()
+    Address ^ Message::GetReplyTo()
     {
         const ::qpid::messaging::Address & addrp =
             messagep->::qpid::messaging::Message::getReplyTo();
@@ -162,12 +159,12 @@ namespace messaging {
     //
     // Subject
     //
-    void Message::setSubject(System::String ^ subject)
+    void Message::SetSubject(System::String ^ subject)
     {
         messagep->setSubject(QpidMarshal::ToNative(subject));
     }
     
-    System::String ^ Message::getSubject()
+    System::String ^ Message::GetSubject()
     {
         return gcnew String(messagep->getSubject().c_str());
     }
@@ -176,26 +173,26 @@ namespace messaging {
     //
     // ContentType
     //
-    void Message::setContentType(System::String ^ ct)
+    void Message::SetContentType(System::String ^ ct)
     {
         messagep->setContentType(QpidMarshal::ToNative(ct));
     }
     
-    System::String ^ Message::getContentType()
+	System::String ^ Message::GetContentType()
     {
-        return gcnew String(messagep->getContentType().c_str());
+		return gcnew String(messagep->::qpid::messaging::Message::getContentType().c_str());
     }
     
     
     //
     // MessageId
     //
-    void Message::setMessageId(System::String ^ mId)
+    void Message::SetMessageId(System::String ^ messageId)
     {
-        messagep->setMessageId(QpidMarshal::ToNative(mId));
+        messagep->setMessageId(QpidMarshal::ToNative(messageId));
     }
     
-    System::String ^ Message::getMessageId()
+    System::String ^ Message::GetMessageId()
     {
         return gcnew String(messagep->getMessageId().c_str());
     }
@@ -204,12 +201,12 @@ namespace messaging {
     //
     // UserId
     //
-    void Message::setUserId(System::String ^ uId)
+    void Message::SetUserId(System::String ^ uId)
     {
         messagep->setUserId(QpidMarshal::ToNative(uId));
     }
     
-    System::String ^ Message::getUserId()
+    System::String ^ Message::GetUserId()
     {
         return gcnew String(messagep->getUserId().c_str());
     }
@@ -218,12 +215,12 @@ namespace messaging {
     //
     // CorrelationId
     //
-    void Message::setCorrelationId(System::String ^ cId)
+    void Message::SetCorrelationId(System::String ^ correlationId)
     {
-        messagep->setCorrelationId(QpidMarshal::ToNative(cId));
+        messagep->setCorrelationId(QpidMarshal::ToNative(correlationId));
     }
     
-    System::String ^ Message::getCorrelationId()
+    System::String ^ Message::GetCorrelationId()
     {
         return gcnew String(messagep->getCorrelationId().c_str());
     }
@@ -232,12 +229,12 @@ namespace messaging {
     //
     // Priority
     //
-    void Message::setPriority(unsigned char priority)
+    void Message::SetPriority(unsigned char priority)
     {
         messagep->setPriority(priority);
     }
     
-    unsigned char Message::getPriority()
+    unsigned char Message::GetPriority()
     {
         return messagep->getPriority();
     }
@@ -246,44 +243,44 @@ namespace messaging {
     //
     // Ttl
     //
-    void Message::setTtl(Duration ^ ttl)
+    void Message::SetTtl(Duration ^ ttl)
     {
         ::qpid::messaging::Duration dur(ttl->Milliseconds);
 
         messagep->setTtl(dur);
     }
     
-    Duration ^ Message::getTtl()
+    Duration ^ Message::GetTtl()
     {
         Duration ^ dur = gcnew Duration(messagep->getTtl().getMilliseconds());
 
         return dur;
     }
 
-    void Message::setDurable(bool durable)
+    void Message::SetDurable(bool durable)
     {
         messagep->setDurable(durable);
     }
     
-    bool Message::getDurable()
+    bool Message::GetDurable()
     {
         return messagep->getDurable();
     }
 
 
-    bool Message::getRedelivered()
+    bool Message::GetRedelivered()
     {
         return messagep->getRedelivered();
     }
 
-    void Message::setRedelivered(bool redelivered)
+    void Message::SetRedelivered(bool redelivered)
     {
         messagep->setRedelivered(redelivered);
     }
 
 
     System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ Message::getProperties()
+            System::String^, System::Object^> ^ Message::GetProperties()
     {
         ::qpid::types::Variant::Map map;
 
@@ -294,19 +291,19 @@ namespace messaging {
             gcnew System::Collections::Generic::Dictionary<
                       System::String^, System::Object^> ;
 
-        TypeTranslator::NativeToManaged(dict, map);
+        TypeTranslator::NativeToManaged(map, dict);
 
         return dict;
     }
 
 
-    void Message::setContent(System::String ^ content)
+    void Message::SetContent(System::String ^ content)
     {
         messagep->setContent(QpidMarshal::ToNative(content));
     }
 
 
-    System::String ^ Message::getContent()
+    System::String ^ Message::GetContent()
     {
         return gcnew String(messagep->getContent().c_str());
     }
@@ -315,7 +312,7 @@ namespace messaging {
     //
     // User wants to extract a Dictionary from the message
     //
-    void Message::getContent(System::Collections::Generic::Dictionary<
+    void Message::GetContent(System::Collections::Generic::Dictionary<
                                 System::String^, 
                                 System::Object^> ^ dict)
     {
@@ -324,14 +321,14 @@ namespace messaging {
         
         ::qpid::messaging::decode(*messagep, map, QpidMarshal::ToNative("amqp/map"));
 
-        TypeTranslator::NativeToManaged(dict, map);
+        TypeTranslator::NativeToManaged(map, dict);
     }
 
 
     //
     // User wants to extract a list from the message
     //
-    void Message::getContent(System::Collections::Generic::List<
+    void Message::GetContent(System::Collections::ObjectModel::Collection<
                         System::Object^> ^ list)
     {
         // allocate a native messaging::List
@@ -341,22 +338,22 @@ namespace messaging {
         ::qpid::messaging::decode(*messagep, nativeList, QpidMarshal::ToNative("amqp/list"));
 
         // translate native list into user's managed list
-        TypeTranslator::NativeToManaged(list, nativeList);
+        TypeTranslator::NativeToManaged(nativeList, list);
     }
 
     //
     // User wants content as bytes.
     // result array must be correct size already
     //
-    void Message::getRaw(array<System::Byte> ^ arr)
+    void Message::GetRaw(array<System::Byte> ^ arr)
     {
         System::UInt32 size = messagep->getContentSize();
      
         if (0 == size)
-            throw gcnew QpidException("Message::getRaw - message size is zero");
+            throw gcnew QpidException("Message::GetRaw - message size is zero");
 
         if (arr->Length != size)
-            throw gcnew QpidException("Message::getRaw - receive buffer is too small");
+            throw gcnew QpidException("Message::GetRaw - receive buffer is too small");
 
         const char * ptr = messagep->getContentPtr();
 
@@ -369,7 +366,7 @@ namespace messaging {
     }
 
 
-    System::UInt64 Message::getContentSize()
+    System::UInt64 Message::GetContentSize()
     {
         return messagep->getContentSize();
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.h b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
index ab06588..0a932a9 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
@@ -26,10 +26,10 @@
 
 #include "qpid/messaging/Message.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     ref class Address;
     ref class Duration;
@@ -45,15 +45,18 @@ namespace messaging {
         // Kept object deletion code
         void Cleanup();
 
+        // The kept object in the Messaging C++ DLL
+        ::qpid::messaging::Message * messagep;
+
     public:
         // Create empty message
         Message();
 
         // Create from String
-        Message(System::String ^ string);
+        Message(System::String ^ theStr);
 
         // Create from object
-        Message(System::Object ^ obj);
+        Message(System::Object ^ theValue);
 
         // TODO: Create from bytes
         // Message(System::Byte [] ^ bytes);
@@ -67,62 +70,64 @@ namespace messaging {
         // Copy constructor
         Message(const Message % rhs);
 
-        // The kept object in the Messaging C++ DLL
-        ::qpid::messaging::Message * messagep;
+        property ::qpid::messaging::Message * NativeMessage
+        {
+            ::qpid::messaging::Message * get () { return messagep; }
+        }
 
-        void setReplyTo(Address ^ address);
-        Address ^ getReplyTo();
+        void SetReplyTo(Address ^ address);
+        Address ^ GetReplyTo();
 
-        void setSubject(System::String ^ subject);
-        System::String ^ getSubject();
+        void SetSubject(System::String ^ subject);
+        System::String ^ GetSubject();
 
-        void setContentType(System::String ^ ct);
-        System::String ^ getContentType();
+        void SetContentType(System::String ^ ct);
+        System::String ^ GetContentType();
         
-        void setMessageId(System::String ^ mId);
-        System::String ^ getMessageId();
+        void SetMessageId(System::String ^ messageId);
+        System::String ^ GetMessageId();
         
-        void setUserId(System::String ^ uId);
-        System::String ^ getUserId();
+        void SetUserId(System::String ^ uId);
+        System::String ^ GetUserId();
         
-        void setCorrelationId(System::String ^ cId);
-        System::String ^ getCorrelationId();
+        void SetCorrelationId(System::String ^ correlationId);
+        System::String ^ GetCorrelationId();
 
-        void setPriority(unsigned char priority);
-        unsigned char getPriority();
+        void SetPriority(unsigned char priority);
+        unsigned char GetPriority();
 
-        void setTtl(Duration ^ ttl);
-        Duration ^ getTtl();
+        void SetTtl(Duration ^ ttl);
+        Duration ^ GetTtl();
 
-        void setDurable(bool durable);
-        bool getDurable();
+        void SetDurable(bool durable);
+        bool GetDurable();
 
-        bool getRedelivered();
-        void setRedelivered(bool redelivered);
+        bool GetRedelivered();
+        void SetRedelivered(bool redelivered);
 
         System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ getProperties();
+            System::String^, System::Object^> ^ GetProperties();
 
-        void setContent(System::String ^ content);
+        void SetContent(System::String ^ content);
 
         //TODO:: void setContent(Bytes{} bytes, offset, length);
 
         // get content as string
-        System::String ^ getContent();
+        System::String ^ GetContent();
 
         // get content as dictionary
-        void getContent(System::Collections::Generic::Dictionary<
+        void GetContent(System::Collections::Generic::Dictionary<
                             System::String^, 
                             System::Object^> ^ dict);
 
         // get content as map
-        void getContent(System::Collections::Generic::List<
+        void GetContent(System::Collections::ObjectModel::Collection<
                             System::Object^> ^);
 
         // get content as bytes
-        void getRaw(cli::array<System::Byte> ^ arr);
+        void GetRaw(cli::array<System::Byte> ^ arr);
 
-        System::UInt64 getContentSize();
+        System::UInt64 GetContentSize();
 
         //TODO: EncodingException
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
index eecc545..c63f245 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidException.h
@@ -19,19 +19,23 @@
 
 #pragma once
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
 using namespace System;
 
+[Serializable]
 public ref class QpidException : System::Exception
 {
  public:
 
- QpidException() : System::Exception() {}
- QpidException(String^ estring) : System::Exception(estring) {}
+ QpidException() 
+	 : System::Exception() {}
+
+ QpidException(String^ estring) 
+	 : System::Exception(estring) {}
 
 };
 
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
index 7b52346..a8266ba 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidMarshal.h
@@ -22,10 +22,10 @@
 using namespace System;
 using namespace System::Text;
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
 
 
@@ -33,6 +33,9 @@ namespace messaging {
 
 private ref class QpidMarshal
 {
+private:
+	QpidMarshal::QpidMarshal() {}
+
 public:
 
     /// <summary>
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h b/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
index 2e87c3e..47f391f 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/QpidTypeCheck.h
@@ -24,10 +24,10 @@
 #include <string>
 #include <limits>
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// QpidTypeCheck determines if a given managed object represents
@@ -35,7 +35,7 @@ namespace messaging {
     ///
     // The supported mapping is:
     /// * a managed Dictionary and a Qpid Messaging Map
-    /// * a managed List       and a Qpid Messaging List
+    /// * a managed Collection and a Qpid Messaging List
     /// </summary>
 
     typedef System::Collections::Generic::Dictionary<
@@ -43,33 +43,38 @@ namespace messaging {
                 System::Object^> 
                     QpidMap;
 
-    typedef System::Collections::Generic::List<
+    typedef System::Collections::ObjectModel::Collection<
                 System::Object^> 
                     QpidList;
 
-    private ref class QpidTypeCheckConstants
+    private ref class QpidTypeCheckConstants sealed
     {
+	private:
+		QpidTypeCheckConstants::QpidTypeCheckConstants() {}
+
     public:
         static System::Type const ^ const mapTypeP = System::Type::GetType(
             "System.Collections.Generic.Dictionary`2[System.String,System.Object]");
         static System::Type const ^ const listTypeP = System::Type::GetType(
-            "System.Collections.Generic.List`1[System.Object]");
+            "System.Collections.ObjectModel.Collection`1[System.Object]");
     };
 
 
-    public ref class QpidTypeCheck
+    public ref class QpidTypeCheck sealed
     {
+	private:
+		QpidTypeCheck::QpidTypeCheck() {}
 
     public:
 
-        static bool ObjectIsMap (System::Object ^ object)
+        static bool ObjectIsMap (System::Object ^ theValue)
         { 
-            return (*object).GetType() == QpidTypeCheckConstants::mapTypeP;
+            return (*theValue).GetType() == QpidTypeCheckConstants::mapTypeP;
         }
 
-        static bool ObjectIsList(System::Object ^ object)
+        static bool ObjectIsList(System::Object ^ theValue)
         { 
-            return (*object).GetType() == QpidTypeCheckConstants::listTypeP;
+            return (*theValue).GetType() == QpidTypeCheckConstants::listTypeP;
         }
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/ReadMe.txt b/qpid/cpp/bindings/qpid/dotnet/src/ReadMe.txt
index a75e35b..a17f043 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/ReadMe.txt
+++ b/qpid/cpp/bindings/qpid/dotnet/src/ReadMe.txt
@@ -1,13 +1,13 @@
 ========================================================================
-    DYNAMIC LINK LIBRARY : org.apache.qpid.messaging Project Overview
+    DYNAMIC LINK LIBRARY : Org.Apache.Qpid.Messaging Project Overview
 ========================================================================
 
-AppWizard has created this org.apache.qpid.messaging DLL for you.  
+AppWizard has created this Org.Apache.Qpid.Messaging DLL for you.  
 
 This file contains a summary of what you will find in each of the files that
-make up your org.apache.qpid.messaging application.
+make up your Org.Apache.Qpid.Messaging application.
 
-org.apache.qpid.messaging.vcproj
+Org.Apache.Qpid.Messaging.vcproj
     This is the main project file for VC++ projects generated using an Application Wizard. 
     It contains information about the version of Visual C++ that generated the file, and 
     information about the platforms, configurations, and project features selected with the
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
index d647315..15f8572 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
@@ -34,10 +34,10 @@
 #include "Duration.h"
 #include "QpidException.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Receiver is a managed wrapper for a ::qpid::messaging::Receiver
@@ -85,30 +85,30 @@ namespace messaging {
     }
 
     //
-    // get(message)
+    // Get(message)
     //
-    bool Receiver::get(Message ^ mmsgp)
+    bool Receiver::Get(Message ^ mmsgp)
     {
-        return get(mmsgp, DurationConstants::FORVER);
+        return Get(mmsgp, DurationConstants::FORVER);
     }
 
-    bool Receiver::get(Message ^ mmsgp, Duration ^ durationp)
+    bool Receiver::Get(Message ^ mmsgp, Duration ^ durationp)
     {
         ::qpid::messaging::Duration dur((*durationp).Milliseconds);
 
-        return receiverp->Receiver::get(*(mmsgp->messagep), dur);
+        return receiverp->Receiver::get(*(mmsgp->NativeMessage), dur);
     }
 
     //
-    // message = get()
+    // message = Get()
     //
-    Message ^ Receiver::get()
+    Message ^ Receiver::Get()
     {
-        return get(DurationConstants::FORVER);
+        return Get(DurationConstants::FORVER);
     }
 
 
-    Message ^ Receiver::get(Duration ^ durationp)
+    Message ^ Receiver::Get(Duration ^ durationp)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Message * msgp         = NULL;
@@ -133,58 +133,54 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Receiver:get unknown error");
-        }
         finally
         {
-            // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
                 if (msgp != NULL)
                 {
                     delete msgp;
                 }
-
-                throw newException;
+				if (newMessage != nullptr)
+				{
+					delete newMessage;
+				}
             }
         }
+        if (newException != nullptr)
+        {
+			throw newException;
+		}
 
         return newMessage;
     }
 
     //
-    // fetch(message)
+    // Fetch(message)
     //
-    bool Receiver::fetch(Message ^ mmsgp)
+    bool Receiver::Fetch(Message ^ mmsgp)
     {
-        return fetch(mmsgp, DurationConstants::FORVER);
+        return Fetch(mmsgp, DurationConstants::FORVER);
     }
 
-    bool Receiver::fetch(Message ^ mmsgp, Duration ^ durationp)
+    bool Receiver::Fetch(Message ^ mmsgp, Duration ^ durationp)
     {
         ::qpid::messaging::Duration dur((*durationp).Milliseconds);
 
-        return receiverp->::qpid::messaging::Receiver::fetch(*((*mmsgp).messagep), dur);
+        return receiverp->::qpid::messaging::Receiver::fetch(*((*mmsgp).NativeMessage), dur);
     }
     
 
     //
-    // message = fetch()
+    // message = Fetch()
     //
 
-    Message ^ Receiver::fetch()
+    Message ^ Receiver::Fetch()
     {
-        return fetch(DurationConstants::FORVER);
+        return Fetch(DurationConstants::FORVER);
     }
 
-    Message ^ Receiver::fetch(Duration ^ durationp)
+    Message ^ Receiver::Fetch(Duration ^ durationp)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Message * msgp         = NULL;
@@ -209,64 +205,59 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Receiver:fetch unknown error");
-
-        }
         finally
         {
-            // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
                 if (msgp != NULL)
                 {
                     delete msgp;
                 }
-
-                throw newException;
+				if (newMessage != nullptr)
+				{
+					delete newMessage;
+				}
             }
         }
+        if (newException != nullptr)
+        {
+			throw newException;
+		}
 
         return newMessage;
     }
 
-    void Receiver::setCapacity(System::UInt32 capacity)
+    void Receiver::SetCapacity(System::UInt32 capacity)
     {
         receiverp->setCapacity(capacity);
     }
 
-    System::UInt32 Receiver::getCapacity()
+    System::UInt32 Receiver::GetCapacity()
     {
         return receiverp->getCapacity();
     }
 
-    System::UInt32 Receiver::getAvailable()
+    System::UInt32 Receiver::GetAvailable()
     {
         return receiverp->getAvailable();
     }
 
-    System::UInt32 Receiver::getUnsettled()
+    System::UInt32 Receiver::GetUnsettled()
     {
         return receiverp->getUnsettled();
     }
 
-    void Receiver::close()
+    void Receiver::Close()
     {
         receiverp->close();
     }
 
-    System::String ^ Receiver::getName()
+    System::String ^ Receiver::GetName()
     {
         return gcnew System::String(receiverp->getName().c_str());
     }
 
-    Session ^ Receiver::getSession()
+    Session ^ Receiver::GetSession()
     {
         return parentSession;
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
index 26d0402..0dc2f61 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
@@ -35,10 +35,10 @@ namespace messaging {
     class ReceiverImpl {};
 }}
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Mreceiver is a managed wrapper for a ::qpid::messaging::Receiver
@@ -57,38 +57,43 @@ namespace messaging {
         // Kept object deletion code
         void Cleanup();
 
-    public:
         // The kept object in the Messaging C++ DLL
         ::qpid::messaging::Receiver * receiverp;
 
+    public:
         Receiver(::qpid::messaging::Receiver * r,
             Session ^ sessRef);
         ~Receiver();
         !Receiver();
         Receiver(const Receiver ^ rhs);
 
-        // get(message)
-        bool get(Message ^ mmsgp);
-        bool get(Message ^ mmsgp, Duration ^ durationp);
-
-        // message = get()
-        Message ^ get();
-        Message ^ get(Duration ^ durationp);
-
-        // fetch(message)
-        bool fetch(Message ^ mmsgp);
-        bool fetch(Message ^ mmsgp, Duration ^ duration);
-
-        // message = fetch()
-        Message ^ fetch();
-        Message ^ fetch(Duration ^ durationp);
-
-        void setCapacity(System::UInt32 capacity);
-        System::UInt32 getCapacity();
-        System::UInt32 getAvailable();
-        System::UInt32 getUnsettled();
-        void close();
-        System::String ^ getName();
-        Session ^ getSession();
+        property ::qpid::messaging::Receiver * NativeReceiver
+        {
+            ::qpid::messaging::Receiver * get () { return receiverp; }
+        }
+
+        // Get(message)
+        bool Get(Message ^ mmsgp);
+        bool Get(Message ^ mmsgp, Duration ^ durationp);
+
+        // message = Get()
+        Message ^ Get();
+        Message ^ Get(Duration ^ durationp);
+
+        // Fetch(message)
+        bool Fetch(Message ^ mmsgp);
+        bool Fetch(Message ^ mmsgp, Duration ^ duration);
+
+        // message = Fetch()
+        Message ^ Fetch();
+        Message ^ Fetch(Duration ^ durationp);
+
+        void SetCapacity(System::UInt32 capacity);
+        System::UInt32 GetCapacity();
+        System::UInt32 GetAvailable();
+        System::UInt32 GetUnsettled();
+        void Close();
+        System::String ^ GetName();
+        Session ^ GetSession();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
index 1708359..e0911b3 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
@@ -30,10 +30,10 @@
 #include "Sender.h"
 #include "Message.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Sender a managed wrapper for a ::qpid::messaging::Sender 
@@ -79,25 +79,25 @@ namespace messaging {
     }
 
     //
-    // send(msg)
+    // Send(msg)
     //
-    void Sender::send(Message ^ mmsgp)
+    void Sender::Send(Message ^ mmsgp)
     {
-        send(mmsgp, false);
+        Send(mmsgp, false);
     }
 
-    void Sender::send(Message ^ mmsgp, bool sync)
+    void Sender::Send(Message ^ mmsgp, bool sync)
     {
-        senderp->::qpid::messaging::Sender::send(*((*mmsgp).messagep), sync);
+        senderp->::qpid::messaging::Sender::send(*((*mmsgp).NativeMessage), sync);
     }
 
 
-    void Sender::close()
+    void Sender::Close()
     {
         senderp->close();
     }
 
-    Session ^ Sender::getSession()
+    Session ^ Sender::GetSession()
     {
         return parentSession;
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
index 17f7e82..705c7d5 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
@@ -34,10 +34,10 @@ namespace messaging {
     class SenderImpl {};
 }}
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Sender is a managed wrapper for a ::qpid::messaging::Sender 
@@ -65,11 +65,11 @@ namespace messaging {
         !Sender();
         Sender(const Sender % rhs);
 
-        // send(message)
-        void send(Message ^ mmsgp);
-        void send(Message ^ mmsgp, bool sync);
+        // Send(message)
+        void Send(Message ^ mmsgp);
+        void Send(Message ^ mmsgp, bool sync);
 
-        void close();
+        void Close();
 
         property System::UInt32 Capacity
         {
@@ -95,6 +95,6 @@ namespace messaging {
             }
         }
 
-        Session ^ getSession();
+        Session ^ GetSession();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
index c070f10..c8d85b0 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
@@ -35,10 +35,10 @@
 #include "Message.h"
 #include "QpidException.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Session is a managed wrapper for a ::qpid::messaging::Session
@@ -84,110 +84,93 @@ namespace messaging {
         }
     }
 
-    void Session::close()
+    void Session::Close()
     {
         sessionp->close();
     }
 
-    void Session::commit()
+    void Session::Commit()
     {
         sessionp->commit();
     }
 
-    void Session::rollback()
+    void Session::Rollback()
     {
         sessionp->rollback();
     }
 
-    void Session::acknowledge()
+    void Session::Acknowledge()
     {
-        acknowledge(false);
+        Acknowledge(false);
     }
 
-    void Session::acknowledge(bool sync)
+    void Session::Acknowledge(bool sync)
     {
         sessionp->acknowledge(sync);
     }
 
-    void Session::reject(Message ^ message)
+    void Session::Reject(Message ^ message)
     {
-        sessionp->::qpid::messaging::Session::reject(*(message->messagep));
+        sessionp->::qpid::messaging::Session::reject(*(message->NativeMessage));
     }
 
-    void Session::release(Message ^ message)
+    void Session::Release(Message ^ message)
     {
-        sessionp->::qpid::messaging::Session::release(*(message->messagep));
+        sessionp->::qpid::messaging::Session::release(*(message->NativeMessage));
     }
 
-    void Session::sync()
+    void Session::Sync()
     {
-        sync(true);
+        Sync(true);
     }
 
-    void Session::sync(bool block)
+    void Session::Sync(bool block)
     {
         sessionp->sync(block);
     }
 
     // next(receiver)
-    bool Session::nextReceiver(Receiver ^ rcvr)
+    bool Session::NextReceiver(Receiver ^ rcvr)
     {
-        return nextReceiver(rcvr, DurationConstants::FORVER);
+        return NextReceiver(rcvr, DurationConstants::FORVER);
     }
 
-    bool Session::nextReceiver(Receiver ^ rcvr, Duration ^ timeout)
+    bool Session::NextReceiver(Receiver ^ rcvr, Duration ^ timeout)
     {
         System::Exception           ^ newException = nullptr;
 
-        try
-        {
+        try 
+		{
+			// create a duration object
             ::qpid::messaging::Duration dur(timeout->Milliseconds);
 
-            return sessionp->nextReceiver(*(rcvr->receiverp), dur);
+			// wait for the next received message
+            return sessionp->nextReceiver(*(rcvr->NativeReceiver), dur);
         } 
         catch (const ::qpid::types::Exception & error) 
-        {
+		{
             String ^ errmsg = gcnew String(error.what());
-            if (errmsg = "No message to fetch")
-            {
-                // on timeout return null
+            if ("No message to fetch" == errmsg){
                 return false;
             }
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Session::nextReceiver unknown error");
 
-        }
-        finally
-        {
-            // Clean up and throw on caught exceptions
-            if (newException != nullptr)
-            {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
+		if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
-                throw newException;
-            }
-        }
         return true;
     }
 
     // receiver = next()
-    Receiver ^ Session::nextReceiver()
+    Receiver ^ Session::NextReceiver()
     {
-        return nextReceiver(DurationConstants::FORVER);
+        return NextReceiver(DurationConstants::FORVER);
     }
 
-    Receiver ^ Session::nextReceiver(Duration ^ timeout)
+    Receiver ^ Session::NextReceiver(Duration ^ timeout)
     {
         System::Exception           ^ newException = nullptr;
 
@@ -205,41 +188,23 @@ namespace messaging {
         catch (const ::qpid::types::Exception & error) 
         {
             String ^ errmsg = gcnew String(error.what());
-            if (errmsg = "No message to fetch")
+            if ("No message to fetch" == errmsg)
             {
-                // on timeout return null
                 return nullptr;
             }
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Session::nextReceiver unknown error");
 
-        }
-        finally
-        {
-            // Clean up and throw on caught exceptions
-            if (newException != nullptr)
-            {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
+		if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
-                throw newException;
-            }
-        }
-        return nullptr;
+		return nullptr;
     }
 
 
-    Sender ^ Session::createSender  (System::String ^ address)
+    Sender ^ Session::CreateSender  (System::String ^ address)
     {
         System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Sender  * senderp         = NULL;
@@ -261,41 +226,39 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Session::createSender unknown error");
-
-        }
         finally
         {
-            // Clean up and throw on caught exceptions
             if (newException != nullptr)
             {
-                if (senderp != NULL)
-                {
-                    delete senderp;
-                }
-
-                throw newException;
+				if (newSender != nullptr)
+				{
+					delete newSender;
+				}
+				else
+				{
+					if (senderp != NULL)
+					{
+						delete senderp;
+					}
+				}
             }
         }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
         return newSender;
     }
 
-    Receiver ^ Session::createReceiver(System::String ^ address)
+    Receiver ^ Session::CreateReceiver(System::String ^ address)
     {
         System::Exception           ^ newException = nullptr;
         ::qpid::messaging::Receiver * receiverp    = NULL;
         Receiver                    ^ newReceiver  = nullptr;
 
-        try
-        {
+        try 
+		{
             // allocate a native receiver
             receiverp = new ::qpid::messaging::Receiver;
 
@@ -306,39 +269,37 @@ namespace messaging {
             newReceiver = gcnew Receiver(receiverp, this);
         } 
         catch (const ::qpid::types::Exception & error) 
-        {
+		{
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Session::createReceiver unknown error");
-
-        }
-        finally
-        {
-            // Clean up and throw on caught exceptions
+        finally 
+		{
             if (newException != nullptr)
-            {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
-
-                throw newException;
+			{
+				if (newReceiver != nullptr)
+				{
+					delete newReceiver;
+				}
+				else
+				{
+					if (receiverp != NULL)
+					{
+						delete receiverp;
+					}
+				}
             }
         }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
         return newReceiver;
     }
 
 
-    Receiver ^ Session::createReceiver()
+    Receiver ^ Session::CreateReceiver()
     {
         System::Exception           ^ newException = nullptr;
         ::qpid::messaging::Receiver * receiverp    = NULL;
@@ -357,35 +318,33 @@ namespace messaging {
             String ^ errmsg = gcnew String(error.what());
             newException    = gcnew QpidException(errmsg);
         }
-        catch (const std::exception & error) 
-        {
-            String ^ errmsg = gcnew String(error.what());
-            newException    = gcnew QpidException(errmsg);
-        } 
-        catch ( ... )
-        {
-            newException = gcnew QpidException("Session::createReceiver unknown error");
-
-        }
-        finally
-        {
-            // Clean up and throw on caught exceptions
+        finally 
+		{
             if (newException != nullptr)
-            {
-                if (sessionp != NULL)
-                {
-                    delete sessionp;
-                }
-
-                throw newException;
+			{
+				if (newReceiver != nullptr)
+				{
+					delete newReceiver;
+				}
+				else
+				{
+					if (receiverp != NULL)
+					{
+						delete receiverp;
+					}
+				}
             }
         }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
         return newReceiver;
     }
 
 
-    Sender ^ Session::getSender(System::String ^ name)
+    Sender ^ Session::GetSender(System::String ^ name)
     {
         ::qpid::messaging::Sender * sender = new ::qpid::messaging::Sender;
 
@@ -398,7 +357,7 @@ namespace messaging {
 
 
 
-    Receiver ^ Session::getReceiver(System::String ^ name)
+    Receiver ^ Session::GetReceiver(System::String ^ name)
     {
         ::qpid::messaging::Receiver * receiver = new ::qpid::messaging::Receiver;
 
@@ -411,12 +370,12 @@ namespace messaging {
 
 
 
-    Connection ^ Session::getConnection()
+    Connection ^ Session::GetConnection()
     {
         return parentConnectionp;
     }
 
-    void Session::checkError()
+    void Session::CheckError()
     {
         sessionp->checkError();
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.h b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
index 3212f05..babb99d 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
@@ -36,10 +36,10 @@ namespace messaging {
     class SessionImpl {};
 }}
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Session is a managed wrapper for a ::qpid::messaging::Session
@@ -70,15 +70,15 @@ namespace messaging {
         !Session();
         Session(const Session % rhs);
 
-        void close();
-        void commit();
-        void rollback();
-        void acknowledge();
-        void acknowledge(bool sync);
-        void reject(Message ^);
-        void release(Message ^);
-        void sync();
-        void sync(bool block);
+        void Close();
+        void Commit();
+        void Rollback();
+        void Acknowledge();
+        void Acknowledge(bool sync);
+        void Reject(Message ^);
+        void Release(Message ^);
+        void Sync();
+        void Sync(bool block);
 
         property System::UInt32 Receivable
         {
@@ -91,28 +91,28 @@ namespace messaging {
         }
 
         // next(receiver)
-        bool nextReceiver(Receiver ^);
-        bool nextReceiver(Receiver ^, Duration ^ timeout);
+        bool NextReceiver(Receiver ^ rcvr);
+        bool NextReceiver(Receiver ^ rcvr, Duration ^ timeout);
 
         // receiver = next()
-        Receiver ^ nextReceiver();
-        Receiver ^ nextReceiver(Duration ^ timeout);
+        Receiver ^ NextReceiver();
+        Receiver ^ NextReceiver(Duration ^ timeout);
 
 
-        Sender   ^ createSender  (System::String ^ address);
-        Receiver ^ createReceiver(System::String ^ address);
-        Receiver ^ createReceiver();
+        Sender   ^ CreateSender  (System::String ^ address);
+        Receiver ^ CreateReceiver(System::String ^ address);
+        Receiver ^ CreateReceiver();
 
-        Sender   ^ getSender(System::String ^ name);
-        Receiver ^ getReceiver(System::String ^ name);
+        Sender   ^ GetSender(System::String ^ name);
+        Receiver ^ GetReceiver(System::String ^ name);
 
-        Connection ^ getConnection();
+        Connection ^ GetConnection();
 
         property System::Boolean HasError
         {
             System::Boolean get () { return sessionp->hasError(); }
         }
 
-        void checkError();
+        void CheckError();
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
index 3fbe1e2..d463e66 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
@@ -29,10 +29,10 @@
 #include "QpidTypeCheck.h"
 #include "QpidMarshal.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// Translate between managed and native types.
@@ -42,11 +42,12 @@ namespace messaging {
     // The given object is a Dictionary.
     // Add its elements to the qpid map.
     //
-    void TypeTranslator::ManagedToNative(::qpid::types::Variant::Map & theMapp,
-                         QpidMap ^ theObjp)
+    void TypeTranslator::ManagedToNative(QpidMap ^ theDictionary,
+										 ::qpid::types::Variant::Map & qpidMap)
     {
         // iterate the items, converting each to a variant and adding to the map
-        for each (System::Collections::Generic::KeyValuePair<System::String^, System::Object^> kvp in theObjp)
+        for each (System::Collections::Generic::KeyValuePair
+			<System::String^, System::Object^> kvp in theDictionary)
         {
             if (QpidTypeCheck::ObjectIsMap(kvp.Value))
             {
@@ -55,7 +56,7 @@ namespace messaging {
                 ::qpid::types::Variant::Map newMap;
 
                 // Add the map variables to the map
-                ManagedToNative(newMap, (QpidMap ^)kvp.Value);
+                ManagedToNative((QpidMap ^)kvp.Value, newMap);
 
                 // Create a variant entry for the inner map
                 std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
@@ -64,7 +65,7 @@ namespace messaging {
                 std::string entryName = QpidMarshal::ToNative(kvp.Key);
 
                 // Add inner map to outer map
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, *newVariantp));
+                qpidMap.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, *newVariantp));
             }
             else if (QpidTypeCheck::ObjectIsList(kvp.Value))
             {
@@ -73,7 +74,7 @@ namespace messaging {
                 ::qpid::types::Variant::List newList;
 
                 // Add the List variables to the list
-                ManagedToNative(newList, (QpidList ^)kvp.Value);
+                ManagedToNative((QpidList ^)kvp.Value, newList);
 
                 // Create a variant entry for the inner map
                 ::qpid::types::Variant::List newVariant(newList);
@@ -84,7 +85,7 @@ namespace messaging {
                 std::string entryName = QpidMarshal::ToNative(kvp.Key);
 
                 // Add inner list to outer map
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, newVariant));
+                qpidMap.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, newVariant));
             }
             else
             {
@@ -92,7 +93,7 @@ namespace messaging {
                 ::qpid::types::Variant entryValue;
                 ManagedToNativeObject(kvp.Value, entryValue);
                 std::string entryName = QpidMarshal::ToNative(kvp.Key);
-                theMapp.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, entryValue));
+                qpidMap.insert(std::make_pair<std::string, ::qpid::types::Variant>(entryName, entryValue));
             }
         }
     }
@@ -103,11 +104,11 @@ namespace messaging {
     // The given object is a List.
     // Add its elements to the qpid list.
     //
-    void TypeTranslator::ManagedToNative(::qpid::types::Variant::List & theListp,
-                         QpidList ^ theObjp)
+    void TypeTranslator::ManagedToNative(QpidList ^ theList,
+										 ::qpid::types::Variant::List & qpidList)
     {
         // iterate the items, converting each to a variant and adding to the map
-        for each (System::Object ^ listObj in theObjp)
+        for each (System::Object ^ listObj in theList)
         {
             if (QpidTypeCheck::ObjectIsMap(listObj))
             {
@@ -116,13 +117,13 @@ namespace messaging {
                 ::qpid::types::Variant::Map newMap;
 
                 // Add the map variables to the map
-                ManagedToNative(newMap, (QpidMap ^)listObj);
+                ManagedToNative((QpidMap ^)listObj, newMap);
 
                 // Create a variant entry for the inner map
                 std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newMap));
 
                 // Add inner map to outer list
-                theListp.push_back(*newVariantp);
+                qpidList.push_back(*newVariantp);
             }
             else if (QpidTypeCheck::ObjectIsList(listObj))
             {
@@ -131,20 +132,20 @@ namespace messaging {
                 ::qpid::types::Variant::List newList;
 
                 // Add the List variables to the list
-                ManagedToNative(newList, (QpidList ^)listObj);
+                ManagedToNative((QpidList ^)listObj, newList);
 
                 // Create a variant entry for the inner list
                 std::auto_ptr<::qpid::types::Variant> newVariantp(new ::qpid::types::Variant(newList));
 
                 // Add inner list to outer list
-                theListp.push_back(*newVariantp);
+                qpidList.push_back(*newVariantp);
             }
             else
             {
                 // Add a simple native type to list
                 ::qpid::types::Variant entryValue;
                 ManagedToNativeObject(listObj, entryValue);
-                theListp.push_back(entryValue);
+                qpidList.push_back(entryValue);
             }
         }
     }
@@ -155,57 +156,57 @@ namespace messaging {
     // Returns a variant representing simple native type object.
     // Not to be called for Map/List objects.
     //
-    void TypeTranslator::ManagedToNativeObject(System::Object ^ theObjp, 
-                               ::qpid::types::Variant & targetp)
+    void TypeTranslator::ManagedToNativeObject(System::Object ^ managedValue, 
+                               ::qpid::types::Variant & qpidVariant)
     {
-        System::Type     ^ typeP    = (*theObjp).GetType();
+        System::Type     ^ typeP    = (*managedValue).GetType();
         System::TypeCode   typeCode = System::Type::GetTypeCode( typeP );
 
         switch (typeCode)
         {
         case System::TypeCode::Boolean :
-            targetp = System::Convert::ToBoolean(theObjp);
+			qpidVariant = System::Convert::ToBoolean(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Byte :
-            targetp = System::Convert::ToByte(theObjp);
+            qpidVariant = System::Convert::ToByte(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::UInt16 :
-            targetp = System::Convert::ToUInt16(theObjp);
+            qpidVariant = System::Convert::ToUInt16(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::UInt32 :
-            targetp = System::Convert::ToUInt32(theObjp);
+            qpidVariant = System::Convert::ToUInt32(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::UInt64 :
-            targetp = System::Convert::ToUInt64(theObjp);
+            qpidVariant = System::Convert::ToUInt64(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Char :
         case System::TypeCode::SByte :
-            targetp = System::Convert::ToSByte(theObjp);
+            qpidVariant = System::Convert::ToSByte(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Int16 :
-            targetp = System::Convert::ToInt16(theObjp);
+            qpidVariant = System::Convert::ToInt16(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Int32 :
-            targetp = System::Convert::ToInt32(theObjp);
+            qpidVariant = System::Convert::ToInt32(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Int64 :
-            targetp = System::Convert::ToInt64(theObjp);
+            qpidVariant = System::Convert::ToInt64(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Single :
-            targetp = System::Convert::ToSingle(theObjp);
+            qpidVariant = System::Convert::ToSingle(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::Double :
-            targetp = System::Convert::ToDouble(theObjp);
+            qpidVariant = System::Convert::ToDouble(managedValue, System::Globalization::CultureInfo::InvariantCulture);
             break;
 
         case System::TypeCode::String :
@@ -213,10 +214,10 @@ namespace messaging {
                 std::string      rString;
                 System::String ^ rpString;
 
-                rpString = System::Convert::ToString(theObjp);
+                rpString = System::Convert::ToString(managedValue, System::Globalization::CultureInfo::InvariantCulture);
                 rString = QpidMarshal::ToNative(rpString);
-                targetp = rString;
-                targetp.setEncoding(QpidMarshal::ToNative("utf8"));
+                qpidVariant = rString;
+                qpidVariant.setEncoding(QpidMarshal::ToNative("utf8"));
             }
             break;
 
@@ -232,11 +233,12 @@ namespace messaging {
     // Given a user Dictionary and a qpid map,
     //   extract the qpid elements and put them into the dictionary.
     //
-    void TypeTranslator::NativeToManaged(QpidMap ^ dict, ::qpid::types::Variant::Map & map)
+    void TypeTranslator::NativeToManaged(::qpid::types::Variant::Map & qpidMap,
+										 QpidMap ^ dict)
     {
         // For each object in the message map, 
         //  create a .NET object and add it to the dictionary.
-        for (::qpid::types::Variant::Map::const_iterator i = map.begin(); i != map.end(); ++i) {
+        for (::qpid::types::Variant::Map::const_iterator i = qpidMap.begin(); i != qpidMap.end(); ++i) {
             // Get the name
             System::String ^ elementName = gcnew String(i->first.c_str());
 
@@ -299,7 +301,7 @@ namespace messaging {
                 {
                     QpidMap ^ newDict = gcnew QpidMap();
 
-                    NativeToManaged(newDict, variant.asMap());
+                    NativeToManaged(variant.asMap(), newDict);
 
                     dict[elementName] = newDict;
                     break;
@@ -309,7 +311,7 @@ namespace messaging {
                 {
                     QpidList ^ newList = gcnew QpidList();
 
-                    NativeToManaged(newList, variant.asList());
+                    NativeToManaged(variant.asList(), newList);
 
                     dict[elementName] = newList;
                     break;
@@ -322,10 +324,10 @@ namespace messaging {
     }
 
 
-    void TypeTranslator::NativeToManaged(QpidList ^ vList, ::qpid::types::Variant::List & qpidList)
+    void TypeTranslator::NativeToManaged(::qpid::types::Variant::List & qpidList, QpidList ^ managedList)
     {
-        // For each object in the message map, 
-        //  create a .NET object and add it to the dictionary.
+        // For each object in the qpidList 
+        //  create a .NET object and add it to the managed List.
         for (::qpid::types::Variant::List::const_iterator i = qpidList.begin(); i != qpidList.end(); ++i) 
         {
             ::qpid::types::Variant     variant = *i;
@@ -334,62 +336,62 @@ namespace messaging {
             switch (vType)
             {
             case ::qpid::types::VAR_BOOL:
-                (*vList).Add(variant.asBool());
+                (*managedList).Add(variant.asBool());
                 break;
                 
             case ::qpid::types::VAR_UINT8:
-                (*vList).Add(variant.asUint8());
+                (*managedList).Add(variant.asUint8());
                 break;
                 
             case ::qpid::types::VAR_UINT16:
-                (*vList).Add(variant.asUint16());
+                (*managedList).Add(variant.asUint16());
                 break;
                 
             case ::qpid::types::VAR_UINT32:
-                (*vList).Add(variant.asUint32());
+                (*managedList).Add(variant.asUint32());
                 break;
                 
             case ::qpid::types::VAR_UINT64:
-                (*vList).Add(variant.asUint64());
+                (*managedList).Add(variant.asUint64());
                 break;
                 
             case ::qpid::types::VAR_INT8:
-                (*vList).Add(variant.asInt8());
+                (*managedList).Add(variant.asInt8());
                 break;
                 
             case ::qpid::types::VAR_INT16:
-                (*vList).Add(variant.asInt16());
+                (*managedList).Add(variant.asInt16());
                 break;
                 
             case ::qpid::types::VAR_INT32:
-                (*vList).Add(variant.asInt32());
+                (*managedList).Add(variant.asInt32());
                 break;
                 
             case ::qpid::types::VAR_INT64:
-                (*vList).Add(variant.asInt64());
+                (*managedList).Add(variant.asInt64());
                 break;
                 
             case ::qpid::types::VAR_FLOAT:
-                (*vList).Add(variant.asFloat());
+                (*managedList).Add(variant.asFloat());
                 break;
                 
             case ::qpid::types::VAR_DOUBLE:
-                (*vList).Add(variant.asDouble());
+                (*managedList).Add(variant.asDouble());
                 break;
                 
             case ::qpid::types::VAR_STRING:
                 {
                     System::String ^ elementValue = gcnew System::String(variant.asString().c_str());
-                    (*vList).Add(elementValue);
+                    (*managedList).Add(elementValue);
                     break;
                 }
             case ::qpid::types::VAR_MAP:
                 {
                     QpidMap ^ newDict = gcnew QpidMap();
 
-                    NativeToManaged(newDict, variant.asMap());
+                    NativeToManaged(variant.asMap(), newDict);
 
-                    (*vList).Add(newDict);
+                    (*managedList).Add(newDict);
                     break;
                 }
 
@@ -397,9 +399,9 @@ namespace messaging {
                 {
                     QpidList ^ newList = gcnew QpidList();
 
-                    NativeToManaged(newList, variant.asList());
+                    NativeToManaged(variant.asList(), newList);
 
-                    (*vList).Add(newList);
+                    (*managedList).Add(newList);
                     break;
                 }
                 
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
index 7ffba69..df12689 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.h
@@ -28,43 +28,44 @@
 
 #include "QpidTypeCheck.h"
 
-namespace org {
-namespace apache {
-namespace qpid {
-namespace messaging {
+namespace Org {
+namespace Apache {
+namespace Qpid {
+namespace Messaging {
 
     /// <summary>
     /// TypeTranslator provides codec between .NET Dictionary/List and
     /// qpid messaging Map/List.
     /// </summary>
-
-    public ref class TypeTranslator
+    public ref class TypeTranslator sealed
     {
+	private:
+		TypeTranslator::TypeTranslator() {}
 
     public:
-        // The given object is a Dictionary.
+        // The given object is a managed Dictionary.
         // Add its elements to the qpid map.
-        static void ManagedToNative(::qpid::types::Variant::Map & theMapp,
-                                    QpidMap ^ theObjp);
+        static void ManagedToNative(QpidMap ^ theDictionary,
+									::qpid::types::Variant::Map & qpidMap);
 
-        // The given object is a List.
+        // The given object is a managed List.
         // Add its elements to the qpid list.
-        static void ManagedToNative(::qpid::types::Variant::List & theListp,
-                                    QpidList ^ theObjp);
+        static void ManagedToNative(QpidList ^ theList,
+									::qpid::types::Variant::List & qpidList);
 
-        // The given object is a simple native type (not a Dictionary or List)
+        // The given object is a simple managed type (not a Dictionary or List)
         // Returns a variant representing simple native type object.
-        static void ManagedToNativeObject(System::Object ^ theObjp,
-                                          ::qpid::types::Variant & targetp);
+        static void ManagedToNativeObject(System::Object ^ managedValue,
+                                          ::qpid::types::Variant & qpidVariant);
 
-        // Given a Dictionary,
-        // Return its values in a Qpid map
-        static void NativeToManaged(QpidMap ^ dict, 
-                                    ::qpid::types::Variant::Map & map);
+        // The given object is a qpid map.
+        // Add its elements to the managed Dictionary.
+        static void NativeToManaged(::qpid::types::Variant::Map & qpidMap,
+									QpidMap ^ dict);
 
-        // Given a List,
-        // Return its values in a Qpid list
-        static void NativeToManaged(QpidList ^ vList, 
-                                    ::qpid::types::Variant::List & qpidList);
+        // The given object is a qpid list.
+        // Add its elements to the managed List.
+        static void NativeToManaged(::qpid::types::Variant::List & qpidList,
+									QpidList ^ managedList);
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
index 0e47bae..71f051c 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
+++ b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.rc
@@ -69,12 +69,12 @@ BEGIN
     BEGIN
         BLOCK "040904b0"
         BEGIN
-            VALUE "FileDescription", "org"
+            VALUE "FileDescription", "org.apache.qpid.messaging"
             VALUE "FileVersion", "1, 3, 0, 1"
-            VALUE "InternalName", "org"
+            VALUE "InternalName", "org.apache.qpid.messaging"
             VALUE "LegalCopyright", "Copyright (C) 2010"
             VALUE "OriginalFilename", "org.apache.qpid.messaging"
-            VALUE "ProductName", "org"
+            VALUE "ProductName", "org.apache.qpid.messaging"
             VALUE "ProductVersion", "1, 3, 0, 1"
         END
     END
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
index 7c31781..9700b59 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
+++ b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
@@ -2,7 +2,7 @@
 <VisualStudioProject
 	ProjectType="Visual C++"
 	Version="9.00"
-	Name="org.apache.qpid.messaging"
+	Name="Org.Apache.Qpid.Messaging"
 	ProjectGUID="{AA5A3B83-5F98-406D-A01C-5A921467A57D}"
 	RootNamespace="org.apache.qpid.messaging"
 	Keyword="ManagedCProj"
@@ -244,6 +244,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\QpidException.h"
+				>
+			</File>
+			<File
 				RelativePath=".\QpidMarshal.h"
 				>
 			</File>
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
index 57f83ad..19c1ea9 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/Properties/AssemblyInfo.cs
@@ -24,11 +24,11 @@ using System.Runtime.InteropServices;
 // General Information about an assembly is controlled through the following 
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
-[assembly: AssemblyTitle("org.apache.qpid.messaging.sessionreceiver")]
+[assembly: AssemblyTitle("Org.Apache.Qpid.Messaging.SessionReceiver")]
 [assembly: AssemblyDescription("")]
 [assembly: AssemblyConfiguration("")]
 [assembly: AssemblyCompany("")]
-[assembly: AssemblyProduct("org.apache.qpid.messaging.sessionreceiver")]
+[assembly: AssemblyProduct("Org.Apache.Qpid.Messaging.SessionReceiver")]
 [assembly: AssemblyCopyright("Copyright   2010")]
 [assembly: AssemblyTrademark("")]
 [assembly: AssemblyCulture("")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs
index 73956ec..c5a1a7e 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/sessionreceiver.cs
@@ -23,9 +23,9 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
-namespace org.apache.qpid.messaging.sessionreceiver
+namespace Org.Apache.Qpid.Messaging.SessionReceiver
 {
     /// <summary>
     /// ISessionReceiver interface defines the callback for users to supply.
@@ -43,19 +43,19 @@ namespace org.apache.qpid.messaging.sessionreceiver
 
     
     /// <summary>
-    /// eventEngine - wait for messages from the underlying C++ code.
+    /// EventEngine - wait for messages from the underlying C++ code.
     /// When available get them and deliver them via callback to our 
     /// client through the ISessionReceiver interface.
     /// This class consumes the thread that calls the Run() function.
     /// </summary>
 
-    internal class eventEngine
+    internal class EventEngine
     {
         private Session          session;
         private ISessionReceiver callback;
         private bool             keepRunning;
 
-        public eventEngine(Session theSession, ISessionReceiver thecallback)
+        public EventEngine(Session theSession, ISessionReceiver thecallback)
         {
             this.session  = theSession;
             this.callback = thecallback;
@@ -65,35 +65,35 @@ namespace org.apache.qpid.messaging.sessionreceiver
         /// Function to call Session's nextReceiver, discover messages,
         /// and to deliver messages through the callback.
         /// </summary>
-        public void open()
+        public void Open()
         {
-            Receiver rcvr = session.createReceiver();
+            Receiver rcvr = session.CreateReceiver();
             Message  msg;
 
             keepRunning = true;
             while (keepRunning)
             {
-                if (session.nextReceiver(rcvr, DurationConstants.SECOND))
+                if (session.NextReceiver(rcvr, DurationConstants.SECOND))
                 {
                     if (keepRunning)
                     {
-                        msg = rcvr.fetch(DurationConstants.SECOND);
+                        msg = rcvr.Fetch(DurationConstants.SECOND);
                         this.callback.SessionReceiver(rcvr, msg);
                     }
                 }
                 //else
                 //    receive timed out
-                //    eventEngine exits the nextReceiver() function periodically
+                //    EventEngine exits the nextReceiver() function periodically
                 //    in order to test the keepRunning flag
             }
             // Private thread is now exiting.
         }
 
         /// <summary>
-        /// Function to stop the eventEngine. Private thread will exit within
+        /// Function to stop the EventEngine. Private thread will exit within
         /// one second.
         /// </summary>
-        public void close()
+        public void Close()
         {
             keepRunning = false;
         }
@@ -104,9 +104,9 @@ namespace org.apache.qpid.messaging.sessionreceiver
     /// server is the class that users instantiate to connect a SessionReceiver
     /// callback to the stream of received messages received on a Session.
     /// </summary>
-    public class server
+    public class CallbackServer
     {
-        private eventEngine ee;
+        private EventEngine ee;
 
         /// <summary>
         /// Constructor for the server.
@@ -114,20 +114,20 @@ namespace org.apache.qpid.messaging.sessionreceiver
         /// <param name="session">The Session whose messages are collected.</param>
         /// <param name="callback">The user function call with each message.</param>
         /// 
-        public server(Session session, ISessionReceiver callback)
+        public CallbackServer(Session session, ISessionReceiver callback)
         {
-            ee = new eventEngine(session, callback);
+            ee = new EventEngine(session, callback);
 
             new System.Threading.Thread(
-                new System.Threading.ThreadStart(ee.open)).Start();
+                new System.Threading.ThreadStart(ee.Open)).Start();
         }
 
         /// <summary>
         /// Function to stop the server.
         /// </summary>
-        public void close()
+        public void Close()
         {
-            ee.close();
+            ee.Close();
         }
     }
 }
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
index 5d16172..923952b 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
@@ -2,9 +2,9 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
-using org.apache.qpid.messaging;
+using Org.Apache.Qpid.Messaging;
 
-namespace org.apache.qpid.messaging
+namespace Org.Apache.Qpid.Messaging
 {
     class Program
     {
@@ -64,22 +64,22 @@ namespace org.apache.qpid.messaging
 
             Address aType = new Address ("check3", "subj", options, "hot");
 
-            Console.WriteLine("aEmpty : {0}", aEmpty.str());
-            Console.WriteLine("aStr   : {0}", aStr.str());
-            Console.WriteLine("aSubj  : {0}", aSubj.str());
-            Console.WriteLine("aType  : {0}", aType.str());
+            Console.WriteLine("aEmpty : {0}", aEmpty.ToStr());
+            Console.WriteLine("aStr   : {0}", aStr.ToStr());
+            Console.WriteLine("aSubj  : {0}", aSubj.ToStr());
+            Console.WriteLine("aType  : {0}", aType.ToStr());
 
             //
             // Raw message data retrieval
             //
 
             Message m2 = new Message("rarey");
-            UInt64 m2Size = m2.getContentSize();
+            UInt64 m2Size = m2.GetContentSize();
 
 
             byte[] myRaw = new byte [m2Size];
 
-            m2.getRaw(myRaw);
+            m2.GetRaw(myRaw);
             Console.WriteLine("Got raw array size {0}", m2Size);
             for (UInt64 i = 0; i < m2Size; i++)
                 Console.Write("{0} ", myRaw[i].ToString());
-- 
1.7.1.1

From aa84d40e15cbc74803425d2c49c1c0ce1e4ba484 Mon Sep 17 00:00:00 2001
From: Stephen D. Huston <shuston@apache.org>
Date: Fri, 11 Jun 2010 00:52:28 +0000
Subject: [PATCH 059/129] Fix unreferenced variable warnings on Windows build.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953523 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 6315831712123af530943bd9129425c6dc6d7a17)
---
 qpid/cpp/src/qpid/acl/AclData.cpp      |    4 ++--
 qpid/cpp/src/qpid/acl/AclValidator.cpp |    2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/acl/AclData.cpp b/qpid/cpp/src/qpid/acl/AclData.cpp
index a03d5b4..658529b 100644
--- a/qpid/cpp/src/qpid/acl/AclData.cpp
+++ b/qpid/cpp/src/qpid/acl/AclData.cpp
@@ -101,7 +101,7 @@ AclResult AclData::lookup(const std::string& id, const Action& action, const Obj
 
                                                           try{                      
                                                               aclMax = boost::lexical_cast<uint64_t>(pMItr->second);
-                                                          }catch(const boost::bad_lexical_cast& e){
+                                                          }catch(const boost::bad_lexical_cast&){
                                                               match = false;  
                                                               QPID_LOG(error,"Error evaluating rule. " << 
                                                               "Illegal value given in ACL source <" << aclSource <<
@@ -113,7 +113,7 @@ AclResult AclData::lookup(const std::string& id, const Action& action, const Obj
                                         
                                                           try{
                                                               paramMax = boost::lexical_cast<uint64_t>(paramItr->second);
-                                                          }catch(const boost::bad_lexical_cast& e){
+                                                          }catch(const boost::bad_lexical_cast&){
                                                               match = false;
                                                               QPID_LOG(error,"Error evaluating rule. " <<
                                                               "Illegal value given in lookup for property '" <<  
diff --git a/qpid/cpp/src/qpid/acl/AclValidator.cpp b/qpid/cpp/src/qpid/acl/AclValidator.cpp
index aeaf638..57b68e5 100644
--- a/qpid/cpp/src/qpid/acl/AclValidator.cpp
+++ b/qpid/cpp/src/qpid/acl/AclValidator.cpp
@@ -37,7 +37,7 @@ bool AclValidator::IntPropertyType::validate(const std::string& val) {
   try
   {
     v = boost::lexical_cast<int64_t>(val);
-  }catch(const boost::bad_lexical_cast& e){
+  }catch(const boost::bad_lexical_cast&){
     return 0;
   }
 
-- 
1.7.1.1

From e2f488f7e8257ffb3ace8ba414d21784e625d3e2 Mon Sep 17 00:00:00 2001
From: Stephen D. Huston <shuston@apache.org>
Date: Fri, 11 Jun 2010 00:59:41 +0000
Subject: [PATCH 060/129] Refer to struct Url as that, not a class - fixes compile warnings on Windows.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@953526 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 5a8d36c5bfb045876b21da5864ee747e80a1d1f6)
---
 qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h
index f32a075..904cef7 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h
+++ b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h
@@ -31,7 +31,7 @@
 #include <vector>
 
 namespace qpid {
-class Url;
+struct Url;
 
 namespace client {
 namespace amqp0_10 {
-- 
1.7.1.1

From a74bf473f490b7c7cdca1ad865261f7d82255e2a Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@redhat.com>
Date: Mon, 14 Jun 2010 15:12:58 -0400
Subject: [PATCH 061/129] Revert "QPID-2617: Fix the windows build for modified method signature"

This reverts commit 512db9306e1ac6cf8f05f7a646d36f282f88293e.
---
 .../src/qpid/broker/windows/SaslAuthenticator.cpp  |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp b/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
index 608a8f7..642be29 100644
--- a/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
+++ b/qpid/cpp/src/qpid/broker/windows/SaslAuthenticator.cpp
@@ -68,7 +68,7 @@ bool SaslAuthenticator::available(void)
 }
 
 // Initialize the SASL mechanism; throw if it fails.
-void SaslAuthenticator::init(const std::string& /*saslName*/, const std::string& /*saslConfig*/)
+void SaslAuthenticator::init(const std::string& /*saslName*/)
 {
     return;
 }
-- 
1.7.1.1

From a1cdf640e11415c3376c3e420d40113d2bcc723a Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 15 Jun 2010 15:34:10 +0000
Subject: [PATCH 062/129] Bug 603839 - Fixed - Concurrent tagging of message with trace id while message is delivered from another queue causes segfault

QPID-2670: copy-on-write when tagging message for loop detection

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954933 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit a3ba0d75d20cc5f08bd06046f2eba29650980c40)
---
 qpid/cpp/src/qpid/broker/Message.cpp   |    6 ++++++
 qpid/cpp/src/qpid/broker/Message.h     |    1 +
 qpid/cpp/src/qpid/broker/Queue.cpp     |   13 ++++++++++---
 qpid/cpp/src/qpid/broker/Queue.h       |    2 +-
 qpid/cpp/src/qpid/framing/FrameSet.cpp |   10 ++++++++++
 qpid/cpp/src/qpid/framing/FrameSet.h   |    1 +
 6 files changed, 29 insertions(+), 4 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Message.cpp b/qpid/cpp/src/qpid/broker/Message.cpp
index b086d59..1e56544 100644
--- a/qpid/cpp/src/qpid/broker/Message.cpp
+++ b/qpid/cpp/src/qpid/broker/Message.cpp
@@ -52,6 +52,12 @@ Message::Message(const framing::SequenceNumber& id) :
     expiration(FAR_FUTURE), enqueueCallback(0), dequeueCallback(0),
     inCallback(false), requiredCredit(0) {}
 
+Message::Message(const Message& original) :
+    PersistableMessage(), frames(original.frames), persistenceId(0), redelivered(false), loaded(false),
+    staged(false), forcePersistentPolicy(false), publisher(0), adapter(0), 
+    expiration(FAR_FUTURE), enqueueCallback(0), dequeueCallback(0),
+    inCallback(false), requiredCredit(0) {}
+
 Message::~Message()
 {
     if (expiryPolicy)
diff --git a/qpid/cpp/src/qpid/broker/Message.h b/qpid/cpp/src/qpid/broker/Message.h
index 4330a03..ee80657 100644
--- a/qpid/cpp/src/qpid/broker/Message.h
+++ b/qpid/cpp/src/qpid/broker/Message.h
@@ -53,6 +53,7 @@ public:
     typedef boost::function<void (const boost::intrusive_ptr<Message>&)> MessageCallback;
     
     QPID_BROKER_EXTERN Message(const framing::SequenceNumber& id = framing::SequenceNumber());
+    QPID_BROKER_EXTERN Message(const Message&);
     QPID_BROKER_EXTERN ~Message();
         
     uint64_t getPersistenceId() const { return persistenceId; }
diff --git a/qpid/cpp/src/qpid/broker/Queue.cpp b/qpid/cpp/src/qpid/broker/Queue.cpp
index 8c9e5b8..7f7b2bc 100644
--- a/qpid/cpp/src/qpid/broker/Queue.cpp
+++ b/qpid/cpp/src/qpid/broker/Queue.cpp
@@ -216,7 +216,8 @@ void Queue::requeue(const QueuedMessage& msg){
         if(inLastNodeFailure && persistLastNode && !msg.payload->isStoredOnQueue(shared_from_this())) {
             msg.payload->forcePersistent();
             if (msg.payload->isForcedPersistent() ){
-            	enqueue(0, msg.payload);
+                boost::intrusive_ptr<Message> payload = msg.payload;
+            	enqueue(0, payload);
             }
         }
     }
@@ -720,7 +721,7 @@ void Queue::setLastNodeFailure()
 
 
 // return true if store exists, 
-bool Queue::enqueue(TransactionContext* ctxt, boost::intrusive_ptr<Message> msg, bool suppressPolicyCheck)
+bool Queue::enqueue(TransactionContext* ctxt, boost::intrusive_ptr<Message>& msg, bool suppressPolicyCheck)
 {
     ScopedUse u(barrier);
     if (!u.acquired) return false;
@@ -741,6 +742,11 @@ bool Queue::enqueue(TransactionContext* ctxt, boost::intrusive_ptr<Message> msg,
     }
        
     if (traceId.size()) {
+        //copy on write: take deep copy of message before modifying it
+        //as the frames may already be available for delivery on other
+        //threads
+        boost::intrusive_ptr<Message> copy(new Message(*msg));
+        msg = copy;
         msg->addTraceId(traceId);
     }
 
@@ -1158,7 +1164,8 @@ void Queue::enqueued(const QueuedMessage& m)
             policy->enqueued(m);
         }
         mgntEnqStats(m.payload);
-        enqueue ( 0, m.payload, true );
+        boost::intrusive_ptr<Message> payload = m.payload;
+        enqueue ( 0, payload, true );
     } else {
         QPID_LOG(warning, "Queue informed of enqueued message that has no payload");
     }
diff --git a/qpid/cpp/src/qpid/broker/Queue.h b/qpid/cpp/src/qpid/broker/Queue.h
index cdfa8a1..ebef6e4 100644
--- a/qpid/cpp/src/qpid/broker/Queue.h
+++ b/qpid/cpp/src/qpid/broker/Queue.h
@@ -260,7 +260,7 @@ namespace qpid {
             QPID_BROKER_EXTERN void setLastNodeFailure();
             QPID_BROKER_EXTERN void clearLastNodeFailure();
 
-            bool enqueue(TransactionContext* ctxt, boost::intrusive_ptr<Message> msg, bool suppressPolicyCheck = false);
+            bool enqueue(TransactionContext* ctxt, boost::intrusive_ptr<Message>& msg, bool suppressPolicyCheck = false);
             void enqueueAborted(boost::intrusive_ptr<Message> msg);
             /**
              * dequeue from store (only done once messages is acknowledged)
diff --git a/qpid/cpp/src/qpid/framing/FrameSet.cpp b/qpid/cpp/src/qpid/framing/FrameSet.cpp
index c03dd39..255aaf6 100644
--- a/qpid/cpp/src/qpid/framing/FrameSet.cpp
+++ b/qpid/cpp/src/qpid/framing/FrameSet.cpp
@@ -29,6 +29,16 @@ using namespace qpid::framing;
 using namespace boost;
 
 FrameSet::FrameSet(const SequenceNumber& _id) : id(_id),contentSize(0),recalculateSize(true) { }
+FrameSet::FrameSet(const FrameSet& original) : id(original.id), contentSize(0), recalculateSize(true)
+{
+    for (Frames::const_iterator i = original.begin(); i != original.end(); ++i) {
+        parts.push_back(AMQFrame(*(i->getBody())));
+        parts.back().setFirstSegment(i->isFirstSegment());
+        parts.back().setLastSegment(i->isLastSegment());
+        parts.back().setFirstFrame(i->isFirstFrame());
+        parts.back().setLastFrame(i->isLastFrame());
+    }
+}
 
 void FrameSet::append(const AMQFrame& part)
 {
diff --git a/qpid/cpp/src/qpid/framing/FrameSet.h b/qpid/cpp/src/qpid/framing/FrameSet.h
index 398a709..cae75e5 100644
--- a/qpid/cpp/src/qpid/framing/FrameSet.h
+++ b/qpid/cpp/src/qpid/framing/FrameSet.h
@@ -46,6 +46,7 @@ public:
     typedef boost::shared_ptr<FrameSet> shared_ptr;
 
     QPID_COMMON_EXTERN FrameSet(const SequenceNumber& id);
+    QPID_COMMON_EXTERN FrameSet(const FrameSet&);
     QPID_COMMON_EXTERN void append(const AMQFrame& part);
     QPID_COMMON_EXTERN bool isComplete() const;
 
-- 
1.7.1.1

From abf93417bf2083fdb56ed2cb5e0be50e34d52860 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 16 Jun 2010 18:25:30 +0000
Subject: [PATCH 063/129] Bug 602198 - Fix part 1 - qpidd crashes when testing heartbeats

remove assertion for condition that is in fact valid (the callback could have been processed on the back of an event concurrently returned with the interrupt request)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@955339 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 66ea76a8dfe6a1833a1049bfdbc472e9102d6d9f)
---
 qpid/cpp/src/qpid/sys/DispatchHandle.cpp |    2 --
 1 files changed, 0 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/DispatchHandle.cpp b/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
index 605edab..95da87a 100644
--- a/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
+++ b/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
@@ -291,8 +291,6 @@ void DispatchHandle::processEvent(Poller::EventType type) {
         break;
     case Poller::INTERRUPTED:
         {
-        // We could only be interrupted if we also had a callback to do
-        assert(callbacks.size() > 0);
         // We'll actually do the interrupt below
         }
         break;
-- 
1.7.1.1

From eb748c3ccbb31c0567b6b7dfcd47e106dddd1e40 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@redhat.com>
Date: Wed, 16 Jun 2010 14:46:19 -0400
Subject: [PATCH 064/129] Bug 602198 - Fix part 2 - qpidd crashes when testing heartbeats

Prevent 'interrupt' callback on object already deleted.
---
 qpid/cpp/src/qpid/sys/DispatchHandle.cpp |   10 ++++++++++
 1 files changed, 10 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/DispatchHandle.cpp b/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
index 95da87a..cd9bfd0 100644
--- a/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
+++ b/qpid/cpp/src/qpid/sys/DispatchHandle.cpp
@@ -302,12 +302,22 @@ void DispatchHandle::processEvent(Poller::EventType type) {
     // (because we use a copy from before the previous callbacks we won't
     //  do anything yet that was just added) 
     while (callbacks.size() > 0) {
+        {
+        ScopedLock<Mutex> lock(stateLock);
+        switch (state) {
+        case DELETING:
+            goto finishcallbacks;
+        default:
+            break;
+        }
+        }
         Callback cb = callbacks.front();
         assert(cb);
         cb(*this);
         callbacks.pop();
     }
 
+finishcallbacks:
     {
     ScopedLock<Mutex> lock(stateLock);
     switch (state) {
-- 
1.7.1.1

From 38ce79eee4d48e2be75c6d74ded2c383fba5810c Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Tue, 15 Jun 2010 10:11:39 +0000
Subject: [PATCH 065/129] BZ-567249 added back values method for backwards compatibility

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954787 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/ops.py |    9 +++++++--
 1 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/qpid/python/qpid/ops.py b/qpid/python/qpid/ops.py
index acb54ae..8c9f8a0 100644
--- a/qpid/python/qpid/ops.py
+++ b/qpid/python/qpid/ops.py
@@ -16,14 +16,19 @@
 # specific language governing permissions and limitations
 # under the License.
 #
-import os, mllib, cPickle as pickle
+import os, mllib, cPickle as pickle, sys
 from util import fill
 
 class Primitive(object):
   pass
 
 class Enum(object):
-  pass
+
+  # XXX: for backwards compatibility
+  @classmethod
+  def values(cls):
+    print >> sys.stderr, "warning, please use .VALUES instead of .values()"
+    return cls.VALUES
 
 class Field:
 
-- 
1.7.1.1

From 4e05457ddfe178ac4cfa55bb1dcd6986c272e500 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Tue, 15 Jun 2010 14:13:15 +0000
Subject: [PATCH 066/129] BZ-567249 fix for python 2.3

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954901 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/ops.py |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/qpid/python/qpid/ops.py b/qpid/python/qpid/ops.py
index 8c9f8a0..390552b 100644
--- a/qpid/python/qpid/ops.py
+++ b/qpid/python/qpid/ops.py
@@ -25,10 +25,12 @@ class Primitive(object):
 class Enum(object):
 
   # XXX: for backwards compatibility
-  @classmethod
   def values(cls):
     print >> sys.stderr, "warning, please use .VALUES instead of .values()"
     return cls.VALUES
+  # we can't use the backport preprocessor here because this code gets
+  # called by setup.py
+  values = classmethod(values)
 
 class Field:
 
-- 
1.7.1.1

From b0ae853c18fad859d5e7daabcb0598ab2d197ea6 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Wed, 16 Jun 2010 16:47:18 +0000
Subject: [PATCH 067/129] BZ-596677 performance tweaks for receive: added configurable threshold for issuing credit; don't disable byte credit more than necessary; avoided n-squared loop for generating acks

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@955296 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py    |   19 ++++++++++++++++---
 qpid/python/qpid/messaging/endpoints.py |    7 +++++--
 2 files changed, 21 insertions(+), 5 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 8463aea..16f1b29 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -208,6 +208,7 @@ class LinkIn:
     _rcv.destination = str(rcv.id)
     sst.destinations[_rcv.destination] = _rcv
     _rcv.draining = False
+    _rcv.bytes_open = False
     _rcv.on_unlink = []
 
   def do_link(self, sst, rcv, _rcv, type, subtype, action):
@@ -762,6 +763,7 @@ class Engine:
       sst.write_op(SessionCommandPoint(sst.sent, 0))
       sst.outgoing_idx = 0
       sst.acked = []
+      sst.acked_idx = 0
       if ssn.transactional:
         sst.write_cmd(TxSelect())
       self._attachments[ssn] = sst
@@ -965,7 +967,8 @@ class Engine:
       self.process_receiver(rcv)
 
     if ssn.acked:
-      messages = [m for m in ssn.acked if m not in sst.acked]
+      messages = ssn.acked[sst.acked_idx:]
+      delta = len(messages)
       if messages:
         ids = RangedSet()
 
@@ -975,6 +978,7 @@ class Engine:
           # could we deal this via some message-id based purge?
           if m._transfer_id is None:
             ssn.acked.remove(m)
+            delta -= 1
             continue
           ids.add(m._transfer_id)
           disp = m._disposition or DEFAULT_DISPOSITION
@@ -992,6 +996,7 @@ class Engine:
           def ack_ack():
             for m in msgs:
               ssn.acked.remove(m)
+              sst.acked_idx -= 1
               if not ssn.transactional:
                 sst.acked.remove(m)
           return ack_ack
@@ -1011,7 +1016,9 @@ class Engine:
             for m in msgs:
               log.debug("SACK[%s]: %s, %s", ssn.log_id, m, m._disposition)
 
+        # XXX: could add messages with _transfer_id of None
         sst.acked.extend(messages)
+        sst.acked_idx += delta
 
     if ssn.committing and not sst.committing:
       def commit_ok():
@@ -1076,11 +1083,15 @@ class Engine:
       delta = max(rcv.granted, rcv.received) - rcv.impending
 
     if delta is UNLIMITED:
-      sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.byte, UNLIMITED.value))
+      if not _rcv.bytes_open:
+        sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.byte, UNLIMITED.value))
+        _rcv.bytes_open = True
       sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.message, UNLIMITED.value))
       rcv.impending = UNLIMITED
     elif delta > 0:
-      sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.byte, UNLIMITED.value))
+      if not _rcv.bytes_open:
+        sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.byte, UNLIMITED.value))
+        _rcv.bytes_open = True
       sst.write_cmd(MessageFlow(_rcv.destination, credit_unit.message, delta))
       rcv.impending += delta
     elif delta < 0 and not rcv.draining:
@@ -1088,6 +1099,7 @@ class Engine:
       def do_stop():
         rcv.impending = rcv.received
         _rcv.draining = False
+        _rcv.bytes_open = False
         self.grant(rcv)
       sst.write_cmd(MessageStop(_rcv.destination), do_stop)
 
@@ -1097,6 +1109,7 @@ class Engine:
         rcv.impending = rcv.received
         rcv.granted = rcv.impending
         _rcv.draining = False
+        _rcv.bytes_open = False
         rcv.draining = False
       sst.write_cmd(MessageFlush(_rcv.destination), do_flush)
 
diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index f5f957c..707aee3 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -29,6 +29,7 @@ Areas that still need work:
 """
 
 from logging import getLogger
+from math import ceil
 from qpid.codec010 import StringCodec
 from qpid.concurrency import synchronized, Waiter, Condition
 from qpid.datatypes import Serial, uuid4
@@ -843,6 +844,7 @@ class Receiver(object):
     self._lock = self.session._lock
     self._capacity = 0
     self._set_capacity(options.get("capacity", 0), False)
+    self.threshold = 0.5
 
   @synchronized
   def _set_capacity(self, c, wakeup=True):
@@ -931,8 +933,9 @@ class Receiver(object):
       if msg is None:
         raise Empty()
     elif self._capacity not in (0, UNLIMITED.value):
-      self.granted += 1
-      self._wakeup()
+      if self.received - self.returned <= int(ceil(self.threshold * self._capacity)):
+        self.granted = self.received + self._capacity
+        self._wakeup()
     return msg
 
   def _grant(self):
-- 
1.7.1.1

From c8e4559e0a26efe70e3a462f8e49a4bd55ba46a2 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@redhat.com>
Date: Tue, 15 Jun 2010 15:52:51 -0400
Subject: [PATCH 068/129] Bug 603835 - cluster_tests.test_management failing.

Clean up connections causing extra connection objects in the mangement agent map.
- update connection was not being closed.
- connections belonging to members that left the cluster were not fully cleaned up

Also fixed test errors making failover_soak fail sporadically.

Corresponds to trunk r955370
---
 qpid/cpp/src/qpid/cluster/Cluster.cpp           |    3 +-
 qpid/cpp/src/qpid/cluster/Connection.cpp        |   47 +++++++++++++---------
 qpid/cpp/src/qpid/cluster/Connection.h          |    5 ++-
 qpid/cpp/src/qpid/cluster/OutputInterceptor.cpp |    2 +-
 qpid/cpp/src/qpid/cluster/UpdateClient.cpp      |   22 ++++++----
 qpid/cpp/src/tests/failover_soak.cpp            |   12 +++--
 6 files changed, 54 insertions(+), 37 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Cluster.cpp b/qpid/cpp/src/qpid/cluster/Cluster.cpp
index 6b9fcec..bc47e0b 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.cpp
+++ b/qpid/cpp/src/qpid/cluster/Cluster.cpp
@@ -361,7 +361,6 @@ void Cluster::erase(const ConnectionId& id) {
 
 // Called by Connection::deliverClose() in deliverFrameQueue thread.
 void Cluster::erase(const ConnectionId& id, Lock&) {
-    QPID_LOG(info, *this << " connection closed " << id);
     connections.erase(id);
     decoder.erase(id);
 }
@@ -1022,7 +1021,7 @@ void Cluster::memberUpdate(Lock& l) {
         ConnectionMap::iterator j = i++;
         MemberId m = j->second->getId().getMember();
         if (m != self && !map.isMember(m)) {
-            j->second->getBrokerConnection().closed();
+            j->second->close();
             erase(j->second->getId(), l);
         }
     }
diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index c402415..a2d1cc8 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -101,19 +101,18 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
     if (isLocalClient()) {
         // Local clients are announced to the cluster
         // and initialized when the announce is received.
-        QPID_LOG(info, "new client connection " << *this);
         giveReadCredit(cluster.getSettings().readMax); // Flow control
         init();
     }
     else {
         // Catch-up shadow connections initialized using nextShadow id.
         assert(catchUp);
-        QPID_LOG(info, "new catch-up connection " << *this);
-        connectionCtor.mgmtId = updateIn.nextShadowMgmtId;
+        if (!updateIn.nextShadowMgmtId.empty())
+            connectionCtor.mgmtId = updateIn.nextShadowMgmtId;
         updateIn.nextShadowMgmtId.clear();
         init();
     }
-
+    QPID_LOG(info, "incoming connection " << *this);
 }
 
 void Connection::setSecureConnection(broker::SecureConnection* sc) {
@@ -123,8 +122,6 @@ void Connection::setSecureConnection(broker::SecureConnection* sc) {
 
 void Connection::init() {
     connection = connectionCtor.construct();
-    QPID_LOG(debug, cluster << " initialized connection: " << *this
-             << " ssf=" << connection->getExternalSecuritySettings().ssf);
     if (isLocalClient()) {
         if (secureConnection) connection->setSecureConnection(secureConnection);
         // Actively send cluster-order frames from local node
@@ -171,7 +168,6 @@ void Connection::announce(
 
 Connection::~Connection() {
     if (connection.get()) connection->setErrorListener(0);
-    QPID_LOG(debug, cluster << " deleted connection: " << *this);
 }
 
 bool Connection::doOutput() {
@@ -250,16 +246,15 @@ void Connection::deliveredFrame(const EventFrame& f) {
 // A local connection is closed by the network layer.
 void Connection::closed() {
     try {
-        if (catchUp) {
+        if (isUpdated()) {
+            QPID_LOG(debug, cluster << " update connection closed " << *this);
+            close();
+        }
+        else if (catchUp) {
             QPID_LOG(critical, cluster << " catch-up connection closed prematurely " << *this);
             cluster.leave();
         }
-        else if (isUpdated()) {
-            QPID_LOG(debug, cluster << " closed update connection " << *this);
-            if (connection.get()) connection->closed();
-        }
         else if (isLocal()) {
-            QPID_LOG(debug, cluster << " local close of replicated connection " << *this);
             // This was a local replicated connection. Multicast a deliver
             // closed and process any outstanding frames from the cluster
             // until self-delivery of deliver-close.
@@ -275,15 +270,20 @@ void Connection::closed() {
 // Self-delivery of close message, close the connection.
 void Connection::deliverClose () {
     assert(!catchUp);
+    close();
+    cluster.erase(self);
+}
+
+// Close the connection
+void Connection::close() {
     if (connection.get()) {
         connection->closed();
         // Ensure we delete the broker::Connection in the deliver thread.
         connection.reset();
     }
-    cluster.erase(self);
 }
 
-// The connection has been killed for misbehaving
+// The connection has been killed for misbehaving, called in connection thread.
 void Connection::abort() {
     if (connection.get()) {
         connection->abort();
@@ -424,7 +424,7 @@ void Connection::shadowReady(
     uint64_t memberId, uint64_t connectionId, const string& mgmtId,
     const string& username, const string& fragment, uint32_t sendMax)
 {
-    QPID_ASSERT(mgmtId == getBrokerConnection().getMgmtId());
+    QPID_ASSERT(mgmtId == getBrokerConnection()->getMgmtId());
     ConnectionId shadowId = ConnectionId(memberId, connectionId);
     QPID_LOG(debug, cluster << " catch-up connection " << *this
              << " becomes shadow " << shadowId);
@@ -442,13 +442,19 @@ void Connection::membership(const FieldTable& joiners, const FieldTable& members
     QPID_LOG(debug, cluster << " incoming update complete on connection " << *this);
     cluster.updateInDone(ClusterMap(joiners, members, frameSeq));
     updateIn.consumerNumbering.clear();
-    self.second = 0;        // Mark this as completed update connection.
+    closeUpdated();
 }
 
 void Connection::retractOffer() {
     QPID_LOG(info, cluster << " incoming update retracted on connection " << *this);
     cluster.updateInRetracted();
-    self.second = 0;        // Mark this as completed update connection.
+    closeUpdated();
+}
+
+void Connection::closeUpdated() {
+    self.second = 0;      // Mark this as completed update connection.
+    if (connection.get())
+        connection->close(connection::CLOSE_CODE_NORMAL, "OK");
 }
 
 bool Connection::isLocal() const {
@@ -527,7 +533,10 @@ std::ostream& operator<<(std::ostream& o, const Connection& c) {
     if (c.isLocal()) type = "local";
     else if (c.isShadow()) type = "shadow";
     else if (c.isUpdated()) type = "updated";
-    return o << c.getId() << "(" << type << (c.isCatchUp() ? ",catchup" : "") << ")";
+    const broker::Connection* bc = c.getBrokerConnection();
+    if (bc) o << bc->getMgmtId();
+    else o << "<disconnected>";
+    return o << "(" << c.getId() << " " << type << (c.isCatchUp() ? ",catchup":"") << ")";
 }
 
 void Connection::txStart() {
diff --git a/qpid/cpp/src/qpid/cluster/Connection.h b/qpid/cpp/src/qpid/cluster/Connection.h
index 70c4d0e..45d832a 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.h
+++ b/qpid/cpp/src/qpid/cluster/Connection.h
@@ -75,7 +75,8 @@ class Connection :
     ~Connection();
     
     ConnectionId getId() const { return self; }
-    broker::Connection& getBrokerConnection() { return *connection; }
+    broker::Connection* getBrokerConnection() { return connection.get(); }
+    const broker::Connection* getBrokerConnection() const { return connection.get(); }
 
     /** Local connections may be clients or catch-up connections */
     bool isLocal() const;
@@ -167,6 +168,7 @@ class Connection :
     void announce(const std::string& mgmtId, uint32_t ssf, const std::string& authid,
                   bool nodict, const std::string& username,
                   const std::string& initFrames);
+    void close();
     void abort();
     void deliverClose();
 
@@ -227,6 +229,7 @@ class Connection :
     broker::SessionState& sessionState();
     broker::SemanticState& semanticState();
     broker::QueuedMessage getUpdateMessage();
+    void closeUpdated();
 
     Cluster& cluster;
     ConnectionId self;
diff --git a/qpid/cpp/src/qpid/cluster/OutputInterceptor.cpp b/qpid/cpp/src/qpid/cluster/OutputInterceptor.cpp
index f80eb9c..1354dab 100644
--- a/qpid/cpp/src/qpid/cluster/OutputInterceptor.cpp
+++ b/qpid/cpp/src/qpid/cluster/OutputInterceptor.cpp
@@ -83,7 +83,7 @@ void OutputInterceptor::deliverDoOutput(uint32_t limit) {
             newLimit = (sendMax + sent) / 2;
     }
     sent = 0;
-    while (sent < limit && parent.getBrokerConnection().doOutput())
+    while (sent < limit && parent.getBrokerConnection()->doOutput())
         ++sent;
     if (sent == limit) sendDoOutput(newLimit);
 }
diff --git a/qpid/cpp/src/qpid/cluster/UpdateClient.cpp b/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
index 6499519..90f5bcf 100644
--- a/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
+++ b/qpid/cpp/src/qpid/cluster/UpdateClient.cpp
@@ -150,7 +150,8 @@ void UpdateClient::update() {
     // longer on their original queue.
     session.queueDeclare(arg::queue=UPDATE, arg::autoDelete=true);
     session.sync();
-    std::for_each(connections.begin(), connections.end(), boost::bind(&UpdateClient::updateConnection, this, _1));
+    std::for_each(connections.begin(), connections.end(),
+                  boost::bind(&UpdateClient::updateConnection, this, _1));
     session.queueDelete(arg::queue=UPDATE);
     session.close();
 
@@ -167,15 +168,18 @@ void UpdateClient::update() {
     client::ConnectionAccess::getImpl(connection)->expand(frame.encodedSize(), false);
     client::ConnectionAccess::getImpl(connection)->handle(frame);
 
-    connection.close();
-    QPID_LOG(debug,  updaterId << " update completed to " << updateeId
-             << " at " << updateeUrl << ": " << membership);
+    // FIXME aconway 2010-06-16: Connection will be closed from the other end.
+    // connection.close();
+
     // FIXME aconway 2010-03-15: This sleep avoids the race condition
     // described in // https://bugzilla.redhat.com/show_bug.cgi?id=568831.
     // It allows the connection to fully close before destroying the
     // Connection object. Remove when the bug is fixed.
     //
-    sys::usleep(10*1000);       // 100ms
+    sys::usleep(10*1000);
+
+    QPID_LOG(debug,  updaterId << " update completed to " << updateeId
+             << " at " << updateeUrl << ": " << membership);
 }
 
 namespace {
@@ -347,9 +351,11 @@ void UpdateClient::updateOutputTask(const sys::OutputTask* task) {
 
 void UpdateClient::updateConnection(const boost::intrusive_ptr<Connection>& updateConnection) {
     QPID_LOG(debug, updaterId << " updating connection " << *updateConnection);
+    assert(updateConnection->getBrokerConnection());
+    broker::Connection& bc = *updateConnection->getBrokerConnection();
 
     // Send the management ID first on the main connection.
-    std::string mgmtId = updateConnection->getBrokerConnection().getMgmtId();
+    std::string mgmtId = updateConnection->getBrokerConnection()->getMgmtId();
     ClusterConnectionProxy(session).shadowPrepare(mgmtId);
     // Make sure its received before opening shadow connection
     session.sync();
@@ -357,7 +363,6 @@ void UpdateClient::updateConnection(const boost::intrusive_ptr<Connection>& upda
     // Open shadow connection and update it.
     shadowConnection = catchUpConnection();
 
-    broker::Connection& bc = updateConnection->getBrokerConnection();
     connectionSettings.maxFrameSize = bc.getFrameMax();
     shadowConnection.open(updateeUrl, connectionSettings);
     bc.eachSessionHandler(boost::bind(&UpdateClient::updateSession, this, _1));
@@ -381,8 +386,7 @@ void UpdateClient::updateSession(broker::SessionHandler& sh) {
     broker::SessionState* ss = sh.getSession();
     if (!ss) return;            // no session.
 
-    QPID_LOG(debug, updaterId << " updating session " << &sh.getConnection()
-             << "[" << sh.getChannel() << "] = " << ss->getId());
+    QPID_LOG(debug, updaterId << " updating session " << ss->getId());
 
     // Create a client session to update session state. 
     boost::shared_ptr<client::ConnectionImpl> cimpl = client::ConnectionAccess::getImpl(shadowConnection);
diff --git a/qpid/cpp/src/tests/failover_soak.cpp b/qpid/cpp/src/tests/failover_soak.cpp
index cd7aaa6..058f59e 100644
--- a/qpid/cpp/src/tests/failover_soak.cpp
+++ b/qpid/cpp/src/tests/failover_soak.cpp
@@ -464,11 +464,12 @@ runDeclareQueuesClient ( brokerVector brokers,
              << endl;
     stringstream portSs;
     portSs << port;
+    string portS(portSs.str());
 
     vector<const char*> argv;
     argv.push_back ( "declareQueues" );
     argv.push_back ( host );
-    argv.push_back ( portSs.str().c_str() );
+    argv.push_back ( portS.c_str() );
     if ( durable )
       argv.push_back ( "1" );
     else
@@ -672,7 +673,7 @@ main ( int argc, char const ** argv )
      // Get prefix for each queue name.
      stringstream queue_prefix;
      queue_prefix << "failover_soak_" << getpid();
-
+     string queue_prefix_str(queue_prefix.str());
 
      // Run the declareQueues child.
      int childStatus;
@@ -682,7 +683,7 @@ main ( int argc, char const ** argv )
                               declareQueuesPath, 
                               verbosity, 
                               durable,
-                              queue_prefix.str().c_str(),
+                              queue_prefix_str.c_str(),
                               n_queues
                             );
      if ( -1 == dqClientPid ) {
@@ -706,6 +707,7 @@ main ( int argc, char const ** argv )
 
          stringstream queue_name;
          queue_name << queue_prefix.str() << '_' << i;
+         string queue_name_str(queue_name.str());
 
          // Receiving client ---------------------------
          pid_t receivingClientPid =
@@ -714,7 +716,7 @@ main ( int argc, char const ** argv )
                                   receiverPath,
                                   reportFrequency,
                                   verbosity,
-                                  queue_name.str().c_str() );
+                                  queue_name_str.c_str() );
          if ( -1 == receivingClientPid ) {
              cerr << "END_OF_TEST ERROR_START_RECEIVER\n";
              return CANT_FORK_RECEIVER;
@@ -730,7 +732,7 @@ main ( int argc, char const ** argv )
                                 reportFrequency,
                                 verbosity,
                                 durable,
-                                queue_name.str().c_str() );
+                                queue_name_str.c_str() );
          if ( -1 == sendingClientPid ) {
              cerr << "END_OF_TEST ERROR_START_SENDER\n";
              return CANT_FORK_SENDER;
-- 
1.7.1.1

From e1c3a645453c2796b67625a1e00341894777f223 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Wed, 16 Jun 2010 22:15:14 +0000
Subject: [PATCH 069/129] BZ-574817 don't always set the sync bit on send

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@955414 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py    |   14 ++++++++++----
 qpid/python/qpid/messaging/endpoints.py |   25 +++++++++++++++++++++----
 2 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 16f1b29..a6170c0 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -114,6 +114,7 @@ class SessionState:
     self.min_completion = self.sent
     self.max_completion = self.sent
     self.results = {}
+    self.need_sync = False
 
     # receiver state
     self.received = None
@@ -131,12 +132,12 @@ class SessionState:
     for k, v in overrides.items():
       cmd[k.replace('-', '_')] = v
 
-  def write_cmd(self, cmd, action=noop, overrides=None):
+  def write_cmd(self, cmd, action=noop, overrides=None, sync=True):
     if overrides:
       self.apply_overrides(cmd, overrides)
 
-    if action != noop:
-      cmd.sync = True
+    if sync or action != noop:
+      cmd.sync = sync
     if self.detached:
       raise Exception("detached")
     cmd.id = self.sent
@@ -144,6 +145,7 @@ class SessionState:
     self.actions[cmd.id] = action
     self.max_completion = cmd.id
     self.write_op(cmd)
+    self.need_sync = not cmd.sync
 
   def write_cmds(self, cmds, action=noop):
     if cmds:
@@ -963,6 +965,10 @@ class Engine:
       else:
         break
 
+    for snd in ssn.senders:
+      if snd.synced >= snd.queued and sst.need_sync:
+        sst.write_cmd(ExecutionSync(), sync=True)
+
     for rcv in ssn.receivers:
       self.process_receiver(rcv)
 
@@ -1167,7 +1173,7 @@ class Engine:
       log.debug("RACK[%s]: %s", sst.session.log_id, msg)
       assert msg == m
     sst.write_cmd(MessageTransfer(destination=_snd._exchange, headers=(dp, mp),
-                                  payload=body), msg_acked)
+                                  payload=body), msg_acked, sync=msg._sync)
     log.debug("SENT[%s]: %s", sst.session.log_id, msg)
 
   def do_message_transfer(self, xfr):
diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 707aee3..58a654e 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -677,12 +677,20 @@ class Session:
     assert self.aborted
 
   @synchronized
+  def sync(self):
+    """
+    Sync the session.
+    """
+    for snd in self.senders:
+      snd.sync()
+    self._ewait(lambda: not self.outgoing and not self.acked)
+
+  @synchronized
   def close(self):
     """
     Close the session.
     """
-    # XXX: should be able to express this condition through API calls
-    self._ewait(lambda: not self.outgoing and not self.acked)
+    self.sync()
 
     for link in self.receivers + self.senders:
       link.close()
@@ -704,8 +712,10 @@ class Sender:
     self.target = target
     self.options = options
     self.capacity = options.get("capacity", UNLIMITED)
+    self.threshold = 0.5
     self.durable = options.get("durable")
     self.queued = Serial(0)
+    self.synced = Serial(0)
     self.acked = Serial(0)
     self.error = None
     self.linked = False
@@ -792,18 +802,25 @@ class Sender:
 
     # XXX: what if we send the same message to multiple senders?
     message._sender = self
+    if self.capacity is not UNLIMITED:
+      message._sync = sync or self.available() <= int(ceil(self.threshold*self.capacity))
+    else:
+      message._sync = sync
     self.session.outgoing.append(message)
     self.queued += 1
 
-    self._wakeup()
-
     if sync:
       self.sync()
       assert message not in self.session.outgoing
+    else:
+      self._wakeup()
 
   @synchronized
   def sync(self):
     mno = self.queued
+    if self.synced < mno:
+      self.synced = mno
+      self._wakeup()
     self._ewait(lambda: self.acked >= mno)
 
   @synchronized
-- 
1.7.1.1

From df73fc4c6a53f8b266fb88af60ea68df03057668 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Thu, 17 Jun 2010 02:18:24 +0000
Subject: [PATCH 070/129] BZ-604836 reset reconnect delay after successful connect

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@955462 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index a6170c0..7f04903 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -480,6 +480,7 @@ class Driver:
       self._timeout = None
       self._attempts = 0
       self._host = 0
+      self._delay = self.connection.reconnect_interval_min
       self._retrying = False
     except socket.error, e:
       self._host = (self._host + 1) % len(self._hosts)
-- 
1.7.1.1

From a7229e8f44b08aed075be8a5da16187017314735 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Thu, 17 Jun 2010 16:55:54 +0000
Subject: [PATCH 071/129] Allow libraries to be independently versioned in the autotools build.

Each library libfoo or plugin foo has a variable FOO_VERSION_INFO with
a value passed as -version-info to libtool.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@955672 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/configure.ac       |    7 -------
 qpid/cpp/src/Makefile.am    |   27 ++++++++++++++++++++-------
 qpid/cpp/src/acl.mk         |    4 +++-
 qpid/cpp/src/cluster.mk     |    6 ++++--
 qpid/cpp/src/qmf.mk         |   20 ++++----------------
 qpid/cpp/src/qmfc.mk        |    3 +++
 qpid/cpp/src/replication.mk |   11 +++++++++--
 qpid/cpp/src/ssl.mk         |   10 ++++++----
 qpid/cpp/src/xml.mk         |    4 +++-
 9 files changed, 52 insertions(+), 40 deletions(-)

diff --git a/qpid/cpp/configure.ac b/qpid/cpp/configure.ac
index 4eec5f1..37c0c0a 100644
--- a/qpid/cpp/configure.ac
+++ b/qpid/cpp/configure.ac
@@ -114,13 +114,6 @@ gl_saved_libs=$LIBS
   AC_SUBST([LIB_DLOPEN])
 LIBS=$gl_saved_libs
 
-# Set the argument to be used in "libtool -version-info ARG".
-QPID_CURRENT=2
-QPID_REVISION=0
-QPID_AGE=0
-LIBTOOL_VERSION_INFO_ARG=$QPID_CURRENT:$QPID_REVISION:$QPID_AGE
-AC_SUBST(LIBTOOL_VERSION_INFO_ARG)
-
 gl_CLOCK_TIME
 
 # Enable Valgrind	
diff --git a/qpid/cpp/src/Makefile.am b/qpid/cpp/src/Makefile.am
index 2df445e..6a65c15 100644
--- a/qpid/cpp/src/Makefile.am
+++ b/qpid/cpp/src/Makefile.am
@@ -107,7 +107,6 @@ include $(srcdir)/managementgen.mk
 
 ## Compiler flags
 AM_CXXFLAGS = $(WARNING_CFLAGS)
-AM_LDFLAGS = -version-info $(LIBTOOL_VERSION_INFO_ARG)
 INCLUDES = -I$(top_srcdir)/include -I$(top_builddir)/include -I$(srcdir) -I=$(builddir)
 
 #
@@ -224,8 +223,8 @@ librdmawrap_la_CXXFLAGS = \
   $(AM_CXXFLAGS) -Wno-missing-field-initializers
 lib_LTLIBRARIES += \
   librdmawrap.la
-librdmawrap_la_LDFLAGS = \
-  -no-undefined
+RDMAWRAP_VERSION_INFO  = 2:0:0
+librdmawrap_la_LDFLAGS = -version-info $(RDMAWRAP_VERSION_INFO) -no-undefined
 
 rdma_la_SOURCES = \
   qpid/sys/RdmaIOPlugin.cpp
@@ -233,7 +232,8 @@ rdma_la_LIBADD = \
   libqpidbroker.la \
   librdmawrap.la \
   -libverbs
-rdma_la_LDFLAGS = $(PLUGINLDFLAGS)
+RDMA_VERSION_INFO  = 2:0:0
+rdma_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(RDMA_VERSION_INFO)
 rdma_la_CXXFLAGS = \
   $(AM_CXXFLAGS) -Wno-missing-field-initializers
 dmodule_LTLIBRARIES += \
@@ -245,7 +245,8 @@ rdmaconnector_la_LIBADD = \
   libqpidclient.la \
   librdmawrap.la \
   -libverbs
-rdmaconnector_la_LDFLAGS = $(PLUGINLDFLAGS)
+RDMACONNECTOR_VERSION_INFO = 2:0:0
+rdmaconnector_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(RDMACONNECTOR_VERSION_INFO)
 rdmaconnector_la_CXXFLAGS = \
   $(AM_CXXFLAGS) -Wno-missing-field-initializers
 cmodule_LTLIBRARIES += \
@@ -268,8 +269,6 @@ if SSL
 include ssl.mk
 endif
 
-# New 0-10 codec, to be integrated in future.
-# libqpidamqp_0_10_la_SOURCES= 
 EXTRA_DIST +=\
   CMakeLists.txt \
   cluster.cmake \
@@ -491,6 +490,9 @@ libqpidcommon_la_SOURCES += qpid/sys/cyrus/CyrusSecurityLayer.cpp
 libqpidcommon_la_LIBADD += -lsasl2
 endif
 
+QPIDCOMMON_VERSION_INFO = 2:0:0
+libqpidcommon_la_LDFLAGS=-version-info $(QPIDCOMMON_VERSION_INFO)
+
 libqpidbroker_la_LIBADD = libqpidcommon.la -luuid
 
 libqpidbroker_la_SOURCES = \
@@ -648,6 +650,9 @@ libqpidbroker_la_SOURCES = \
   qpid/management/ManagementTopicExchange.h \
   qpid/sys/TCPIOPlugin.cpp
 
+# Library Version Information:
+QPIDBROKER_VERSION_INFO = 2:0:0
+libqpidbroker_la_LDFLAGS = -version-info $(QPIDBROKER_VERSION_INFO)
 
 libqpidclient_la_LIBADD = libqpidcommon.la  -luuid
 
@@ -709,6 +714,10 @@ libqpidclient_la_SOURCES =			\
   qpid/client/TCPConnector.cpp			\
   qpid/client/TCPConnector.h
 
+# Library Version Information:
+QPIDCLIENT_VERSION_INFO  = 2:0:0
+libqpidclient_la_LDFLAGS = -version-info $(QPIDCLIENT_VERSION_INFO)
+
 libqpidmessaging_la_LIBADD = libqpidclient.la
 
 libqpidmessaging_la_SOURCES =			\
@@ -751,6 +760,10 @@ libqpidmessaging_la_SOURCES =			\
   qpid/client/amqp0_10/SimpleUrlParser.h	\
   qpid/client/amqp0_10/SimpleUrlParser.cpp
 
+# Library Version Information:
+QPIDMESSAGING_VERSION_INFO  = 2:0:0
+libqpidmessaging_la_LDFLAGS = -version-info $(QPIDMESSAGING_VERSION_INFO)
+
 # NOTE: only public header files (which should be in ../include)
 # should go in this list. Private headers should go in the SOURCES
 # list for one of the libraries or executables that includes it.
diff --git a/qpid/cpp/src/acl.mk b/qpid/cpp/src/acl.mk
index cedac7d..0450905 100644
--- a/qpid/cpp/src/acl.mk
+++ b/qpid/cpp/src/acl.mk
@@ -37,4 +37,6 @@ if SUNOS
   acl_la_LIBADD +=  libqmfagent.la libqmfconsole.la libqpidcommon.la -lboost_program_options $(SUNCC_RUNTIME_LIBS)
 endif
 
-acl_la_LDFLAGS = $(PLUGINLDFLAGS)
+ACL_VERSION_INFO  = 2:0:0
+acl_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(ACL_VERSION_INFO)
+
diff --git a/qpid/cpp/src/cluster.mk b/qpid/cpp/src/cluster.mk
index 2a648e9..2e4942d 100644
--- a/qpid/cpp/src/cluster.mk
+++ b/qpid/cpp/src/cluster.mk
@@ -97,13 +97,15 @@ cluster_la_SOURCES =				\
 
 cluster_la_LIBADD=  -lcpg $(libcman) libqpidbroker.la libqpidclient.la
 cluster_la_CXXFLAGS = $(AM_CXXFLAGS) -fno-strict-aliasing
-cluster_la_LDFLAGS = $(PLUGINLDFLAGS)
+CLUSTER_VERSION_INFO = 2:0:0
+cluster_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(CLUSTER_VERSION_INFO)
 
 # The watchdog plugin and helper executable
 dmodule_LTLIBRARIES += watchdog.la
 watchdog_la_SOURCES = qpid/cluster/WatchDogPlugin.cpp
 watchdog_la_LIBADD = libqpidbroker.la
-watchdog_la_LDFLAGS = $(PLUGINLDFLAGS)
+WATCHDOG_VERSION_INFO  = 2:0:0
+watchdog_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(WATCHDOG_VERSION_INFO)
 
 qpidexec_PROGRAMS += qpidd_watchdog
 qpidd_watchdog_SOURCES = qpid/cluster/qpidd_watchdog.cpp
diff --git a/qpid/cpp/src/qmf.mk b/qpid/cpp/src/qmf.mk
index 1e4c59b..93f1817 100644
--- a/qpid/cpp/src/qmf.mk
+++ b/qpid/cpp/src/qmf.mk
@@ -96,20 +96,8 @@ libqmfengine_la_SOURCES =			\
 libqmf_la_LIBADD = libqmfengine.la
 libqmfengine_la_LIBADD = libqpidclient.la
 
-# Library Version Information:
-#
-#  CURRENT  => API/ABI version.  Bump this if the interface changes
-#  REVISION => Version of underlying implementation.
-#              Bump if implementation changes but API/ABI doesn't
-#  AGE      => Number of API/ABI versions this is backward compatible with
-#
-QMF_CURRENT  = 1
-QMF_REVISION = 0
-QMF_AGE      = 0
-
-QMF_ENGINE_CURRENT  = 1
-QMF_ENGINE_REVISION = 1
-QMF_ENGINE_AGE      = 0
+QMF_VERSION_INFO = 1:0:0
+QMFENGINE_VERSION_INFO  = 1:1:0
 
-libqmf_la_LDFLAGS = -version-info $(QMF_CURRENT):$(QMF_REVISION):$(QMF_AGE)
-libqmfengine_la_LDFLAGS = -version-info $(QMF_ENGINE_CURRENT):$(QMF_ENGINE_REVISION):$(QMF_ENGINE_AGE)
+libqmf_la_LDFLAGS = -version-info $(QMF_VERSION_INFO)
+libqmfengine_la_LDFLAGS = -version-info $(QMFENGINE_VERSION_INFO)
diff --git a/qpid/cpp/src/qmfc.mk b/qpid/cpp/src/qmfc.mk
index f3e6dc2..9e8078f 100644
--- a/qpid/cpp/src/qmfc.mk
+++ b/qpid/cpp/src/qmfc.mk
@@ -53,3 +53,6 @@ libqmfconsole_la_SOURCES =			\
 
 libqmfconsole_la_LIBADD = libqpidclient.la
 
+# Library Version Information:
+QMFCONSOLE_VERSION_INFO  = 2:0:0
+libqmfconsole_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(QMFCONSOLE_VERSION_INFO)
diff --git a/qpid/cpp/src/replication.mk b/qpid/cpp/src/replication.mk
index 4a51fb9..e27920d 100644
--- a/qpid/cpp/src/replication.mk
+++ b/qpid/cpp/src/replication.mk
@@ -33,7 +33,10 @@ if SUNOS
   replicating_listener_la_LIBADD += libqpidcommon.la -lboost_program_options -luuid $(SUNCC_RUNTIME_LIBS)
 endif
 
-replicating_listener_la_LDFLAGS = $(PLUGINLDFLAGS)
+# Library Version Information:
+REPLICATING_LISTENER_VERSION_INFO = 2:0:0
+replicating_listener_la_LDFLAGS = $(PLUGINLDFLAGS) \
+  -version-info $(REPLICATING_LISTENER_VERSION_INFO)
 
 # a custom exchange plugin that allows an exchange to be created that
 # can process the messages from a replication queue (populated on the
@@ -49,4 +52,8 @@ replication_exchange_la_LIBADD = libqpidbroker.la
 if SUNOS
   replication_exchange_la_LIBADD += libqpidcommon.la -lboost_program_options $(SUNCC_RUNTIME_LIBS) -luuid
 endif
-replication_exchange_la_LDFLAGS = $(PLUGINLDFLAGS)
+# Library Version Information:
+REPLICATION_EXCHANGE_VERSION_INFO  = 2:0:0
+replication_exchange_la_LDFLAGS = $(PLUGINLDFLAGS) \
+  -version-info $(REPLICATION_EXCHANGE_VERSION_INFO)
+
diff --git a/qpid/cpp/src/ssl.mk b/qpid/cpp/src/ssl.mk
index f7fba7b..40cb9d0 100644
--- a/qpid/cpp/src/ssl.mk
+++ b/qpid/cpp/src/ssl.mk
@@ -29,8 +29,9 @@ libsslcommon_la_SOURCES = \
   qpid/sys/ssl/SslIo.h \
   qpid/sys/ssl/SslIo.cpp
 
+SSLCOMMON_VERSION_INFO  = 2:0:0
+libsslcommon_la_LDFLAGS = -version-info $(SSLCOMMON_VERSION_INFO)
 libsslcommon_la_LIBADD= -lnss3 -lssl3 -lnspr4 libqpidcommon.la
-
 libsslcommon_la_CXXFLAGS=$(AM_CXXFLAGS) $(SSL_CFLAGS)
 
 lib_LTLIBRARIES +=  libsslcommon.la
@@ -44,11 +45,11 @@ ssl_la_LIBADD= libqpidbroker.la libsslcommon.la
 
 ssl_la_CXXFLAGS=$(AM_CXXFLAGS) $(SSL_CFLAGS)
 
-ssl_la_LDFLAGS = $(PLUGINLDFLAGS)
+SSL_VERSION_INFO  = 2:0:0
+ssl_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(SSL_VERSION_INFO)
 
 dmodule_LTLIBRARIES += ssl.la
 
-
 sslconnector_la_SOURCES = \
   qpid/client/SslConnector.cpp
 
@@ -58,7 +59,8 @@ sslconnector_la_LIBADD = \
 
 sslconnector_la_CXXFLAGS = $(AM_CXXFLAGS) -DQPIDC_CONF_FILE=\"$(confdir)/qpidc.conf\"  $(SSL_CFLAGS)
 
-sslconnector_la_LDFLAGS = $(PLUGINLDFLAGS)
+SSLCONNECTOR_VERSION_INFO  = 2:0:0
+sslconnector_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(SSLCONNECTOR_VERSION_INFO)
 
 cmodule_LTLIBRARIES += \
   sslconnector.la
diff --git a/qpid/cpp/src/xml.mk b/qpid/cpp/src/xml.mk
index 957a18e..2372202 100644
--- a/qpid/cpp/src/xml.mk
+++ b/qpid/cpp/src/xml.mk
@@ -25,4 +25,6 @@ xml_la_SOURCES =  \
 
 xml_la_LIBADD = -lxerces-c -lxqilla libqpidbroker.la
 
-xml_la_LDFLAGS = $(PLUGINLDFLAGS)
+XML_VERSION_INFO = 2:0:0
+xml_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(XML_VERSION_INFO)
+
-- 
1.7.1.1

From 6df566bff554a1c95637a8e32398462ee3e1d9ee Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Fri, 18 Jun 2010 13:40:04 +0000
Subject: [PATCH 072/129] Fix version info

- no version info for modules
- no $(PLUGINLDFLAGS)  on libqmfconsole, typo in previous merge.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@956001 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 882656ef4d0d8a26804fbb5a2ced3dcad433dc3b)
---
 qpid/cpp/src/Makefile.am    |    9 ++-------
 qpid/cpp/src/acl.mk         |    3 +--
 qpid/cpp/src/cluster.mk     |    6 ++----
 qpid/cpp/src/qmfc.mk        |    3 +--
 qpid/cpp/src/replication.mk |   11 ++---------
 qpid/cpp/src/ssl.mk         |    6 ++----
 qpid/cpp/src/xml.mk         |    3 +--
 7 files changed, 11 insertions(+), 30 deletions(-)

diff --git a/qpid/cpp/src/Makefile.am b/qpid/cpp/src/Makefile.am
index 6a65c15..27a60e4 100644
--- a/qpid/cpp/src/Makefile.am
+++ b/qpid/cpp/src/Makefile.am
@@ -232,8 +232,7 @@ rdma_la_LIBADD = \
   libqpidbroker.la \
   librdmawrap.la \
   -libverbs
-RDMA_VERSION_INFO  = 2:0:0
-rdma_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(RDMA_VERSION_INFO)
+rdma_la_LDFLAGS = $(PLUGINLDFLAGS)
 rdma_la_CXXFLAGS = \
   $(AM_CXXFLAGS) -Wno-missing-field-initializers
 dmodule_LTLIBRARIES += \
@@ -245,8 +244,7 @@ rdmaconnector_la_LIBADD = \
   libqpidclient.la \
   librdmawrap.la \
   -libverbs
-RDMACONNECTOR_VERSION_INFO = 2:0:0
-rdmaconnector_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(RDMACONNECTOR_VERSION_INFO)
+rdmaconnector_la_LDFLAGS = $(PLUGINLDFLAGS)
 rdmaconnector_la_CXXFLAGS = \
   $(AM_CXXFLAGS) -Wno-missing-field-initializers
 cmodule_LTLIBRARIES += \
@@ -650,7 +648,6 @@ libqpidbroker_la_SOURCES = \
   qpid/management/ManagementTopicExchange.h \
   qpid/sys/TCPIOPlugin.cpp
 
-# Library Version Information:
 QPIDBROKER_VERSION_INFO = 2:0:0
 libqpidbroker_la_LDFLAGS = -version-info $(QPIDBROKER_VERSION_INFO)
 
@@ -714,7 +711,6 @@ libqpidclient_la_SOURCES =			\
   qpid/client/TCPConnector.cpp			\
   qpid/client/TCPConnector.h
 
-# Library Version Information:
 QPIDCLIENT_VERSION_INFO  = 2:0:0
 libqpidclient_la_LDFLAGS = -version-info $(QPIDCLIENT_VERSION_INFO)
 
@@ -760,7 +756,6 @@ libqpidmessaging_la_SOURCES =			\
   qpid/client/amqp0_10/SimpleUrlParser.h	\
   qpid/client/amqp0_10/SimpleUrlParser.cpp
 
-# Library Version Information:
 QPIDMESSAGING_VERSION_INFO  = 2:0:0
 libqpidmessaging_la_LDFLAGS = -version-info $(QPIDMESSAGING_VERSION_INFO)
 
diff --git a/qpid/cpp/src/acl.mk b/qpid/cpp/src/acl.mk
index 0450905..bcd1d88 100644
--- a/qpid/cpp/src/acl.mk
+++ b/qpid/cpp/src/acl.mk
@@ -37,6 +37,5 @@ if SUNOS
   acl_la_LIBADD +=  libqmfagent.la libqmfconsole.la libqpidcommon.la -lboost_program_options $(SUNCC_RUNTIME_LIBS)
 endif
 
-ACL_VERSION_INFO  = 2:0:0
-acl_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(ACL_VERSION_INFO)
+acl_la_LDFLAGS = $(PLUGINLDFLAGS)
 
diff --git a/qpid/cpp/src/cluster.mk b/qpid/cpp/src/cluster.mk
index 2e4942d..2a648e9 100644
--- a/qpid/cpp/src/cluster.mk
+++ b/qpid/cpp/src/cluster.mk
@@ -97,15 +97,13 @@ cluster_la_SOURCES =				\
 
 cluster_la_LIBADD=  -lcpg $(libcman) libqpidbroker.la libqpidclient.la
 cluster_la_CXXFLAGS = $(AM_CXXFLAGS) -fno-strict-aliasing
-CLUSTER_VERSION_INFO = 2:0:0
-cluster_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(CLUSTER_VERSION_INFO)
+cluster_la_LDFLAGS = $(PLUGINLDFLAGS)
 
 # The watchdog plugin and helper executable
 dmodule_LTLIBRARIES += watchdog.la
 watchdog_la_SOURCES = qpid/cluster/WatchDogPlugin.cpp
 watchdog_la_LIBADD = libqpidbroker.la
-WATCHDOG_VERSION_INFO  = 2:0:0
-watchdog_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(WATCHDOG_VERSION_INFO)
+watchdog_la_LDFLAGS = $(PLUGINLDFLAGS)
 
 qpidexec_PROGRAMS += qpidd_watchdog
 qpidd_watchdog_SOURCES = qpid/cluster/qpidd_watchdog.cpp
diff --git a/qpid/cpp/src/qmfc.mk b/qpid/cpp/src/qmfc.mk
index 9e8078f..b0ef68d 100644
--- a/qpid/cpp/src/qmfc.mk
+++ b/qpid/cpp/src/qmfc.mk
@@ -53,6 +53,5 @@ libqmfconsole_la_SOURCES =			\
 
 libqmfconsole_la_LIBADD = libqpidclient.la
 
-# Library Version Information:
 QMFCONSOLE_VERSION_INFO  = 2:0:0
-libqmfconsole_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(QMFCONSOLE_VERSION_INFO)
+libqmfconsole_la_LDFLAGS = -version-info $(QMFCONSOLE_VERSION_INFO)
diff --git a/qpid/cpp/src/replication.mk b/qpid/cpp/src/replication.mk
index e27920d..dbe071f 100644
--- a/qpid/cpp/src/replication.mk
+++ b/qpid/cpp/src/replication.mk
@@ -32,11 +32,7 @@ replicating_listener_la_LIBADD = libqpidbroker.la
 if SUNOS
   replicating_listener_la_LIBADD += libqpidcommon.la -lboost_program_options -luuid $(SUNCC_RUNTIME_LIBS)
 endif
-
-# Library Version Information:
-REPLICATING_LISTENER_VERSION_INFO = 2:0:0
-replicating_listener_la_LDFLAGS = $(PLUGINLDFLAGS) \
-  -version-info $(REPLICATING_LISTENER_VERSION_INFO)
+replicating_listener_la_LDFLAGS = $(PLUGINLDFLAGS)
 
 # a custom exchange plugin that allows an exchange to be created that
 # can process the messages from a replication queue (populated on the
@@ -52,8 +48,5 @@ replication_exchange_la_LIBADD = libqpidbroker.la
 if SUNOS
   replication_exchange_la_LIBADD += libqpidcommon.la -lboost_program_options $(SUNCC_RUNTIME_LIBS) -luuid
 endif
-# Library Version Information:
-REPLICATION_EXCHANGE_VERSION_INFO  = 2:0:0
-replication_exchange_la_LDFLAGS = $(PLUGINLDFLAGS) \
-  -version-info $(REPLICATION_EXCHANGE_VERSION_INFO)
+replication_exchange_la_LDFLAGS = $(PLUGINLDFLAGS)
 
diff --git a/qpid/cpp/src/ssl.mk b/qpid/cpp/src/ssl.mk
index 40cb9d0..5fbdd55 100644
--- a/qpid/cpp/src/ssl.mk
+++ b/qpid/cpp/src/ssl.mk
@@ -45,8 +45,7 @@ ssl_la_LIBADD= libqpidbroker.la libsslcommon.la
 
 ssl_la_CXXFLAGS=$(AM_CXXFLAGS) $(SSL_CFLAGS)
 
-SSL_VERSION_INFO  = 2:0:0
-ssl_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(SSL_VERSION_INFO)
+ssl_la_LDFLAGS = $(PLUGINLDFLAGS)
 
 dmodule_LTLIBRARIES += ssl.la
 
@@ -59,8 +58,7 @@ sslconnector_la_LIBADD = \
 
 sslconnector_la_CXXFLAGS = $(AM_CXXFLAGS) -DQPIDC_CONF_FILE=\"$(confdir)/qpidc.conf\"  $(SSL_CFLAGS)
 
-SSLCONNECTOR_VERSION_INFO  = 2:0:0
-sslconnector_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(SSLCONNECTOR_VERSION_INFO)
+sslconnector_la_LDFLAGS = $(PLUGINLDFLAGS)
 
 cmodule_LTLIBRARIES += \
   sslconnector.la
diff --git a/qpid/cpp/src/xml.mk b/qpid/cpp/src/xml.mk
index 2372202..0d700fc 100644
--- a/qpid/cpp/src/xml.mk
+++ b/qpid/cpp/src/xml.mk
@@ -25,6 +25,5 @@ xml_la_SOURCES =  \
 
 xml_la_LIBADD = -lxerces-c -lxqilla libqpidbroker.la
 
-XML_VERSION_INFO = 2:0:0
-xml_la_LDFLAGS = $(PLUGINLDFLAGS) -version-info $(XML_VERSION_INFO)
+xml_la_LDFLAGS = $(PLUGINLDFLAGS)
 
-- 
1.7.1.1

From 0f5083fda071b089376561b6de3b89a89d0d7823 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Tue, 22 Jun 2010 13:29:52 +0000
Subject: [PATCH 073/129] Bug 605763 - Failures in long cluster_tests.test_management

Fix cluster broker crashes when management is active.

Cluser brokers were exiting with errors "modified cluster state
outside cluster context" and "confirmed < (50+0) but only sent < (49+0)"

Fix was to:
 - delay completion of incoming update till update connection closes.
 - delay addding new connections to managment until connection is announced.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@956882 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 8c6bdbf58524a38ded50903ffd457a3f1aa59fc1)
---
 qpid/cpp/src/qpid/broker/Connection.cpp          |   30 +-
 qpid/cpp/src/qpid/broker/Connection.h            |   14 +-
 qpid/cpp/src/qpid/cluster/Cluster.cpp            |   13 +-
 qpid/cpp/src/qpid/cluster/Cluster.h              |    3 +-
 qpid/cpp/src/qpid/cluster/Connection.cpp         |   45 ++-
 qpid/cpp/src/qpid/cluster/Connection.h           |   14 +-
 qpid/cpp/src/qpid/management/ManagementAgent.cpp |   21 +-
 qpid/cpp/src/qpid/sys/ClusterSafe.cpp            |   11 +-
 qpid/cpp/src/tests/cluster_tests.py              |    2 +-
 qpid/cpp/src/tests/run_long_cluster_tests        |    2 +-
 qpid/cpp/src/tests/verify_cluster_objects        |  456 ++++------------------
 qpid/cpp/xml/cluster.xml                         |    4 +-
 12 files changed, 188 insertions(+), 427 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Connection.cpp b/qpid/cpp/src/qpid/broker/Connection.cpp
index 619f1a1..bc755e3 100644
--- a/qpid/cpp/src/qpid/broker/Connection.cpp
+++ b/qpid/cpp/src/qpid/broker/Connection.cpp
@@ -76,8 +76,14 @@ struct ConnectionTimeoutTask : public sys::TimerTask {
     }
 };
 
-Connection::Connection(ConnectionOutputHandler* out_, Broker& broker_, const std::string& mgmtId_,
-                       const qpid::sys::SecuritySettings& external, bool isLink_, uint64_t objectId, bool shadow_) :
+Connection::Connection(ConnectionOutputHandler* out_,
+                       Broker& broker_, const
+                       std::string& mgmtId_,
+                       const qpid::sys::SecuritySettings& external,
+                       bool isLink_,
+                       uint64_t objectId_,
+                       bool shadow_,
+                       bool delayManagement) :
     ConnectionState(out_, broker_),
     securitySettings(external),
     adapter(*this, isLink_, shadow_),
@@ -89,26 +95,30 @@ Connection::Connection(ConnectionOutputHandler* out_, Broker& broker_, const std
     agent(0),
     timer(broker_.getTimer()),
     errorListener(0),
+    objectId(objectId_),
     shadow(shadow_)
 {
-    Manageable* parent = broker.GetVhostObject();
-
     if (isLink)
         links.notifyConnection(mgmtId, this);
+    // In a cluster, allow adding the management object to be delayed.
+    if (!delayManagement) addManagementObject();
+    if (!isShadow()) broker.getConnectionCounter().inc_connectionCount();
+}
 
-    if (parent != 0)
-    {
-        agent = broker_.getManagementAgent();
-
-        // TODO set last bool true if system connection
+void Connection::addManagementObject() {
+    assert(agent == 0);
+    assert(mgmtObject == 0);
+    Manageable* parent = broker.GetVhostObject();
+    if (parent != 0) {
+        agent = broker.getManagementAgent();
         if (agent != 0) {
+            // TODO set last bool true if system connection
             mgmtObject = new _qmf::Connection(agent, this, parent, mgmtId, !isLink, false);
             mgmtObject->set_shadow(shadow);
             agent->addObject(mgmtObject, objectId);
         }
         ConnectionState::setUrl(mgmtId);
     }
-    if (!isShadow()) broker.getConnectionCounter().inc_connectionCount();
 }
 
 void Connection::requestIOProcessing(boost::function0<void> callback)
diff --git a/qpid/cpp/src/qpid/broker/Connection.h b/qpid/cpp/src/qpid/broker/Connection.h
index cf199fa..8ad78f6 100644
--- a/qpid/cpp/src/qpid/broker/Connection.h
+++ b/qpid/cpp/src/qpid/broker/Connection.h
@@ -79,9 +79,15 @@ class Connection : public sys::ConnectionInputHandler,
         virtual void connectionError(const std::string&) = 0;
     };
 
-    Connection(sys::ConnectionOutputHandler* out, Broker& broker, const std::string& mgmtId,
+    Connection(sys::ConnectionOutputHandler* out,
+               Broker& broker,
+               const std::string& mgmtId,
                const qpid::sys::SecuritySettings&,
-               bool isLink = false, uint64_t objectId = 0, bool shadow=false);
+               bool isLink = false,
+               uint64_t objectId = 0,
+               bool shadow=false,
+               bool delayManagement = false);
+
     ~Connection ();
 
     /** Get the SessionHandler for channel. Create if it does not already exist */
@@ -139,6 +145,9 @@ class Connection : public sys::ConnectionInputHandler,
     // Used by cluster to update connection status
     sys::AggregateOutput& getOutputTasks() { return outputTasks; }
 
+    /** Cluster delays adding management object in the constructor then calls this. */
+    void addManagementObject();
+
     const qpid::sys::SecuritySettings& getExternalSecuritySettings() const
     { 
         return securitySettings;
@@ -166,6 +175,7 @@ class Connection : public sys::ConnectionInputHandler,
     boost::intrusive_ptr<sys::TimerTask> heartbeatTimer;
     boost::intrusive_ptr<ConnectionTimeoutTask> timeoutTimer;
     ErrorListener* errorListener;
+    uint64_t objectId;
     bool shadow;
 
   public:
diff --git a/qpid/cpp/src/qpid/cluster/Cluster.cpp b/qpid/cpp/src/qpid/cluster/Cluster.cpp
index bc47e0b..233cc89 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.cpp
+++ b/qpid/cpp/src/qpid/cluster/Cluster.cpp
@@ -194,7 +194,7 @@ namespace _qmf = ::qmf::org::apache::qpid::cluster;
  * Currently use SVN revision to avoid clashes with versions from
  * different branches.
  */
-const uint32_t Cluster::CLUSTER_VERSION = 904565;
+const uint32_t Cluster::CLUSTER_VERSION = 956001;
 
 struct ClusterDispatcher : public framing::AMQP_AllOperations::ClusterHandler {
     qpid::cluster::Cluster& cluster;
@@ -269,6 +269,7 @@ Cluster::Cluster(const ClusterSettings& set, broker::Broker& b) :
     lastAliveCount(0),
     lastBroker(false),
     updateRetracted(false),
+    updateClosed(false),
     error(*this)
 {
     // We give ownership of the timer to the broker and keep a plain pointer.
@@ -861,6 +862,14 @@ void Cluster::updateStart(const MemberId& updatee, const Url& url, Lock& l) {
                          connectionSettings(settings)));
 }
 
+// Called in network thread
+void Cluster::updateInClosed() {
+    Lock l(lock);
+    assert(!updateClosed);
+    updateClosed = true;
+    checkUpdateIn(l);
+}
+
 // Called in update thread.
 void Cluster::updateInDone(const ClusterMap& m) {
     Lock l(lock);
@@ -877,6 +886,7 @@ void Cluster::updateInRetracted() {
 
 void Cluster::checkUpdateIn(Lock& l) {
     if (state != UPDATEE) return; // Wait till we reach the stall point.
+    if (!updateClosed) return;  // Wait till update connection closes.
     if (updatedMap) { // We're up to date
         map = *updatedMap;
         failoverExchange->setUrls(getUrls(l));
@@ -893,6 +903,7 @@ void Cluster::checkUpdateIn(Lock& l) {
     }
     else if (updateRetracted) { // Update was retracted, request another update
         updateRetracted = false;
+        updateClosed = false;
         state = JOINER;
         QPID_LOG(notice, *this << " update retracted, sending new update request.");
         mcast.mcastControl(ClusterUpdateRequestBody(ProtocolVersion(), myUrl.str()), self);
diff --git a/qpid/cpp/src/qpid/cluster/Cluster.h b/qpid/cpp/src/qpid/cluster/Cluster.h
index 0d8b55c..84dee27 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.h
+++ b/qpid/cpp/src/qpid/cluster/Cluster.h
@@ -97,6 +97,7 @@ class Cluster : private Cpg::Handler, public management::Manageable {
     void leave();
 
     // Update completed - called in update thread
+    void updateInClosed();
     void updateInDone(const ClusterMap&);
     void updateInRetracted();
 
@@ -277,7 +278,7 @@ class Cluster : private Cpg::Handler, public management::Manageable {
     bool lastBroker;
     sys::Thread updateThread;
     boost::optional<ClusterMap> updatedMap;
-    bool updateRetracted;
+    bool updateRetracted, updateClosed;
     ErrorCheck error;
     UpdateReceiver updateReceiver;
     ClusterTimer* timer;
diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index a2d1cc8..e0c0465 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -22,7 +22,6 @@
 #include "UpdateClient.h"
 #include "Cluster.h"
 #include "UpdateReceiver.h"
-
 #include "qpid/assert.h"
 #include "qpid/broker/SessionState.h"
 #include "qpid/broker/SemanticState.h"
@@ -43,7 +42,6 @@
 #include "qpid/framing/ConnectionCloseOkBody.h"
 #include "qpid/log/Statement.h"
 #include "qpid/management/ManagementAgent.h"
-
 #include <boost/current_function.hpp>
 
 
@@ -99,10 +97,9 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
 {
     cluster.addLocalConnection(this);
     if (isLocalClient()) {
-        // Local clients are announced to the cluster
-        // and initialized when the announce is received.
         giveReadCredit(cluster.getSettings().readMax); // Flow control
-        init();
+        // Delay adding the connection to the management map until announce()
+        connectionCtor.delayManagement = true;
     }
     else {
         // Catch-up shadow connections initialized using nextShadow id.
@@ -110,9 +107,9 @@ Connection::Connection(Cluster& c, sys::ConnectionOutputHandler& out,
         if (!updateIn.nextShadowMgmtId.empty())
             connectionCtor.mgmtId = updateIn.nextShadowMgmtId;
         updateIn.nextShadowMgmtId.clear();
-        init();
-    }
-    QPID_LOG(info, "incoming connection " << *this);
+     }
+    init();
+    QPID_LOG(debug, cluster << " local connection " << *this);
 }
 
 void Connection::setSecureConnection(broker::SecureConnection* sc) {
@@ -152,8 +149,11 @@ void Connection::announce(
     QPID_ASSERT(ssf == connectionCtor.external.ssf);
     QPID_ASSERT(authid == connectionCtor.external.authid);
     QPID_ASSERT(nodict == connectionCtor.external.nodict);
-    // Local connections are already initialized.
-    if (isShadow()) {
+    // Local connections are already initialized but with management delayed.
+    if (isLocalClient()) {
+        connection->addManagementObject();
+    }
+    else if (isShadow()) {
         init();
         // Play initial frames into the connection.
         Buffer buf(const_cast<char*>(initialFrames.data()), initialFrames.size());
@@ -162,8 +162,9 @@ void Connection::announce(
             connection->received(frame);
          connection->setUserId(username);
     }
-    // Raise the connection management event now that the connection is replicated.
+    // Do managment actions now that the connection is replicated.
     connection->raiseConnectEvent();
+    QPID_LOG(debug, cluster << " replicated connection " << *this);
 }
 
 Connection::~Connection() {
@@ -249,6 +250,7 @@ void Connection::closed() {
         if (isUpdated()) {
             QPID_LOG(debug, cluster << " update connection closed " << *this);
             close();
+            cluster.updateInClosed();
         }
         else if (catchUp) {
             QPID_LOG(critical, cluster << " catch-up connection closed prematurely " << *this);
@@ -259,7 +261,8 @@ void Connection::closed() {
             // closed and process any outstanding frames from the cluster
             // until self-delivery of deliver-close.
             output.closeOutput();
-            cluster.getMulticast().mcastControl(ClusterConnectionDeliverCloseBody(), self);
+            cluster.getMulticast().mcastControl(
+                ClusterConnectionDeliverCloseBody(ProtocolVersion(), false), self);
         }
     }
     catch (const std::exception& e) {
@@ -268,17 +271,21 @@ void Connection::closed() {
 }
 
 // Self-delivery of close message, close the connection.
-void Connection::deliverClose () {
-    assert(!catchUp);
-    close();
+void Connection::deliverClose (bool aborted) {
+    QPID_LOG(debug, cluster << " replicated close of " << *this);
+    if (connection.get()) {
+        if (aborted) connection->abort();
+        else connection->closed();
+        connection.reset();
+    }
     cluster.erase(self);
 }
 
 // Close the connection
 void Connection::close() {
+    QPID_LOG(debug, cluster << " local close of " << *this);
     if (connection.get()) {
         connection->closed();
-        // Ensure we delete the broker::Connection in the deliver thread.
         connection.reset();
     }
 }
@@ -286,11 +293,9 @@ void Connection::close() {
 // The connection has been killed for misbehaving, called in connection thread.
 void Connection::abort() {
     if (connection.get()) {
-        connection->abort();
-        // Ensure we delete the broker::Connection in the deliver thread.
-        connection.reset();
+        cluster.getMulticast().mcastControl(
+            ClusterConnectionDeliverCloseBody(ProtocolVersion(), true), self);
     }
-    cluster.erase(self);
 }
 
 // ConnectionCodec::decode receives read buffers from  directly-connected clients.
diff --git a/qpid/cpp/src/qpid/cluster/Connection.h b/qpid/cpp/src/qpid/cluster/Connection.h
index 45d832a..72a98c1 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.h
+++ b/qpid/cpp/src/qpid/cluster/Connection.h
@@ -170,7 +170,7 @@ class Connection :
                   const std::string& initFrames);
     void close();
     void abort();
-    void deliverClose();
+    void deliverClose(bool);
 
     OutputInterceptor& getOutput() { return output; }
 
@@ -194,6 +194,7 @@ class Connection :
         bool isLink;
         uint64_t objectId;
         bool shadow;
+        bool delayManagement;
 
         ConnectionCtor(
             sys::ConnectionOutputHandler* out_,
@@ -202,14 +203,19 @@ class Connection :
             const qpid::sys::SecuritySettings& external_,
             bool isLink_=false,
             uint64_t objectId_=0,
-            bool shadow_=false
+            bool shadow_=false,
+            bool delayManagement_=false
         ) : out(out_), broker(broker_), mgmtId(mgmtId_), external(external_),
-            isLink(isLink_), objectId(objectId_), shadow(shadow_)
+            isLink(isLink_), objectId(objectId_), shadow(shadow_),
+            delayManagement(delayManagement_)
         {}
 
         std::auto_ptr<broker::Connection> construct() {
             return std::auto_ptr<broker::Connection>(
-                new broker::Connection(out, broker, mgmtId, external, isLink, objectId, shadow));
+                new broker::Connection(
+                    out, broker, mgmtId, external, isLink, objectId,
+                    shadow, delayManagement)
+            );
         }
     };
 
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.cpp b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
index b1c2780..8818a4c 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
@@ -2321,6 +2321,23 @@ void ManagementAgent::importAgents(qpid::framing::Buffer& inBuf) {
     }
 }
 
+namespace {
+bool isNotDeleted(const ManagementObjectMap::value_type& value) {
+    return !value.second->isDeleted();
+}
+
+size_t countNotDeleted(const ManagementObjectMap& map) {
+    return std::count_if(map.begin(), map.end(), isNotDeleted);
+}
+
+void dumpMap(std::ostream& o, const ManagementObjectMap& map) {
+    for (ManagementObjectMap::const_iterator i = map.begin(); i != map.end(); ++i) {
+        if (!i->second->isDeleted())
+            o << endl << "   " << i->second->getObjectId().getV2Key();
+    }
+}
+} // namespace
+
 string ManagementAgent::debugSnapshot() {
     ostringstream msg;
     msg << " management snapshot:";
@@ -2328,8 +2345,8 @@ string ManagementAgent::debugSnapshot() {
          i != remoteAgents.end(); ++i)
         msg << " " << i->second->routingKey;
     msg << " packages: " << packages.size();
-    msg << " objects: " << managementObjects.size();
-    msg << " new objects: " << newManagementObjects.size();
+    msg << " objects: " << countNotDeleted(managementObjects);
+    msg << " new objects: " << countNotDeleted(newManagementObjects);
     return msg.str();
 }
 
diff --git a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
index e051591..6105fc9 100644
--- a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
+++ b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
@@ -43,8 +43,15 @@ void assertClusterSafe()  {
     }
 }
 
-ClusterSafeScope::ClusterSafeScope() { inContext = true; }
-ClusterSafeScope::~ClusterSafeScope() { inContext = false; }
+ClusterSafeScope::ClusterSafeScope() {
+    assert(!inContext);
+    inContext = true;
+}
+
+ClusterSafeScope::~ClusterSafeScope() {
+    assert(inContext);
+    inContext = false;
+}
 
 void enableClusterSafe() { inCluster = true; }
 
diff --git a/qpid/cpp/src/tests/cluster_tests.py b/qpid/cpp/src/tests/cluster_tests.py
index 983a8bd..ebb07a1 100755
--- a/qpid/cpp/src/tests/cluster_tests.py
+++ b/qpid/cpp/src/tests/cluster_tests.py
@@ -199,7 +199,7 @@ class LongTests(BrokerTest):
                 StoppableThread.stop(self)
 
         # def test_management
-        args=["--mgmt-pub-interval", 1] # Publish management information every second.
+        args = ["--mgmt-pub-interval", 1] # Publish management information every second.
         # Use store if present.
         if BrokerTest.store_lib: args +=["--load-module", BrokerTest.store_lib]
         cluster = self.cluster(3, args)
diff --git a/qpid/cpp/src/tests/run_long_cluster_tests b/qpid/cpp/src/tests/run_long_cluster_tests
index 05c7867..5dce0be 100755
--- a/qpid/cpp/src/tests/run_long_cluster_tests
+++ b/qpid/cpp/src/tests/run_long_cluster_tests
@@ -20,5 +20,5 @@
 #
 
 srcdir=`dirname $0`
-$srcdir/run_cluster_tests 'cluster_tests.LongTests.*' -DDURATION=2
+$srcdir/run_cluster_tests 'cluster_tests.LongTests.*' -DDURATION=4
 
diff --git a/qpid/cpp/src/tests/verify_cluster_objects b/qpid/cpp/src/tests/verify_cluster_objects
index be6d67d..a96c636 100755
--- a/qpid/cpp/src/tests/verify_cluster_objects
+++ b/qpid/cpp/src/tests/verify_cluster_objects
@@ -1,6 +1,5 @@
 #!/usr/bin/env python
 
-#
 # Licensed to the Apache Software Foundation (ASF) under one
 # or more contributor license agreements.  See the NOTICE file
 # distributed with this work for additional information
@@ -19,390 +18,83 @@
 # under the License.
 #
 
-import os
-import getopt
-import sys
-import locale
-import socket
-import re
-from qmf.console import Session, SchemaClass
-
-_host = "localhost"
-_connTimeout = 10
-_verbose = 0
-_del_test = False;
-pattern = re.compile("^\\d+\\.\\d+\\.\\d+\\.\\d+:\\d+$")
-_debug_recursion = 0
-
-def Usage ():
-    print "Usage:  verify_cluster_objects [OPTIONS] [broker-addr]"
-    print
-    print "             broker-addr is in the form:   [username/password@] hostname | ip-address [:<port>]"
-    print "             ex:  localhost, 10.1.1.7:10000, broker-host:10000, guest/guest@localhost"
-    print
-    print "    This program contacts every node of a cluster, loads all manageable objects from"
-    print "    those nodes and verifies that the management data is identical across the clusters."
-    print
-    print "Options:"
-    print "    --timeout seconds (10)  Maximum time to wait for broker connection"
-    print "    --verbose level (0)     Show details of objects and their IDs"
-    print "    --delete                Delete some objects after creation, to test synchup"
-    print
-    sys.exit (1)
-
-class IpAddr:
-    def __init__(self, text):
-        if text.find("@") != -1:
-            tokens = text.split("@")
-            text = tokens[1]
-        if text.find(":") != -1:
-            tokens = text.split(":")
-            text = tokens[0]
-            self.port = int(tokens[1])
-        else:
-            self.port = 5672
-        self.dottedQuad = socket.gethostbyname(text)
-        nums = self.dottedQuad.split(".")
-        self.addr = (int(nums[0]) << 24) + (int(nums[1]) << 16) + (int(nums[2]) << 8) + int(nums[3])
-
-    def bestAddr(self, addrPortList):
-        bestDiff = 0xFFFFFFFFL
-        bestAddr = None
-        for addrPort in addrPortList:
-            diff = IpAddr(addrPort[0]).addr ^ self.addr
-            if diff < bestDiff:
-                bestDiff = diff
-                bestAddr = addrPort
-        return bestAddr
-
-class ObjectId:
-    """Object identity, use for dictionaries by object id"""
-    def __init__(self, object): self.object = object
-    def __eq__(self, other): return self.object is other.object
-    def __hash__(self): return hash(id(self.object))
-
-class Broker(object):
-    def __init__(self, qmf, broker):
-        self.broker = broker
-        self.qmf = qmf
-
-        agents = qmf.getAgents()
-        for a in agents:
-            if a.getAgentBank() == '0':
-                self.brokerAgent = a
-
-        bobj = qmf.getObjects(_class="broker", _package="org.apache.qpid.broker",
-                              _agent=self.brokerAgent)[0]
-        self.currentTime = bobj.getTimestamps()[0]
-        try:
-            self.uptime = bobj.uptime
-        except:
-            self.uptime = 0
-        self.tablesByName = {}
-        self.package = "org.apache.qpid.broker"
-        self.id_cache = {}              # Cache for getAbstractId
-
-    def getUrl(self):
-        return self.broker.getUrl()
-
-    def getData(self):
-        if _verbose > 1:
-            print "Broker:", self.broker
-
-        classList = self.qmf.getClasses(self.package)
-        for cls in classList:
-            if self.qmf.getSchema(cls).kind == SchemaClass.CLASS_KIND_TABLE:
-                self.loadTable(cls)
+# Verify managment objects are consistent in a cluster.
+# Arguments: url of one broker in the cluster.
 
+import qmf.console, sys, re
 
-    #
-    # this should be a method on an object, but is kept here for now, until
-    # we finish sorting out the treatment of names in qmfv2
-    #
-    def getAbstractId(self, object):
-      """ return a string the of the hierarchical name """
-      if (ObjectId(object) in self.id_cache): return self.id_cache[ObjectId(object)]
-      global _debug_recursion
-      result = u""
-      valstr = u""
-      _debug_recursion += 1
-      debug_prefix = _debug_recursion
-      if (_verbose > 9):
-          print debug_prefix, "  enter gai: props ", object._properties
-      for property, value in object._properties:
+class Session(qmf.console.Session):
+    """A qmf.console.Session that caches useful values"""
 
-          # we want to recurse on things which are refs.  we tell by
-          # asking each property if it's an index.  I think...
-          if (_verbose > 9):
-              print debug_prefix, "  prop ", property, " val " , value, " idx ", 
-              property.index, " type ", property.type
-
-          # property is an instance, you can ask its type, name, etc.
-
-          # special case system refs, as they will never be the same on
-          # distinct cluster nodes.  later we probably want a different
-          # way of representing these objects, like for instance don't
-          # include the system ref in the hierarchy.
-
-          if property.name == "systemRef":
-              _debug_recursion -= 1
-              self.id_cache[ObjectId(object)] = ""
-              return ""
-
-          if property.index:
-              if result != u"":
-                  result += u":"
-              if property.type == 10:
-                  try:
-                      recursive_objects = object._session.getObjects(_objectId = value, _broker=object._broker)
-                      if (_verbose > 9):
-                          print debug_prefix, "   r ", recursive_objects[0]
-                          for rp, rv in recursive_objects[0]._properties:
-                              print debug_prefix, "   rrr ", rp, " idx-p ", rp.index, " v ", rv
-                          print debug_prefix, "    recursing on ", recursive_objects[0]
-                      valstr = self.getAbstractId(recursive_objects[0])
-                      if (_verbose > 9):
-                          print debug_prefix,  "    recursing on ", recursive_objects[0],
-                          " -> ", valstr
-                  except Exception, e:
-                      if (_verbose > 9):
-                          print debug_prefix, "          except ", e
-                      valstr = u"<undecodable>"
-              else:
-                  # this yields UUID-blah.  not good.  try something else
-                  # valstr = value.__repr__()
-                  # print debug_prefix, " val ", value
-          
-                  # yetch.  this needs to be abstracted someplace?  I don't
-                  # think we have the infrastructure we need to make these id
-                  # strings be sensible in the general case
-                  if property.name == "systemId":
-                      # special case.  try to do something sensible about systemref objects
-                      valstr = object.nodeName
-                  else:
-                      valstr = value.__repr__() # I think...
-          result += valstr
-          if (_verbose > 9):
-              print debug_prefix, "    id ", self, " -> ", result
-      _debug_recursion -= 1
-      self.id_cache[ObjectId(object)] = result
-      return result
-
-    def loadTable(self, cls):
-        if _verbose > 1:
-            print "  Class:", cls.getClassName()
-        list = self.qmf.getObjects(_class=cls.getClassName(),
-                                   _package=cls.getPackageName(),
-                                   _agent=self.brokerAgent)
-
-        # tables-by-name maps class name to a table by object-name of
-        # objects.  ie use the class name ("broker", "queue", etc) to
-        # index tables-by-name, returning a second table, use the
-        # object name to index that to get an object.
-
-        self.tablesByName[cls.getClassName()] = {}
-        for obj in list:
-            # make sure we aren't colliding on name.  it's an internal
-            # error (ie, the name-generation code is busted) if we do
-            key = self.getAbstractId(obj)
-            if key in self.tablesByName[cls.getClassName()]:
-                raise Exception("internal error: collision for %s on key %s\n"
-                                % (obj, key))
-                
-            self.tablesByName[cls.getClassName()][key] = obj
-            if _verbose > 1:
-                print "   ", obj.getObjectId(), " ", obj.getIndex(), " ", key
-
-
-class BrokerManager:
     def __init__(self):
-        self.brokerName = None
-        self.qmf        = None
-        self.broker     = None
-        self.brokers    = []
-        self.cluster    = None
-
-    def SetBroker(self, brokerUrl):
-        self.url = brokerUrl
-        self.qmf = Session()
-        self.broker = self.qmf.addBroker(brokerUrl, _connTimeout)
-        agents = self.qmf.getAgents()
-        for a in agents:
-            if a.getAgentBank() == '0':
-                self.brokerAgent = a
-
-    def Disconnect(self):
-        if self.broker:
-            self.qmf.delBroker(self.broker)
-
-    def _getCluster(self):
-        packages = self.qmf.getPackages()
-        if "org.apache.qpid.cluster" not in packages:
-            return None
+        qmf.console.Session.__init__(self)
+        self.classes = None
 
-        clusters = self.qmf.getObjects(_class="cluster", _agent=self.brokerAgent)
-        if len(clusters) == 0:
-            print "Clustering is installed but not enabled on the broker."
-            return None
+    def all_classes(self):
+        if self.classes is None:
+            self.classes = [c for p in self.getPackages() for c in self.getClasses(p)]
+        return self.classes
 
-        self.cluster = clusters[0]
-
-    def _getHostList(self, urlList):
-        hosts = []
-        hostAddr = IpAddr(_host)
-        for url in urlList:
-            if url.find("amqp:") != 0:
-                raise Exception("Invalid URL 1")
-            url = url[5:]
-            addrs = str(url).split(",")
-            addrList = []
-            for addr in addrs:
-                tokens = addr.split(":")
-                if len(tokens) != 3:
-                    raise Exception("Invalid URL 2")
-                addrList.append((tokens[1], tokens[2]))
-
-            # Find the address in the list that is most likely to be
-            # in the same subnet as the address with which we made the
-            # original QMF connection.  This increases the probability
-            # that we will be able to reach the cluster member.
-
-            best = hostAddr.bestAddr(addrList)
-            bestUrl = best[0] + ":" + best[1]
-            hosts.append(bestUrl)
-        return hosts
-
-
-    # the main fun which tests for broker state "identity".  now that
-    # we're using qmf2 style object names across the board, that test
-    # means that we are ensuring that for all objects of a given
-    # class, an object of that class with the same object name exists
-    # on the peer broker.
-
-    def verify(self):
-        if _verbose > 0:
-            print "Connecting to the cluster..."
-        self._getCluster()
-        if self.cluster:
-            memberList = self.cluster.members.split(";")
-            hostList = self._getHostList(memberList)
-            self.qmf.delBroker(self.broker)
-            self.broker = None
-            for host in hostList:
-                b = self.qmf.addBroker(host, _connTimeout)
-                self.brokers.append(Broker(self.qmf, b))
-                if _verbose > 0:
-                    print "   ", b
-        else:
-            raise Exception("Failed - Not a cluster")
-
-        failures = []
-
-        # Wait until connections to all nodes are established before
-        # loading the management data.  This will ensure that the
-        # objects are all stable and the same.
-        if _verbose > 0:
-            print "Loading management data from nodes..."
-        for broker in self.brokers:
-            broker.getData()
-
-        # If we're testing delete-some-objects functionality, create a
-        # few widgets here and then delete them.
-        if _del_test:
-            if _verbose > 0:
-                print "Running delete test"
-            # just stick 'em in the first broker
-            b = self.brokers[0]
-            session = b.qmf.brokers[0].getAmqpSession()
-            session.queue_declare(queue="foo", exclusive=True, auto_delete=True)
-            session.exchange_bind(exchange="amq.direct",
-                                                 queue="foo", binding_key="foo")
-            session.queue_declare(queue="bar", exclusive=True, auto_delete=True)
-            session.exchange_bind(exchange="amq.direct",
-                                                 queue="bar", binding_key="bar")
-            # now delete 'em
-            session.exchange_unbind(queue="foo", exchange="amq.direct", binding_key="foo")
-            session.exchange_unbind(queue="bar", exchange="amq.direct", binding_key="bar")
-            session.queue_delete("bar")
-            session.queue_delete("foo")
-
-        # Verify that each node has the same set of objects (based on
-        # object name).
-        if _verbose > 0:
-            print "Verifying objects based on object name..."
-        base = self.brokers[0]
-        for broker in self.brokers[1:]:
-
-            # walk over the class names, for each class (with some
-            # exceptions) walk over the objects of that class, making
-            # sure they match between broker A and broker B
-
-            for className in base.tablesByName:
-                if className in ["broker", "system", "connection"]:
-                    continue
-
-                tab1 = base.tablesByName[className]
-                tab2 = broker.tablesByName[className]
-
-                for key in tab1:
-                    if key not in tab2:
-                        failures.append("%s key %s not found on node %s" %
-                                        (className, key, broker.getUrl()))
-                for key in tab2:
-                    if key not in tab1:
-                        failures.append("%s key %s not found on node %s" %
-                                        (className, key, base.getUrl()))
-
-        if len(failures) > 0:
-            print "Failures:"
-            for failure in failures:
-                print "  %s" % failure
-            raise Exception("Failures")
-
-        if _verbose > 0:
-            print "Success"
-
-##
-## Main Program
-##
-
-try:
-    longOpts = ("verbose=", "timeout=", "delete")
-    (optlist, encArgs) = getopt.gnu_getopt(sys.argv[1:], "", longOpts)
-except:
-    Usage()
-
-try:
-    encoding = locale.getpreferredencoding()
-    cargs = [a.decode(encoding) for a in encArgs]
-except:
-    cargs = encArgs
-
-for opt in optlist:
-    if opt[0] == "--timeout":
-        _connTimeout = int(opt[1])
-        if _connTimeout == 0:
-            _connTimeout = None
-    elif opt[0] == "--verbose":
-        _verbose = int(opt[1])
-    elif opt[0] == "--delete":
-        _del_test = True;
-    else:
-        Usage()
-
-nargs = len(cargs)
-bm    = BrokerManager()
-
-if nargs == 1:
-    _host = cargs[0]
-
-try:
-    bm.SetBroker(_host)
-    bm.verify()
-except KeyboardInterrupt:
-    print
-except Exception,e:
-    print "Failed: %s - %s" % (e.__class__.__name__, e)
-    sys.exit(1)
-
-bm.Disconnect()
+class Broker:
+    def __init__(self, url, qmf):
+        self.url = url
+        self.qmf = qmf
+        self.broker = self.qmf.addBroker(url)
+        self.broker._waitForStable()
+        self.objects = None
+        self.ignore_list = [ re.compile("org.apache.qpid.broker:system:") ]
+
+    def get_objects(self):
+        def ignore(name):
+            for m in (m for m in self.ignore_list if m.match(name)):
+                return True
+        if self.objects is None:
+            obj_list = []
+            for c in self.qmf.all_classes():
+                for o in self.qmf.getObjects(_key=c, _broker=self.broker):
+                    name=o.getObjectId().getObject()
+                    if not ignore(name): obj_list.append(name)
+            self.objects = set(obj_list)
+            if (len(obj_list) != len(self.objects)):
+                raise Exception("Duplicates in object list for %s"%(self.url))
+        return self.objects
+
+    def compare(self,other):
+        def compare1(x,y):
+            diff = x.get_objects() - y.get_objects()
+            if diff:
+                print "ERROR: found on %s but not %s"%(x, y)
+                for o in diff: print "    %s"%(o)
+                return False
+            return True
+
+        so = compare1(self, other)
+        os = compare1(other, self)
+        return so and os
+
+    def __str__(self): return self.url
+
+    def get_cluster(self):
+        """Given one Broker, return list of all brokers in its cluster"""
+        clusters = self.qmf.getObjects(_class="cluster")
+        if not clusters: raise ("%s is not a cluster member"%(self.url))
+        def first_address(url):
+            """Python doesn't understand the brokers URL syntax. Extract a simple addres"""
+            return re.compile("amqp:tcp:([^,]*)").match(url).group(1)
+        return [Broker(first_address(url), self.qmf) for url in clusters[0].members.split(";")]
+
+    def __del__(self): self.qmf.delBroker(self.broker)
+
+def main(argv=None):
+    if argv is None: argv = sys.argv
+    qmf = Session()
+    brokers = Broker(argv[1], qmf).get_cluster()
+    base = brokers.pop(0)
+    result = 0
+    for b in brokers:
+        if not base.compare(b): result = 1
+    del base
+    del brokers
+    return result
+
+if __name__ == "__main__": sys.exit(main())
diff --git a/qpid/cpp/xml/cluster.xml b/qpid/cpp/xml/cluster.xml
index 30cd159..25ad978 100644
--- a/qpid/cpp/xml/cluster.xml
+++ b/qpid/cpp/xml/cluster.xml
@@ -134,7 +134,9 @@
     </control>
 
     <!-- Marks the cluster-wide point when a connection is considered closed. -->
-    <control name="deliver-close" code="0x2"/>
+    <control name="deliver-close" code="0x2">
+      <field name="aborted" type="bit"/>
+    </control>
 
     <!-- Permission to generate output up to the limit. -->
     <control name="deliver-do-output" code="0x3">
-- 
1.7.1.1

From 5fbdc4c62f80ea01c9bd82187b1decdca36dde7e Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 22 Jun 2010 15:42:35 +0000
Subject: [PATCH 074/129] Bug 603896 - Fixed - Message traffic freezes after queues back up

Don't hold QueueRegistry lock while iterating over queues to purge them of expired messages.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@956923 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 1a85afb37de55697e172acd001db98dd9b4722a1)
---
 qpid/cpp/src/qpid/broker/QueueCleaner.cpp |   18 +++++++++++++++++-
 1 files changed, 17 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/QueueCleaner.cpp b/qpid/cpp/src/qpid/broker/QueueCleaner.cpp
index c80fe89..ed98468 100644
--- a/qpid/cpp/src/qpid/broker/QueueCleaner.cpp
+++ b/qpid/cpp/src/qpid/broker/QueueCleaner.cpp
@@ -46,9 +46,25 @@ void QueueCleaner::Task::fire()
     parent.fired();
 }
 
+namespace {
+struct CollectQueues
+{
+    std::vector<Queue::shared_ptr>* queues;
+    CollectQueues(std::vector<Queue::shared_ptr>* q) : queues(q) {}
+    void operator()(Queue::shared_ptr q)
+    {
+        queues->push_back(q);
+    }
+};
+}
+
 void QueueCleaner::fired()
 {
-    queues.eachQueue(boost::bind(&Queue::purgeExpired, _1));
+    //collect copy of list of queues to avoid holding registry lock while we perform purge
+    std::vector<Queue::shared_ptr> copy;
+    CollectQueues collect(&copy);
+    queues.eachQueue(collect);
+    std::for_each(copy.begin(), copy.end(), boost::bind(&Queue::purgeExpired, _1));
     task->setupNextFire();
     timer.add(task);
 }
-- 
1.7.1.1

From 7361da16e3ffdd0b3b4804d774ae768503c2460c Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Tue, 22 Jun 2010 18:13:35 +0000
Subject: [PATCH 075/129] Bug 605763 - Failures in long cluster_tests.test_management

Fix bad assertion introduced in prevoius commit r956882

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@956965 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 9f875847254c6a47f7fc9fef3fcfee7e0391d39e)
---
 qpid/cpp/src/qpid/sys/ClusterSafe.cpp |    6 +++---
 qpid/cpp/src/qpid/sys/ClusterSafe.h   |    5 ++++-
 2 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
index 6105fc9..c6b527d 100644
--- a/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
+++ b/qpid/cpp/src/qpid/sys/ClusterSafe.cpp
@@ -43,14 +43,14 @@ void assertClusterSafe()  {
     }
 }
 
-ClusterSafeScope::ClusterSafeScope() {
-    assert(!inContext);
+ClusterSafeScope::ClusterSafeScope()  {
+    save = inContext;
     inContext = true;
 }
 
 ClusterSafeScope::~ClusterSafeScope() {
     assert(inContext);
-    inContext = false;
+    inContext = save;
 }
 
 void enableClusterSafe() { inCluster = true; }
diff --git a/qpid/cpp/src/qpid/sys/ClusterSafe.h b/qpid/cpp/src/qpid/sys/ClusterSafe.h
index f338230..15675e8 100644
--- a/qpid/cpp/src/qpid/sys/ClusterSafe.h
+++ b/qpid/cpp/src/qpid/sys/ClusterSafe.h
@@ -61,9 +61,12 @@ QPID_COMMON_EXTERN bool isCluster();
  * and provides functions to assist detecting bugs in cluster
  * behavior.
  */
-struct ClusterSafeScope {
+class ClusterSafeScope {
+  public:
     ClusterSafeScope();
     ~ClusterSafeScope();
+  private:
+    bool save;
 };
 
 /**
-- 
1.7.1.1

From 60a76e31d0b05c93662101a61bf573067440daec Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 22 Jun 2010 19:27:12 +0000
Subject: [PATCH 076/129] Bug 606824 - Fixed - Acquired but Not Accepted Messages Not Sent to Alternate Exchange

QPID-2688: ensure that unacked messages are requeued before autodeletion occurs when session closes

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@956988 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 91c77007649756868748b02fa8fd7ff9d6e881b4)
---
 qpid/cpp/src/qpid/broker/SemanticState.cpp |   41 +++++++++++++++++++++------
 qpid/cpp/src/qpid/broker/SemanticState.h   |    4 +++
 qpid/cpp/src/qpid/broker/SessionState.cpp  |    1 +
 3 files changed, 37 insertions(+), 9 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/SemanticState.cpp b/qpid/cpp/src/qpid/broker/SemanticState.cpp
index b8981b4..c91cfba 100644
--- a/qpid/cpp/src/qpid/broker/SemanticState.cpp
+++ b/qpid/cpp/src/qpid/broker/SemanticState.cpp
@@ -73,21 +73,34 @@ SemanticState::SemanticState(DeliveryAdapter& da, SessionContext& ss)
       authMsg(getSession().getBroker().getOptions().auth && !getSession().getConnection().isFederationLink()),
       userID(getSession().getConnection().getUserId()),
       userName(getSession().getConnection().getUserId().substr(0,getSession().getConnection().getUserId().find('@'))),
-      isDefaultRealm(userID.find('@') != std::string::npos && getSession().getBroker().getOptions().realm == userID.substr(userID.find('@')+1,userID.size()))
+      isDefaultRealm(userID.find('@') != std::string::npos && getSession().getBroker().getOptions().realm == userID.substr(userID.find('@')+1,userID.size())),
+      closeComplete(false)
 {
     acl = getSession().getBroker().getAcl();
 }
 
 SemanticState::~SemanticState() {
-    //cancel all consumers
-    for (ConsumerImplMap::iterator i = consumers.begin(); i != consumers.end(); i++) {
-        cancel(i->second);
-    }
+    closed();
+}
 
-    if (dtxBuffer.get()) {
-        dtxBuffer->fail();
+void SemanticState::closed() {
+    if (!closeComplete) {
+        //prevent requeued messages being redelivered to consumers
+        for (ConsumerImplMap::iterator i = consumers.begin(); i != consumers.end(); i++) {
+            disable(i->second);
+        }        
+        if (dtxBuffer.get()) {
+            dtxBuffer->fail();
+        }
+        recover(true);
+
+        //now unsubscribe, which may trigger queue deletion and thus
+        //needs to occur after the requeueing of unacked messages
+        for (ConsumerImplMap::iterator i = consumers.begin(); i != consumers.end(); i++) {
+            unsubscribe(i->second);
+        }
+        closeComplete = true;
     }
-    recover(true);
 }
 
 bool SemanticState::exists(const string& consumerTag){
@@ -389,11 +402,15 @@ SemanticState::ConsumerImpl::~ConsumerImpl()
         mgmtObject->resourceDestroy ();
 }
 
-void SemanticState::cancel(ConsumerImpl::shared_ptr c)
+void SemanticState::disable(ConsumerImpl::shared_ptr c)
 {
     c->disableNotify();
     if (session.isAttached())
         session.getConnection().outputTasks.removeOutputTask(c.get());
+}
+
+void SemanticState::unsubscribe(ConsumerImpl::shared_ptr c)
+{
     Queue::shared_ptr queue = c->getQueue();
     if(queue) {
         queue->cancel(c);
@@ -403,6 +420,12 @@ void SemanticState::cancel(ConsumerImpl::shared_ptr c)
     }
 }
 
+void SemanticState::cancel(ConsumerImpl::shared_ptr c)
+{
+    disable(c);
+    unsubscribe(c);
+}
+
 void SemanticState::handle(intrusive_ptr<Message> msg) {
     if (txBuffer.get()) {
         TxPublish* deliverable(new TxPublish(msg));
diff --git a/qpid/cpp/src/qpid/broker/SemanticState.h b/qpid/cpp/src/qpid/broker/SemanticState.h
index cae8527..2b31492 100644
--- a/qpid/cpp/src/qpid/broker/SemanticState.h
+++ b/qpid/cpp/src/qpid/broker/SemanticState.h
@@ -157,6 +157,7 @@ class SemanticState : private boost::noncopyable {
     const string userID;
     const string userName;
     const bool isDefaultRealm;
+    bool closeComplete;
 
     void route(boost::intrusive_ptr<Message> msg, Deliverable& strategy);
     void checkDtxTimeout();
@@ -165,6 +166,8 @@ class SemanticState : private boost::noncopyable {
     AckRange findRange(DeliveryId first, DeliveryId last);
     void requestDispatch();
     void cancel(ConsumerImpl::shared_ptr);
+    void unsubscribe(ConsumerImpl::shared_ptr);
+    void disable(ConsumerImpl::shared_ptr);
 
   public:
     SemanticState(DeliveryAdapter&, SessionContext&);
@@ -220,6 +223,7 @@ class SemanticState : private boost::noncopyable {
 
     void attached();
     void detached();
+    void closed();
 
     // Used by cluster to re-create sessions
     template <class F> void eachConsumer(F f) {
diff --git a/qpid/cpp/src/qpid/broker/SessionState.cpp b/qpid/cpp/src/qpid/broker/SessionState.cpp
index ddf68ca..be4f8c7 100644
--- a/qpid/cpp/src/qpid/broker/SessionState.cpp
+++ b/qpid/cpp/src/qpid/broker/SessionState.cpp
@@ -88,6 +88,7 @@ SessionState::SessionState(
 }
 
 SessionState::~SessionState() {
+    semanticState.closed();
     if (mgmtObject != 0)
         mgmtObject->resourceDestroy ();
 
-- 
1.7.1.1

From c3f1bef98288cc54c6434e295d82bc2dec3888ca Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Wed, 23 Jun 2010 04:52:49 +0000
Subject: [PATCH 077/129] BZ 606761:

QPID-2388: Do not unmask signals whilst waiting for IO to happen
- The client and common libraries do not use signals at all so
  there is no real reason to allow signal handling on IO threads.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957109 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp |   12 ------------
 qpid/cpp/src/tests/DispatcherTest.cpp       |    8 ++------
 2 files changed, 2 insertions(+), 18 deletions(-)

diff --git a/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp b/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
index 9ae9bce..9ad05c7 100644
--- a/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
+++ b/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp
@@ -262,7 +262,6 @@ class PollerPrivate {
     const int epollFd;
     bool isShutdown;
     InterruptHandle interruptHandle;
-    ::sigset_t sigMask;
     HandleSet registeredHandles;
     AtomicCount threadCount;
 
@@ -294,7 +293,6 @@ class PollerPrivate {
         epollFd(::epoll_create(DefaultFds)),
         isShutdown(false) {
         QPID_POSIX_CHECK(epollFd);
-        ::sigemptyset(&sigMask);
         // Add always readable fd into our set (but not listening to it yet)
         ::epoll_event epe;
         epe.events = 0;
@@ -562,17 +560,7 @@ Poller::Event Poller::wait(Duration timeout) {
     // Repeat until we weren't interrupted by signal
     do {
         PollerHandleDeletionManager.markAllUnusedInThisThread();
-        // Need to run on kernels without epoll_pwait()
-        // - fortunately in this case we don't really need the atomicity of epoll_pwait()
-#if 1
-        sigset_t os;
-        pthread_sigmask(SIG_SETMASK, &impl->sigMask, &os);
         int rc = ::epoll_wait(impl->epollFd, &epe, 1, timeoutMs);
-        pthread_sigmask(SIG_SETMASK, &os, 0);
-#else
-        int rc = ::epoll_pwait(impl->epollFd, &epe, 1, timeoutMs, &impl->sigMask);
-#endif
-
         if (rc ==-1 && errno != EINTR) {
             QPID_POSIX_CHECK(rc);
         } else if (rc > 0) {
diff --git a/qpid/cpp/src/tests/DispatcherTest.cpp b/qpid/cpp/src/tests/DispatcherTest.cpp
index 17b3b4e..41e6054 100644
--- a/qpid/cpp/src/tests/DispatcherTest.cpp
+++ b/qpid/cpp/src/tests/DispatcherTest.cpp
@@ -161,12 +161,8 @@ int main(int /*argc*/, char** /*argv*/)
     wh->startWatch(poller);
 
     // Set up a regular itimer interupt
-
-    // Ignore signal in this thread
-    ::sigset_t sm;
-    ::sigemptyset(&sm);
-    ::sigaddset(&sm, SIGRTMIN);
-    ::pthread_sigmask(SIG_BLOCK, &sm, 0);
+    // We assume that this thread will handle the signals whilst sleeping
+    // as the Poller threads have signal handling blocked
 
     // Signal handling
     struct ::sigaction sa;
-- 
1.7.1.1

From 162d3fdea6a041706de430aec6ebdeea0dc1fae6 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Thu, 24 Jun 2010 11:22:28 +0000
Subject: [PATCH 078/129] Bug 607552 - Fixed - ttl is lost for federation routes where trace id is added

QPID-2691: ensure ttl adjustment uses correct expiration on cloned message

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957511 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit f6f5a3deb6dfe337081d58bcb6d97ec4f03e6531)
---
 qpid/cpp/src/qpid/broker/Message.cpp |    7 +++++--
 qpid/cpp/src/qpid/broker/Queue.cpp   |    2 +-
 qpid/cpp/src/qpid/broker/Queue.h     |    2 +-
 qpid/cpp/src/tests/federation.py     |    4 +++-
 4 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Message.cpp b/qpid/cpp/src/qpid/broker/Message.cpp
index 1e56544..ad67bff 100644
--- a/qpid/cpp/src/qpid/broker/Message.cpp
+++ b/qpid/cpp/src/qpid/broker/Message.cpp
@@ -55,8 +55,11 @@ Message::Message(const framing::SequenceNumber& id) :
 Message::Message(const Message& original) :
     PersistableMessage(), frames(original.frames), persistenceId(0), redelivered(false), loaded(false),
     staged(false), forcePersistentPolicy(false), publisher(0), adapter(0), 
-    expiration(FAR_FUTURE), enqueueCallback(0), dequeueCallback(0),
-    inCallback(false), requiredCredit(0) {}
+    expiration(original.expiration), enqueueCallback(0), dequeueCallback(0),
+    inCallback(false), requiredCredit(0) 
+{
+    setExpiryPolicy(original.expiryPolicy);
+}
 
 Message::~Message()
 {
diff --git a/qpid/cpp/src/qpid/broker/Queue.cpp b/qpid/cpp/src/qpid/broker/Queue.cpp
index 7f7b2bc..dd077aa 100644
--- a/qpid/cpp/src/qpid/broker/Queue.cpp
+++ b/qpid/cpp/src/qpid/broker/Queue.cpp
@@ -141,7 +141,7 @@ bool Queue::isExcluded(boost::intrusive_ptr<Message>& msg)
     return traceExclude.size() && msg->isExcluded(traceExclude);
 }
 
-void Queue::deliver(boost::intrusive_ptr<Message>& msg){
+void Queue::deliver(boost::intrusive_ptr<Message> msg){
     if (msg->isImmediate() && getConsumerCount() == 0) {
         if (alternateExchange) {
             DeliverableMessage deliverable(msg);
diff --git a/qpid/cpp/src/qpid/broker/Queue.h b/qpid/cpp/src/qpid/broker/Queue.h
index ebef6e4..41c6b46 100644
--- a/qpid/cpp/src/qpid/broker/Queue.h
+++ b/qpid/cpp/src/qpid/broker/Queue.h
@@ -211,7 +211,7 @@ namespace qpid {
              * Delivers a message to the queue. Will record it as
              * enqueued if persistent then process it.
              */
-            QPID_BROKER_EXTERN void deliver(boost::intrusive_ptr<Message>& msg);
+            QPID_BROKER_EXTERN void deliver(boost::intrusive_ptr<Message> msg);
             /**
              * Dispatches the messages immediately to a consumer if
              * one is available or stores it for later if not.
diff --git a/qpid/cpp/src/tests/federation.py b/qpid/cpp/src/tests/federation.py
index d7f9342..63e3f2b 100755
--- a/qpid/cpp/src/tests/federation.py
+++ b/qpid/cpp/src/tests/federation.py
@@ -358,7 +358,7 @@ class FederationTests(TestBase010):
         for b, t in zip(body, trace):
             headers = {}
             if (t): headers["x-qpid.trace"]=t
-            dp = r_session.delivery_properties(routing_key="my-key")
+            dp = r_session.delivery_properties(routing_key="my-key", ttl=1000*60*5)
             mp = r_session.message_properties(application_headers=headers)
             r_session.message_transfer(destination="amq.direct", message=Message(dp, mp, b))
 
@@ -366,6 +366,8 @@ class FederationTests(TestBase010):
             msg = queue.get(timeout=5)
             self.assertEqual("yes", msg.body)
             self.assertEqual(e, self.getAppHeader(msg, "x-qpid.trace"))
+            assert(msg.get("delivery_properties").ttl > 0)
+            assert(msg.get("delivery_properties").ttl < 1000*60*50)
 
         try:
             extra = queue.get(timeout=1)
-- 
1.7.1.1

From abe5059836d94a9aa121e1211f080a4b3d2c03eb Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Thu, 24 Jun 2010 11:34:18 +0000
Subject: [PATCH 079/129] Bug 607550 - Fixed - spout: Ignoring frame while closing connection

Ensure spout example waits for all messages to be sent before detaching session

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957513 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 9b98d16351d428295a9108ff53994bc80f92e46d)
---
 qpid/cpp/examples/messaging/spout.cpp |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/examples/messaging/spout.cpp b/qpid/cpp/examples/messaging/spout.cpp
index e100560..57b955c 100644
--- a/qpid/cpp/examples/messaging/spout.cpp
+++ b/qpid/cpp/examples/messaging/spout.cpp
@@ -161,6 +161,7 @@ int main(int argc, char** argv)
                 message.getProperties()["spout-id"] = spoutid.str();
                 sender.send(message);
             }
+            session.sync();
             connection.close();
             return 0;
         } catch(const std::exception& error) {
-- 
1.7.1.1

From da98116bb0e911c9f491c942790ff33543e14571 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Thu, 24 Jun 2010 17:19:58 +0000
Subject: [PATCH 080/129] Bug 604842 - cluster_test fails intermittently

The bug is fixed by this and other commits leading up to it.

Fix regression in r956882, sporadic failures of client_test.cpp:testBadClientData

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957640 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit bc5441acda9f35bef338677868e46145ce7a418b)
---
 qpid/cpp/src/qpid/cluster/Connection.cpp |   23 +++++++++--------------
 qpid/cpp/src/qpid/cluster/Connection.h   |    2 +-
 qpid/cpp/xml/cluster.xml                 |    4 +---
 3 files changed, 11 insertions(+), 18 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index e0c0465..04aced5 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -262,7 +262,7 @@ void Connection::closed() {
             // until self-delivery of deliver-close.
             output.closeOutput();
             cluster.getMulticast().mcastControl(
-                ClusterConnectionDeliverCloseBody(ProtocolVersion(), false), self);
+                ClusterConnectionDeliverCloseBody(), self);
         }
     }
     catch (const std::exception& e) {
@@ -271,31 +271,26 @@ void Connection::closed() {
 }
 
 // Self-delivery of close message, close the connection.
-void Connection::deliverClose (bool aborted) {
-    QPID_LOG(debug, cluster << " replicated close of " << *this);
-    if (connection.get()) {
-        if (aborted) connection->abort();
-        else connection->closed();
-        connection.reset();
-    }
+void Connection::deliverClose () {
+    close();
     cluster.erase(self);
 }
 
 // Close the connection
 void Connection::close() {
-    QPID_LOG(debug, cluster << " local close of " << *this);
     if (connection.get()) {
+        QPID_LOG(debug, cluster << " closed connection " << *this);
         connection->closed();
         connection.reset();
     }
 }
 
-// The connection has been killed for misbehaving, called in connection thread.
+// The connection has sent invalid data and should be aborted.
+// All members will get the same abort since they all process the same data.
 void Connection::abort() {
-    if (connection.get()) {
-        cluster.getMulticast().mcastControl(
-            ClusterConnectionDeliverCloseBody(ProtocolVersion(), true), self);
-    }
+    connection->abort();
+    // Aborting the connection will result in a call to ::closed()
+    // and allow the connection to close in an orderly manner.
 }
 
 // ConnectionCodec::decode receives read buffers from  directly-connected clients.
diff --git a/qpid/cpp/src/qpid/cluster/Connection.h b/qpid/cpp/src/qpid/cluster/Connection.h
index 72a98c1..aec18d7 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.h
+++ b/qpid/cpp/src/qpid/cluster/Connection.h
@@ -170,7 +170,7 @@ class Connection :
                   const std::string& initFrames);
     void close();
     void abort();
-    void deliverClose(bool);
+    void deliverClose();
 
     OutputInterceptor& getOutput() { return output; }
 
diff --git a/qpid/cpp/xml/cluster.xml b/qpid/cpp/xml/cluster.xml
index 25ad978..30cd159 100644
--- a/qpid/cpp/xml/cluster.xml
+++ b/qpid/cpp/xml/cluster.xml
@@ -134,9 +134,7 @@
     </control>
 
     <!-- Marks the cluster-wide point when a connection is considered closed. -->
-    <control name="deliver-close" code="0x2">
-      <field name="aborted" type="bit"/>
-    </control>
+    <control name="deliver-close" code="0x2"/>
 
     <!-- Permission to generate output up to the limit. -->
     <control name="deliver-do-output" code="0x3">
-- 
1.7.1.1

From 3f3e6086766770c3d7e1a7cf9afdfaedce82dd18 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Thu, 24 Jun 2010 17:34:34 +0000
Subject: [PATCH 081/129] BZ-560707 added full support for unreliable, at-least-once, and at-most-once reliability options

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957644 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py          |   59 +++++++++++++++++--------
 qpid/python/qpid/tests/messaging/endpoints.py |   27 +++++++++++
 2 files changed, 68 insertions(+), 18 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 7f04903..76ccd54 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -95,6 +95,7 @@ CLIENT_PROPERTIES = {"product": "qpid python client",
                      "qpid.client_ppid": ppid}
 
 def noop(): pass
+def sync_noop(): pass
 
 class SessionState:
 
@@ -136,7 +137,7 @@ class SessionState:
     if overrides:
       self.apply_overrides(cmd, overrides)
 
-    if sync or action != noop:
+    if action != noop:
       cmd.sync = sync
     if self.detached:
       raise Exception("detached")
@@ -215,11 +216,14 @@ class LinkIn:
 
   def do_link(self, sst, rcv, _rcv, type, subtype, action):
     link_opts = _rcv.options.get("link", {})
-    # XXX: default?
-    reliability = link_opts.get("reliability", "unreliable")
+    reliability = link_opts.get("reliability", "at-least-once")
     declare = link_opts.get("x-declare", {})
     subscribe = link_opts.get("x-subscribe", {})
     acq_mode = acquire_mode.pre_acquired
+    if reliability in ("unreliable", "at-most-once"):
+      rcv._accept_mode = accept_mode.none
+    else:
+      rcv._accept_mode = accept_mode.explicit
 
     if type == "topic":
       default_name = "%s.%s" % (rcv.session.name, _rcv.destination)
@@ -239,9 +243,12 @@ class LinkIn:
         acq_mode = acquire_mode.not_acquired
       bindings = get_bindings(link_opts, queue=_rcv._queue)
 
+
     sst.write_cmds(bindings)
-    sst.write_cmd(MessageSubscribe(queue=_rcv._queue, destination=_rcv.destination,
-                                   acquire_mode = acq_mode),
+    sst.write_cmd(MessageSubscribe(queue=_rcv._queue,
+                                   destination=_rcv.destination,
+                                   acquire_mode = acq_mode,
+                                   accept_mode = rcv._accept_mode),
                   overrides=subscribe)
     sst.write_cmd(MessageSetFlowMode(_rcv.destination, flow_mode.credit), action)
 
@@ -263,9 +270,12 @@ class LinkOut:
 
   def init_link(self, sst, snd, _snd):
     _snd.closing = False
+    _snd.pre_ack = False
 
   def do_link(self, sst, snd, _snd, type, subtype, action):
     link_opts = _snd.options.get("link", {})
+    reliability = link_opts.get("reliability", "at-least-once")
+    _snd.pre_ack = reliability in ("unreliable", "at-most-once")
     if type == "topic":
       _snd._exchange = _snd.name
       _snd._routing_key = _snd.subject
@@ -968,32 +978,34 @@ class Engine:
 
     for snd in ssn.senders:
       if snd.synced >= snd.queued and sst.need_sync:
-        sst.write_cmd(ExecutionSync(), sync=True)
+        sst.write_cmd(ExecutionSync(), sync_noop)
 
     for rcv in ssn.receivers:
       self.process_receiver(rcv)
 
     if ssn.acked:
       messages = ssn.acked[sst.acked_idx:]
-      delta = len(messages)
       if messages:
         ids = RangedSet()
 
         disposed = [(DEFAULT_DISPOSITION, [])]
+        acked = []
         for m in messages:
           # XXX: we're ignoring acks that get lost when disconnected,
           # could we deal this via some message-id based purge?
           if m._transfer_id is None:
-            ssn.acked.remove(m)
-            delta -= 1
+            acked.append(m)
             continue
           ids.add(m._transfer_id)
-          disp = m._disposition or DEFAULT_DISPOSITION
-          last, msgs = disposed[-1]
-          if disp.type is last.type and disp.options == last.options:
-            msgs.append(m)
+          if m._receiver._accept_mode is accept_mode.explicit:
+            disp = m._disposition or DEFAULT_DISPOSITION
+            last, msgs = disposed[-1]
+            if disp.type is last.type and disp.options == last.options:
+              msgs.append(m)
+            else:
+              disposed.append((disp, [m]))
           else:
-            disposed.append((disp, [m]))
+            acked.append(m)
 
         for range in ids:
           sst.executed.add_range(range)
@@ -1004,6 +1016,7 @@ class Engine:
             for m in msgs:
               ssn.acked.remove(m)
               sst.acked_idx -= 1
+              # XXX: should this check accept_mode too?
               if not ssn.transactional:
                 sst.acked.remove(m)
           return ack_ack
@@ -1023,9 +1036,9 @@ class Engine:
             for m in msgs:
               log.debug("SACK[%s]: %s, %s", ssn.log_id, m, m._disposition)
 
-        # XXX: could add messages with _transfer_id of None
         sst.acked.extend(messages)
-        sst.acked_idx += delta
+        sst.acked_idx += len(messages)
+        ack_acker(acked)()
 
     if ssn.committing and not sst.committing:
       def commit_ok():
@@ -1173,10 +1186,20 @@ class Engine:
       sst.outgoing_idx -= 1
       log.debug("RACK[%s]: %s", sst.session.log_id, msg)
       assert msg == m
-    sst.write_cmd(MessageTransfer(destination=_snd._exchange, headers=(dp, mp),
-                                  payload=body), msg_acked, sync=msg._sync)
+
+    xfr = MessageTransfer(destination=_snd._exchange, headers=(dp, mp),
+                          payload=body)
+
+    if _snd.pre_ack:
+      sst.write_cmd(xfr)
+    else:
+      sst.write_cmd(xfr, msg_acked, sync=msg._sync)
+
     log.debug("SENT[%s]: %s", sst.session.log_id, msg)
 
+    if _snd.pre_ack:
+      msg_acked()
+
   def do_message_transfer(self, xfr):
     sst = self.get_sst(xfr)
     ssn = sst.session
diff --git a/qpid/python/qpid/tests/messaging/endpoints.py b/qpid/python/qpid/tests/messaging/endpoints.py
index 3133fe7..dce8d9b 100644
--- a/qpid/python/qpid/tests/messaging/endpoints.py
+++ b/qpid/python/qpid/tests/messaging/endpoints.py
@@ -685,6 +685,33 @@ class ReceiverTests(Base):
 
   # XXX: need testUnsettled()
 
+  def unreliabilityTest(self, mode="unreliable"):
+    msgs = [self.message("testUnreliable", i) for i in range(3)]
+    snd = self.ssn.sender("test-unreliability-queue; {create: sender, delete: receiver}")
+    rcv = self.ssn.receiver(snd.target)
+    for m in msgs:
+      snd.send(m)
+
+    # close without ack on reliable receiver, messages should be requeued
+    ssn = self.conn.session()
+    rrcv = ssn.receiver("test-unreliability-queue")
+    self.drain(rrcv, expected=msgs)
+    ssn.close()
+
+    # close without ack on unreliable receiver, messages should not be requeued
+    ssn = self.conn.session()
+    urcv = ssn.receiver("test-unreliability-queue; {link: {reliability: %s}}" % mode)
+    self.drain(urcv, expected=msgs, redelivered=True)
+    ssn.close()
+
+    self.assertEmpty(rcv)
+
+  def testUnreliable(self):
+    self.unreliabilityTest(mode="unreliable")
+
+  def testAtMostOnce(self):
+    self.unreliabilityTest(mode="at-most-once")
+
 class AddressTests(Base):
 
   def setup_connection(self):
-- 
1.7.1.1

From 495213b8cc66dc00c15662c559a48dcf04516fd7 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Fri, 25 Jun 2010 17:09:05 +0000
Subject: [PATCH 082/129] BZ-569515 added optional timeouts to {connection,session,sender,receiver}.close() as well as connection.detach() and {session,sender}.sync()

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958037 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py          |    2 +
 qpid/python/qpid/messaging/endpoints.py       |   57 +++++++++-----
 qpid/python/qpid/messaging/exceptions.py      |    5 +
 qpid/python/qpid/tests/messaging/__init__.py  |    6 +-
 qpid/python/qpid/tests/messaging/endpoints.py |  103 ++++++++++++++++++++++++-
 5 files changed, 148 insertions(+), 25 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 76ccd54..6dab24d 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -357,6 +357,8 @@ class Driver:
 
   def stop(self):
     self._selector.unregister(self)
+    if self._transport:
+      self.st_closed()
 
   def fileno(self):
     return self._transport.fileno()
diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 58a654e..30f51fe 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -251,15 +251,18 @@ class Connection:
             if not (l.linked or l.error or l.closed)]
 
   @synchronized
-  def detach(self):
+  def detach(self, timeout=None):
     """
     Detach from the remote endpoint.
     """
     self._connected = False
     self._wakeup()
-    self._wait(lambda: not self._transport_connected)
-    self._driver.stop()
-    self._condition.gc()
+    try:
+      if not self._wait(lambda: not self._transport_connected, timeout=timeout):
+        raise Timeout("detach timed out")
+    finally:
+      self._driver.stop()
+      self._condition.gc()
 
   @synchronized
   def attached(self):
@@ -269,15 +272,15 @@ class Connection:
     return self._connected
 
   @synchronized
-  def close(self):
+  def close(self, timeout=None):
     """
     Close the connection and all sessions.
     """
     try:
       for ssn in self.sessions.values():
-        ssn.close()
+        ssn.close(timeout=timeout)
     finally:
-      self.detach()
+      self.detach(timeout=timeout)
       self._open = False
 
 class Session:
@@ -677,28 +680,32 @@ class Session:
     assert self.aborted
 
   @synchronized
-  def sync(self):
+  def sync(self, timeout=None):
     """
     Sync the session.
     """
     for snd in self.senders:
-      snd.sync()
-    self._ewait(lambda: not self.outgoing and not self.acked)
+      snd.sync(timeout=timeout)
+    if not self._ewait(lambda: not self.outgoing and not self.acked, timeout=timeout):
+      raise Timeout("session sync timed out")
 
   @synchronized
-  def close(self):
+  def close(self, timeout=None):
     """
     Close the session.
     """
-    self.sync()
+    self.sync(timeout=timeout)
 
     for link in self.receivers + self.senders:
-      link.close()
+      link.close(timeout=timeout)
 
     self.closing = True
     self._wakeup()
-    self._ewait(lambda: self.closed)
-    self.connection._remove_session(self)
+    try:
+      if not self._ewait(lambda: self.closed, timeout=timeout):
+        raise Timeout("session close timed out")
+    finally:
+      self.connection._remove_session(self)
 
 class Sender:
 
@@ -816,22 +823,29 @@ class Sender:
       self._wakeup()
 
   @synchronized
-  def sync(self):
+  def sync(self, timeout=None):
     mno = self.queued
     if self.synced < mno:
       self.synced = mno
       self._wakeup()
-    self._ewait(lambda: self.acked >= mno)
+    if not self._ewait(lambda: self.acked >= mno, timeout=timeout):
+      raise Timeout("sender sync timed out")
 
   @synchronized
-  def close(self):
+  def close(self, timeout=None):
     """
     Close the Sender.
     """
+    # avoid erroring out when closing a sender that was never
+    # established
+    if self.acked < self.queued:
+      self.sync(timeout=timeout)
+
     self.closing = True
     self._wakeup()
     try:
-      self.session._ewait(lambda: self.closed)
+      if not self.session._ewait(lambda: self.closed, timeout=timeout):
+        raise Timeout("sender close timed out")
     finally:
       self.session.senders.remove(self)
 
@@ -962,14 +976,15 @@ class Receiver(object):
       self.granted = self.received + self._capacity
 
   @synchronized
-  def close(self):
+  def close(self, timeout=None):
     """
     Close the receiver.
     """
     self.closing = True
     self._wakeup()
     try:
-      self.session._ewait(lambda: self.closed)
+      if not self.session._ewait(lambda: self.closed, timeout=timeout):
+        raise Timeout("receiver close timed out")
     finally:
       self.session.receivers.remove(self)
 
diff --git a/qpid/python/qpid/messaging/exceptions.py b/qpid/python/qpid/messaging/exceptions.py
index 0a4941a..f640b6b 100644
--- a/qpid/python/qpid/messaging/exceptions.py
+++ b/qpid/python/qpid/messaging/exceptions.py
@@ -17,6 +17,11 @@
 # under the License.
 #
 
+class Timeout(Exception):
+  pass
+
+## Messaging Errors
+
 class MessagingError(Exception):
 
   def __init__(self, code=None, text=None, **info):
diff --git a/qpid/python/qpid/tests/messaging/__init__.py b/qpid/python/qpid/tests/messaging/__init__.py
index 147dbb8..2c1dce9 100644
--- a/qpid/python/qpid/tests/messaging/__init__.py
+++ b/qpid/python/qpid/tests/messaging/__init__.py
@@ -51,7 +51,11 @@ class Base(Test):
 
   def teardown(self):
     if self.conn is not None and self.conn.attached():
-      self.conn.close()
+      self.teardown_connection(self.conn)
+      self.conn = None
+
+  def teardown_connection(self, conn):
+    conn.close()
 
   def content(self, base, count = None):
     if count is None:
diff --git a/qpid/python/qpid/tests/messaging/endpoints.py b/qpid/python/qpid/tests/messaging/endpoints.py
index dce8d9b..b064d62 100644
--- a/qpid/python/qpid/tests/messaging/endpoints.py
+++ b/qpid/python/qpid/tests/messaging/endpoints.py
@@ -20,10 +20,11 @@
 # setup, usage, teardown, errors(sync), errors(async), stress, soak,
 # boundary-conditions, config
 
-import errno, os, time
+import errno, os, socket, time
 from qpid import compat
 from qpid.compat import set
 from qpid.messaging import *
+from qpid.messaging.transports import TRANSPORTS
 from qpid.tests.messaging import Base
 
 class SetupTests(Base):
@@ -98,8 +99,6 @@ class SetupTests(Base):
 
   def testReconnect(self):
     options = self.connection_options()
-    import socket
-    from qpid.messaging.transports import TRANSPORTS
     real = TRANSPORTS["tcp"]
 
     class flaky:
@@ -213,6 +212,104 @@ class ConnectionTests(Base):
     self.conn.close()
     assert not self.conn.attached()
 
+class hangable:
+
+  def __init__(self, host, port):
+    self.tcp = TRANSPORTS["tcp"](host, port)
+    self.hung = False
+
+  def hang(self):
+    self.hung = True
+
+  def fileno(self):
+    return self.tcp.fileno()
+
+  def reading(self, reading):
+    if self.hung:
+      return True
+    else:
+      return self.tcp.reading(reading)
+
+  def writing(self, writing):
+    if self.hung:
+      return False
+    else:
+      return self.tcp.writing(writing)
+
+  def send(self, bytes):
+    if self.hung:
+      return 0
+    else:
+      return self.tcp.send(bytes)
+
+  def recv(self, n):
+    if self.hung:
+      return ""
+    else:
+      return self.tcp.recv(n)
+
+  def close(self):
+    self.tcp.close()
+
+TRANSPORTS["hangable"] = hangable
+
+class TimeoutTests(Base):
+
+  def setup_connection(self):
+    options = self.connection_options()
+    options["transport"] = "hangable"
+    return Connection.establish(self.broker, **options)
+
+  def setup_session(self):
+    return self.conn.session()
+
+  def setup_sender(self):
+    return self.ssn.sender("amq.topic")
+
+  def setup_receiver(self):
+    return self.ssn.receiver("amq.topic")
+
+  def teardown_connection(self, conn):
+    try:
+      conn.detach(timeout=0)
+    except Timeout:
+      pass
+
+  def hang(self):
+    self.conn._driver._transport.hang()
+
+  def timeoutTest(self, method):
+    self.hang()
+    try:
+      method(timeout=self.delay())
+      assert False, "did not time out"
+    except Timeout:
+      pass
+
+  def testSenderSync(self):
+    self.snd.send(self.content("testSenderSync"), sync=False)
+    self.timeoutTest(self.snd.sync)
+
+  def testSenderClose(self):
+    self.snd.send(self.content("testSenderClose"), sync=False)
+    self.timeoutTest(self.snd.close)
+
+  def testReceiverClose(self):
+    self.timeoutTest(self.rcv.close)
+
+  def testSessionSync(self):
+    self.snd.send(self.content("testSessionSync"), sync=False)
+    self.timeoutTest(self.ssn.sync)
+
+  def testSessionClose(self):
+    self.timeoutTest(self.ssn.close)
+
+  def testConnectionDetach(self):
+    self.timeoutTest(self.conn.detach)
+
+  def testConnectionClose(self):
+    self.timeoutTest(self.conn.close)
+
 ACK_QC = 'test-ack-queue; {create: always}'
 ACK_QD = 'test-ack-queue; {delete: always}'
 
-- 
1.7.1.1

From 9201b99100d8d47b3ed92573eea0e71969996418 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Fri, 25 Jun 2010 18:12:28 +0000
Subject: [PATCH 083/129] BZ-608118 added support for x-amqp-0-10.{app-id,content-encoding,routing-key}

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958055 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py         |    9 +++++++++
 qpid/python/qpid/tests/messaging/__init__.py |   14 ++++++++++----
 qpid/python/qpid/tests/messaging/message.py  |    4 +++-
 3 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 6dab24d..ed6b602 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -1159,12 +1159,15 @@ class Engine:
       rt = addr2reply_to(msg.reply_to)
     else:
       rt = None
+    content_encoding = msg.properties.get("x-amqp-0-10.content-encoding")
     dp = DeliveryProperties(routing_key=rk)
     mp = MessageProperties(message_id=msg.id,
                            user_id=msg.user_id,
                            reply_to=rt,
                            correlation_id=msg.correlation_id,
+                           app_id = msg.properties.get("x-amqp-0-10.app-id"),
                            content_type=msg.content_type,
+                           content_encoding=content_encoding,
                            application_headers=msg.properties)
     if subject is not None:
       if mp.application_headers is None:
@@ -1242,6 +1245,12 @@ class Engine:
     msg.ttl = dp.ttl
     msg.redelivered = dp.redelivered
     msg.properties = mp.application_headers
+    if mp.app_id is not None:
+      msg.properties["x-amqp-0-10.app-id"] = mp.app_id
+    if mp.content_encoding is not None:
+      msg.properties["x-amqp-0-10.content-encoding"] = mp.content_encoding
+    if dp.routing_key is not None:
+      msg.properties["x-amqp-0-10.routing-key"] = dp.routing_key
     msg.content_type = mp.content_type
     msg._transfer_id = xfr.id
     return msg
diff --git a/qpid/python/qpid/tests/messaging/__init__.py b/qpid/python/qpid/tests/messaging/__init__.py
index 2c1dce9..a160f38 100644
--- a/qpid/python/qpid/tests/messaging/__init__.py
+++ b/qpid/python/qpid/tests/messaging/__init__.py
@@ -88,16 +88,22 @@ class Base(Test):
       self.assertEchos(expected, messages, redelivered)
     return messages
 
-  def diff(self, m1, m2):
+  def diff(self, m1, m2, excluded_properties=()):
     result = {}
     for attr in ("id", "subject", "user_id", "reply_to",
                  "correlation_id", "durable", "priority", "ttl",
-                 "redelivered", "properties", "content_type",
-                 "content"):
+                 "redelivered", "content_type", "content"):
       a1 = getattr(m1, attr)
       a2 = getattr(m2, attr)
       if a1 != a2:
         result[attr] = (a1, a2)
+    p1 = dict(m1.properties)
+    p2 = dict(m2.properties)
+    for ep in excluded_properties:
+      p1.pop(ep, None)
+      p2.pop(ep, None)
+    if p1 != p2:
+      result["properties"] = (p1, p2)
     return result
 
   def assertEcho(self, msg, echo, redelivered=False):
@@ -108,7 +114,7 @@ class Base(Test):
         echo = echo.content
         assert msg == echo, "expected %s, got %s" % (msg, echo)
     else:
-      delta = self.diff(msg, echo)
+      delta = self.diff(msg, echo, ("x-amqp-0-10.routing-key",))
       mttl, ettl = delta.pop("ttl", (0, 0))
       if redelivered:
         assert echo.redelivered, \
diff --git a/qpid/python/qpid/tests/messaging/message.py b/qpid/python/qpid/tests/messaging/message.py
index 2ca1fbf..91aab5f 100644
--- a/qpid/python/qpid/tests/messaging/message.py
+++ b/qpid/python/qpid/tests/messaging/message.py
@@ -85,7 +85,9 @@ class MessageEchoTests(Base):
               "key6": -3.14,
               "key7": ["one", 2, 3.14],
               "key8": [],
-              "key9": {"sub-key0": 3}}
+              "key9": {"sub-key0": 3},
+              "x-amqp-0-10.app-id": "test-app-id",
+              "x-amqp-0-10.content-encoding": "test-content-encoding"}
 
   def testMapContent(self):
     self.check(Message(MessageEchoTests.TEST_MAP))
-- 
1.7.1.1

From d5086ed9cd510ce9f1dc80da90315518d5c3ebd2 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Fri, 25 Jun 2010 18:26:14 +0000
Subject: [PATCH 084/129] BZ-608118 make sure we initialize properties even if application_headers is None

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958060 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index ed6b602..a732a60 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -1244,7 +1244,7 @@ class Engine:
     msg.priority = dp.priority
     msg.ttl = dp.ttl
     msg.redelivered = dp.redelivered
-    msg.properties = mp.application_headers
+    msg.properties = mp.application_headers or {}
     if mp.app_id is not None:
       msg.properties["x-amqp-0-10.app-id"] = mp.app_id
     if mp.content_encoding is not None:
-- 
1.7.1.1

From ee19a4688911a9fc55dea5f3176e99d6b77acafe Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Fri, 25 Jun 2010 18:57:59 +0000
Subject: [PATCH 085/129] BZ-569515 fix timeout tests to not leave queues lying around

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958077 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/tests/messaging/endpoints.py |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/python/qpid/tests/messaging/endpoints.py b/qpid/python/qpid/tests/messaging/endpoints.py
index b064d62..c01f16e 100644
--- a/qpid/python/qpid/tests/messaging/endpoints.py
+++ b/qpid/python/qpid/tests/messaging/endpoints.py
@@ -267,7 +267,7 @@ class TimeoutTests(Base):
     return self.ssn.sender("amq.topic")
 
   def setup_receiver(self):
-    return self.ssn.receiver("amq.topic")
+    return self.ssn.receiver("amq.topic; {link: {reliability: unreliable}}")
 
   def teardown_connection(self, conn):
     try:
-- 
1.7.1.1

From 1834e02e7dd0abd92d4bee09818f86f4fb6af89b Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Fri, 25 Jun 2010 19:06:05 +0000
Subject: [PATCH 086/129] BZ-607798 add uuid prefix to addresses beginning with hash(#)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958083 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/endpoints.py |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 30f51fe..8bddc96 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -543,6 +543,7 @@ class Session:
     @rtype: Sender
     @return: a new Sender for the specified target
     """
+    target = _mangle(target)
     sender = Sender(self, self.next_sender_id, target, options)
     self.next_sender_id += 1
     self.senders.append(sender)
@@ -566,6 +567,7 @@ class Session:
     @rtype: Receiver
     @return: a new Receiver for the specified source
     """
+    source = _mangle(source)
     receiver = Receiver(self, self.next_receiver_id, source, options)
     self.next_receiver_id += 1
     self.receivers.append(receiver)
@@ -707,6 +709,12 @@ class Session:
     finally:
       self.connection._remove_session(self)
 
+def _mangle(addr):
+  if addr.startswith("#"):
+    return str(uuid4()) + addr
+  else:
+    return addr
+
 class Sender:
 
   """
-- 
1.7.1.1

From ab7384c897f2bf27147e9b985b4a9d80f7b0600c Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Fri, 25 Jun 2010 17:25:46 +0000
Subject: [PATCH 087/129] Bug 608118 - Fixed - New Messaging API lacks access to some 0-10 headers

QPID-2698: recognise special property names for amqp 0-10 specific message- and delivery- properties

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958044 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 1db44a2ebafe023b1adec5f6de140bfe6023c4a2)
---
 .../src/qpid/client/amqp0_10/IncomingMessages.cpp  |   19 ++++++++
 .../src/qpid/client/amqp0_10/OutgoingMessage.cpp   |   32 +++++++++++++-
 qpid/cpp/src/tests/MessagingFixture.h              |    5 ++
 qpid/cpp/src/tests/MessagingSessionTests.cpp       |   45 ++++++++++++++++++++
 4 files changed, 98 insertions(+), 3 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp b/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
index 30cb634..2c00e6f 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/IncomingMessages.cpp
@@ -290,6 +290,10 @@ namespace {
 //TODO: unify conversion to and from 0-10 message that is currently
 //split between IncomingMessages and OutgoingMessage
 const std::string SUBJECT("qpid.subject");
+
+const std::string X_APP_ID("x-amqp-0-10.app-id");
+const std::string X_ROUTING_KEY("x-amqp-0-10.routing-key");
+const std::string X_CONTENT_ENCODING("x-amqp-0-10.content-encoding");
 }
 
 void populateHeaders(qpid::messaging::Message& message, 
@@ -312,6 +316,21 @@ void populateHeaders(qpid::messaging::Message& message,
         translate(messageProperties->getApplicationHeaders(), message.getProperties());
         message.setCorrelationId(messageProperties->getCorrelationId());
         message.setUserId(messageProperties->getUserId());
+        if (messageProperties->hasMessageId()) {
+            message.setMessageId(messageProperties->getMessageId().str());
+        }
+        //expose 0-10 specific items through special properties: 
+        //    app-id, content-encoding
+        if (messageProperties->hasAppId()) {
+            message.getProperties()[X_APP_ID] = messageProperties->getAppId();
+        }
+        if (messageProperties->hasContentEncoding()) {
+            message.getProperties()[X_CONTENT_ENCODING] = messageProperties->getContentEncoding();
+        }
+        //    routing-key, others?
+        if (deliveryProperties && deliveryProperties->hasRoutingKey()) {
+            message.getProperties()[X_ROUTING_KEY] = deliveryProperties->getRoutingKey();
+        }
     }
 }
 
diff --git a/qpid/cpp/src/qpid/client/amqp0_10/OutgoingMessage.cpp b/qpid/cpp/src/qpid/client/amqp0_10/OutgoingMessage.cpp
index c22eb54..8235896 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/OutgoingMessage.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/OutgoingMessage.cpp
@@ -21,10 +21,12 @@
 #include "qpid/client/amqp0_10/OutgoingMessage.h"
 #include "qpid/client/amqp0_10/AddressResolution.h"
 #include "qpid/amqp_0_10/Codecs.h"
+#include "qpid/types/Variant.h"
 #include "qpid/messaging/Address.h"
 #include "qpid/messaging/Message.h"
 #include "qpid/messaging/MessageImpl.h"
 #include "qpid/framing/enum.h"
+#include <sstream>
 
 namespace qpid {
 namespace client {
@@ -32,9 +34,19 @@ namespace amqp0_10 {
 
 using qpid::messaging::Address;
 using qpid::messaging::MessageImplAccess;
+using qpid::types::Variant;
 using namespace qpid::framing::message;
 using namespace qpid::amqp_0_10;
 
+namespace {
+//TODO: unify conversion to and from 0-10 message that is currently
+//split between IncomingMessages and OutgoingMessage
+const std::string SUBJECT("qpid.subject");
+const std::string X_APP_ID("x-amqp-0-10.app-id");
+const std::string X_ROUTING_KEY("x-amqp-0-10.routing-key");
+const std::string X_CONTENT_ENCODING("x-amqp-0-10.content-encoding");
+}
+
 void OutgoingMessage::convert(const qpid::messaging::Message& from)
 {
     //TODO: need to avoid copying as much as possible
@@ -55,10 +67,24 @@ void OutgoingMessage::convert(const qpid::messaging::Message& from)
         message.getDeliveryProperties().setRedelivered(true);
     }
     if (from.getPriority()) message.getDeliveryProperties().setPriority(from.getPriority());
-}
 
-namespace {
-const std::string SUBJECT("qpid.subject");
+    //allow certain 0-10 specific items to be set through special properties: 
+    //    message-id, app-id, content-encoding
+    if (from.getMessageId().size()) {
+        qpid::framing::Uuid uuid;
+        std::istringstream data(from.getMessageId());
+        data >> uuid;
+        message.getMessageProperties().setMessageId(uuid);
+    }
+    Variant::Map::const_iterator i;
+    i = from.getProperties().find(X_APP_ID);
+    if (i != from.getProperties().end()) {
+        message.getMessageProperties().setAppId(i->second.asString());
+    }
+    i = from.getProperties().find(X_CONTENT_ENCODING);
+    if (i != from.getProperties().end()) {
+        message.getMessageProperties().setContentEncoding(i->second.asString());
+    }
 }
 
 void OutgoingMessage::setSubject(const std::string& subject)
diff --git a/qpid/cpp/src/tests/MessagingFixture.h b/qpid/cpp/src/tests/MessagingFixture.h
index 5546b4e..c8ae86d 100644
--- a/qpid/cpp/src/tests/MessagingFixture.h
+++ b/qpid/cpp/src/tests/MessagingFixture.h
@@ -79,6 +79,11 @@ struct BrokerAdmin
         return !result.getNotFound();
     }
 
+    void send(qpid::client::Message& message, const std::string& exchange=std::string())
+    {
+        session.messageTransfer(qpid::client::arg::destination=exchange, qpid::client::arg::content=message);
+    }
+
     ~BrokerAdmin()
     {
         session.close();
diff --git a/qpid/cpp/src/tests/MessagingSessionTests.cpp b/qpid/cpp/src/tests/MessagingSessionTests.cpp
index 375af73..6fee123 100644
--- a/qpid/cpp/src/tests/MessagingSessionTests.cpp
+++ b/qpid/cpp/src/tests/MessagingSessionTests.cpp
@@ -712,6 +712,51 @@ QPID_AUTO_TEST_CASE(testOptionVerification)
     BOOST_CHECK_THROW(fix.session.createReceiver("my-queue; {invalid-option:blah}"), qpid::messaging::AddressError);    
 }
 
+QPID_AUTO_TEST_CASE(testReceiveSpecialProperties)
+{
+    QueueFixture fix;
+
+    qpid::client::Message out;
+    out.getDeliveryProperties().setRoutingKey(fix.queue);
+    out.getMessageProperties().setAppId("my-app-id");
+    out.getMessageProperties().setMessageId(qpid::framing::Uuid(true));
+    out.getMessageProperties().setContentEncoding("my-content-encoding");
+    fix.admin.send(out);
+
+    Receiver receiver = fix.session.createReceiver(fix.queue);
+    Message in = receiver.fetch(Duration::SECOND * 5);
+    BOOST_CHECK_EQUAL(in.getProperties()["x-amqp-0-10.routing-key"].asString(), out.getDeliveryProperties().getRoutingKey());
+    BOOST_CHECK_EQUAL(in.getProperties()["x-amqp-0-10.app-id"].asString(), out.getMessageProperties().getAppId());
+    BOOST_CHECK_EQUAL(in.getProperties()["x-amqp-0-10.content-encoding"].asString(), out.getMessageProperties().getContentEncoding());
+    BOOST_CHECK_EQUAL(in.getMessageId(), out.getMessageProperties().getMessageId().str());
+    fix.session.acknowledge(true);
+}
+
+QPID_AUTO_TEST_CASE(testSendSpecialProperties)
+{
+    QueueFixture fix;
+    Sender sender = fix.session.createSender(fix.queue);
+    Message out("test-message");
+    std::string appId = "my-app-id";
+    std::string contentEncoding = "my-content-encoding";
+    out.getProperties()["x-amqp-0-10.app-id"] = appId;
+    out.getProperties()["x-amqp-0-10.content-encoding"] = contentEncoding;
+    out.setMessageId(qpid::framing::Uuid(true).str());
+    sender.send(out, true);
+
+    qpid::client::LocalQueue q;
+    qpid::client::SubscriptionManager subs(fix.admin.session);
+    qpid::client::Subscription s = subs.subscribe(q, fix.queue);
+    qpid::client::Message in = q.get();
+    s.cancel();
+    fix.admin.session.sync();
+
+    BOOST_CHECK_EQUAL(in.getMessageProperties().getAppId(), appId);
+    BOOST_CHECK_EQUAL(in.getMessageProperties().getContentEncoding(), contentEncoding);
+    BOOST_CHECK_EQUAL(in.getMessageProperties().getMessageId().str(), out.getMessageId());
+}
+
+
 QPID_AUTO_TEST_SUITE_END()
 
 }} // namespace qpid::tests
-- 
1.7.1.1

From dcc6c20a11f1dffac6708a128517757e7b1e0324 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Mon, 28 Jun 2010 11:35:59 +0000
Subject: [PATCH 088/129] BZ-607798 fix mangling for addresses that are None

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958547 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/endpoints.py |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 8bddc96..62423ca 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -710,7 +710,7 @@ class Session:
       self.connection._remove_session(self)
 
 def _mangle(addr):
-  if addr.startswith("#"):
+  if addr and addr.startswith("#"):
     return str(uuid4()) + addr
   else:
     return addr
-- 
1.7.1.1

From 8a7446059bd03eed784ec7f81815e4adab972fdb Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Tue, 15 Jun 2010 17:51:10 +0000
Subject: [PATCH 089/129] QPID-2589 - Patch from Chuck Rolke
 More API cleanup and new examples (to match the examples for other languages)

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@954983 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit fa677aa82da3ee0fa654372d998563d8d652a787)
---
 .../csharp.direct.receiver.cs                      |   47 ++---
 .../csharp.direct.receiver.csproj                  |    4 +-
 .../csharp.direct.sender/csharp.direct.sender.cs   |   42 +++--
 .../csharp.direct.sender.csproj                    |    4 +-
 .../Properties/AssemblyInfo.cs                     |   36 ++++
 .../csharp.example.client/csharp.example.client.cs |   70 +++++++
 .../csharp.example.client.csproj                   |   81 +++++++++
 .../Properties/AssemblyInfo.cs                     |   36 ++++
 .../csharp.example.declare_queues.cs               |   61 +++++++
 .../csharp.example.declare_queues.csproj           |   81 +++++++++
 .../examples/csharp.example.drain/Options.cs       |  181 +++++++++++++++++++
 .../Properties/AssemblyInfo.cs                     |   36 ++++
 .../csharp.example.drain/csharp.example.drain.cs   |   85 +++++++++
 .../csharp.example.drain.csproj                    |   82 +++++++++
 .../Properties/AssemblyInfo.cs                     |   36 ++++
 .../csharp.example.server/csharp.example.server.cs |   61 +++++++
 .../csharp.example.server.csproj                   |   81 +++++++++
 .../examples/csharp.example.spout/Options.cs       |  189 ++++++++++++++++++++
 .../Properties/AssemblyInfo.cs                     |   36 ++++
 .../csharp.example.spout/csharp.example.spout.cs   |  117 ++++++++++++
 .../csharp.example.spout.csproj                    |   82 +++++++++
 .../csharp.map.callback.receiver.csproj            |    4 +-
 .../csharp.map.callback.sender.cs                  |   41 ++++-
 .../csharp.map.callback.sender.csproj              |    4 +-
 .../csharp.map.receiver/csharp.map.receiver.csproj |    4 +-
 .../csharp.map.receiver/csharp.map.recevier.cs     |   11 +-
 .../csharp.map.sender/csharp.map.sender.cs         |   47 +++++-
 .../csharp.map.sender/csharp.map.sender.csproj     |    4 +-
 .../qpid/dotnet/org.apache.qpid.messaging.sln      |   93 ++++++++++-
 qpid/cpp/bindings/qpid/dotnet/src/Message.cpp      |  146 ++++++++++++++--
 qpid/cpp/bindings/qpid/dotnet/src/Message.h        |   22 ++-
 qpid/cpp/bindings/qpid/dotnet/src/Session.cpp      |  102 +++++++++++-
 qpid/cpp/bindings/qpid/dotnet/src/Session.h        |    6 +-
 ...rg.apache.qpid.messaging.sessionreceiver.csproj |    4 +-
 .../dotnet/test/messaging.test/messaging.test.cs   |   31 ++++
 .../test/messaging.test/messaging.test.csproj      |    4 +-
 36 files changed, 1879 insertions(+), 92 deletions(-)
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Options.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Options.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.csproj

diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
index 98531eb..af0b398 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
@@ -32,6 +32,7 @@ namespace CSharpDirect
         // Direct receiver example
         //
         // Receive 10 messages from localhost:5672, amq.direct/key
+        // Messages are assumed to be printable strings.
         //
         static void Main(string[] args)
         {
@@ -52,39 +53,27 @@ namespace CSharpDirect
             Console.WriteLine("nMsg : {0}", nMsg);
             Console.WriteLine();
 
-            Connection conn = new Connection(host);
-
-            conn.Open();
-
-            if (!conn.IsOpen())
-            {
-                Console.WriteLine("Failed to open connection to host : {0}", host);
-            }
-            else
+            Connection connection = null;
+            try
             {
-
-                Session sess = conn.CreateSession();
-
-                Duration dura = new Duration(3600000); // wait forever
-
-                Receiver rcv = sess.CreateReceiver(addr);
-
-                Message msg = new Message("");
-
-                for (int i = 0; i < nMsg; i++)
-                {
-                    try
-                    {
-                        Message msg2 = rcv.Fetch(dura);
+                connection = new Connection(host);
+                connection.Open();
+                if (!connection.IsOpen()) {
+                    Console.WriteLine("Failed to open connection to host : {0}", host);
+                } else {
+                    Session session = connection.CreateSession();
+                    Receiver receiver = session.CreateReceiver(addr);
+                    Message message = new Message("");
+                    for (int i = 0; i < nMsg; i++) {
+                        Message msg2 = receiver.Fetch(DurationConstants.FORVER);
                         Console.WriteLine("Rcvd msg {0} : {1}", i, msg2.GetContent());
                     }
-                    catch (Exception e)
-                    {
-                        Console.WriteLine("Exception {0}.", e);
-                    }
+                    connection.Close();
                 }
-
-                conn.Close();
+            } catch (Exception e) {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
             }
         }
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
index 96b4540..172e25a 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{52F880E7-D677-4C91-8516-D679CE0F46A8}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
index 71ab75c..b287af2 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
@@ -29,6 +29,11 @@ namespace csharp.direct.sender
 {
     class Program
     {
+        // Direct sender example
+        //
+        // Send 10 messages from localhost:5672, amq.direct/key
+        // Messages are assumed to be printable strings.
+        //
         static void Main(string[] args)
         {
             String host = "localhost:5672";
@@ -48,28 +53,27 @@ namespace csharp.direct.sender
             Console.WriteLine("nMsg : {0}", nMsg);
             Console.WriteLine();
 
-            Connection conn = new Connection(host);
-
-            conn.Open();
-
-            if (!conn.IsOpen())
-            {
-                Console.WriteLine("Failed to open connection to host : {0}", host);
-            }
-            else
+            Connection connection = null;
+            try
             {
-                Session sess = conn.CreateSession();
+                connection = new Connection(host);
+                connection.Open();
 
-                Sender snd = sess.CreateSender(addr);
-
-                for (int i = 0; i < nMsg; i++)
-                {
-                    Message msg = new Message(String.Format("Test Message {0}", i));
-
-                    snd.Send(msg);
+                if (!connection.IsOpen()) {
+                    Console.WriteLine("Failed to open connection to host : {0}", host);
+                } else {
+                    Session session = connection.CreateSession();
+                    Sender sender = session.CreateSender(addr);
+                    for (int i = 0; i < nMsg; i++) {
+                        Message message = new Message(String.Format("Test Message {0}", i));
+                        sender.Send(message);
+                    }
+                    connection.Close();
                 }
-
-                conn.Close();
+            } catch (Exception e) {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
             }
         }
     }
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
index 4543222..8e8371c 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..95433e4
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.receiver")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("c60b17ab-a82c-4edf-ba95-1e88bd4c3e75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
new file mode 100644
index 0000000..93459b6
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
@@ -0,0 +1,70 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging.Examples {
+    class Client {
+        static void Main(string[] args) {
+            String url = "amqp:tcp:127.0.0.1:5672";
+
+            if (args.Length > 0)
+                url = args[0];
+
+            Connection connection = new Connection(url);
+            try
+            {
+                connection.Open();
+
+                Session session = connection.CreateSession();
+
+                Sender sender = session.CreateSender("service_queue");
+
+                Address responseQueue = new Address("#response-queue; {create:always, delete:always}");
+                Receiver receiver = session.CreateReceiver(responseQueue);
+
+                String[] s = new String[] {
+                    "Twas brillig, and the slithy toves",
+                    "Did gire and gymble in the wabe.",
+                    "All mimsy were the borogroves,",
+                    "And the mome raths outgrabe."
+                };
+
+                Message request = new Message("");
+                request.SetReplyTo(responseQueue);
+
+                for (int i = 0; i < s.Length; i++) {
+                    request.SetContent(s[i]);
+                    sender.Send(request);
+                    Message response = receiver.Fetch();
+                    Console.WriteLine("{0} -> {1}", request.GetContent(), response.GetContent());
+                }
+                connection.Close();
+            }
+            catch (Exception e)
+            {
+                Console.WriteLine("Exception {0}.", e);
+                connection.Close();
+            }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.csproj
new file mode 100644
index 0000000..76fb1c5
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.csproj
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{0DE01712-C2D1-4CA4-B42C-5856456A8696}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.client</RootNamespace>
+    <AssemblyName>csharp.example.client</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.client.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..95433e4
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.receiver")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("c60b17ab-a82c-4edf-ba95-1e88bd4c3e75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.cs
new file mode 100644
index 0000000..7f116f1
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.cs
@@ -0,0 +1,61 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging.Examples {
+    class DeclareQueues {
+        //
+        // Sample invocation: csharp.example.declare_queues.exe localhost:5672 my-queue
+        //
+        static void Main(string[] args) {
+            string addr = "localhost:5672";
+            string queue = "my-queue";
+
+            if (args.Length > 0)
+                addr = args[0];
+            if (args.Length > 1)
+                queue = args[1];
+
+            Connection connection = null;
+            try
+            {
+                connection = new Connection(addr);
+                connection.Open();
+                Session session = connection.CreateSession();
+                String queueName = queue + "; {create: always}";
+                Sender sender = session.CreateSender(queueName);
+                session.Close();
+                connection.Close();
+            }
+            catch (Exception e)
+            {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
+            }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.csproj
new file mode 100644
index 0000000..fb7e950
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.declare_queues/csharp.example.declare_queues.csproj
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{E31B349C-830C-4583-8BD9-30DA4398349F}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.declare_queues</RootNamespace>
+    <AssemblyName>csharp.example.declare_queues</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.declare_queues.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Options.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Options.cs
new file mode 100644
index 0000000..808e227
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Options.cs
@@ -0,0 +1,181 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+namespace Org.Apache.Qpid.Messaging.Examples
+{
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.Diagnostics;
+    using System.IO;
+    using System.Text;
+    using System.Xml;
+
+    public class Options
+    {
+        private string url;
+        private string address;
+        private UInt64 timeout;
+        private int count;
+        private string id;
+        private string replyTo;
+        //private string[] properties;
+        //private string[] entries;
+        private string content;
+        private string connectionOptions;
+        private bool forever;
+
+        public Options(string[] args)
+        {
+            this.url = "amqp:tcp:127.0.0.1:5672";
+            this.address = "";
+            this.timeout = 0;
+            this.count = 1;
+            this.id = "";
+            this.replyTo = "";
+            this.content = "";
+            this.connectionOptions = "";
+            this.forever = false;
+            Parse(args);
+        }
+
+        private void Parse(string[] args)
+        {
+            int argCount = args.Length;
+            int current = 0;
+
+            while ((current + 1) < argCount)
+            {
+                string arg = args[current];
+                if (arg == "--broker")
+                {
+                    this.url = args[++current];
+                }
+                else if (arg == "--address")
+                {
+                    this.address = args[++current];
+                }
+                else if (arg == "--timeout")
+                {
+                    arg = args[++current];
+                    UInt64 i = UInt64.Parse(arg);
+                    if (i >= 0)
+                    {
+                        this.timeout = i;
+                    }
+                }
+                else if (arg == "--count")
+                {
+                    arg = args[++current];
+                    int i = int.Parse(arg);
+                    if (i >= 0)
+                    {
+                        this.count = i;
+                    }
+                }
+                else if (arg == "--id")
+                {
+                    this.id = args[++current];
+                }
+                else if (arg == "--reply-to")
+                {
+                    this.replyTo = args[++current];
+                }
+                else if (arg == "--properties")
+                {
+                    throw new ArgumentException("TODO: properties not implemented");
+                }
+                else if (arg == "--entries")
+                {
+                    throw new ArgumentException("TODO: entries not implemented");
+                }
+                else if (arg == "--content")
+                {
+                    this.content = args[++current];
+                }
+                else if (arg == "--connection-options")
+                {
+                    this.connectionOptions = args[++current];
+                }
+                else if (arg == "--forever")
+                {
+                    this.forever = true;
+                }
+                else
+                {
+                    throw new ArgumentException(String.Format("unknown argument \"{0}\"", arg));
+                }
+
+                current++;
+            }
+
+            if (current == argCount)
+            {
+                throw new ArgumentException("missing argument: address");
+            }
+
+            address = args[current];
+        }
+
+        public string Url
+        {
+            get { return this.url; }
+        }
+
+        public string Address
+        {
+            get { return this.address; }
+        }
+
+        public UInt64 Timeout
+        {
+            get { return this.timeout; }
+        }
+
+        public int Count
+        {
+            get { return this.count; }
+        }
+
+        public string Id
+        {
+            get { return this.id; }
+        }
+
+        public string ReplyTo
+        {
+            get { return this.replyTo; }
+        }
+
+        public string Content
+        {
+            get { return content; }
+        }
+
+        public string ConnectionOptions
+        {
+            get { return this.connectionOptions; }
+        }
+
+        public bool Forever
+        {
+            get { return this.forever; }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..95433e4
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.receiver")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("c60b17ab-a82c-4edf-ba95-1e88bd4c3e75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
new file mode 100644
index 0000000..6740e6a
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
@@ -0,0 +1,85 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging.Examples {
+    class Drain {
+        //
+        // Sample invocation: csharp.example.drain.exe --broker localhost:5672 --timeout 30 my-queue
+        //
+        static void Main(string[] args) {
+            Options options = new Options(args);
+
+            Connection connection = null;
+            try
+            {
+                connection = new Connection(options.Url, options.ConnectionOptions);
+                connection.Open();
+                Session session = connection.CreateSession();
+                Receiver receiver = session.CreateReceiver(options.Address);
+                Duration timeout = options.Forever ? 
+                                   DurationConstants.FORVER : 
+                                   DurationConstants.SECOND * options.Timeout;
+                Message message = new Message();
+                while (receiver.Fetch(message, timeout))
+                {
+                    Dictionary<string, object> properties = new Dictionary<string, object>();
+                    properties = message.GetProperties();
+                    Console.Write("Message(properties={0}, content='", 
+                                  message.MapAsString(properties));
+
+                    if ("amqp/map" == message.GetContentType())
+                    {
+                        Dictionary<string, object> content = new Dictionary<string, object>();
+                        message.GetContent(content);
+                        Console.Write(message.MapAsString(content));
+                    }
+                    else if ("amqp/list" == message.GetContentType())
+                    {
+                        Collection<object> content = new Collection<object>();
+                        message.GetContent(content);
+                        Console.Write(message.ListAsString(content));
+                    }
+                    else
+                    {
+                        Console.Write(message.GetContent());
+                    }
+                    Console.WriteLine("')");
+                    session.Acknowledge();
+                }
+                receiver.Close();
+                session.Close();
+                connection.Close();
+            }
+            catch (Exception e)
+            {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
+            }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.csproj
new file mode 100644
index 0000000..198900c
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.csproj
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{C43DEB69-8088-420B-B0CA-C699535E6D08}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.drain</RootNamespace>
+    <AssemblyName>csharp.example.drain</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.drain.cs" />
+    <Compile Include="Options.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..95433e4
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.receiver")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("c60b17ab-a82c-4edf-ba95-1e88bd4c3e75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
new file mode 100644
index 0000000..af01e4b
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
@@ -0,0 +1,61 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging.Examples {
+    class Server {
+        static void Main(string[] args) {
+            String url = "amqp:tcp:127.0.0.1:5672";
+
+            if (args.Length > 0)
+                url = args[0];
+
+            try {
+                Connection connection = new Connection(url);
+                connection.Open();
+                Session session = connection.CreateSession();
+                Receiver receiver = session.CreateReceiver("service_queue; {create: always}");
+
+                while (true) {
+                    Message request = receiver.Fetch();
+                    Address address = request.GetReplyTo();
+
+                    if (null != address) {
+                        Sender sender = session.CreateSender(address);
+                        String s = request.GetContent();
+                        Message response = new Message(s.ToUpper());
+                        sender.Send(response);
+                        Console.WriteLine("Processed request: {0} -> {1}", request.GetContent(), response.GetContent());
+                        session.Acknowledge();
+                    } else {
+                        Console.WriteLine("Error: no reply address specified for request: {0}", request.GetContent());
+                        session.Reject(request);
+                    }
+                }
+                // connection.Close();  // unreachable in this example
+            } catch (Exception e) {
+                Console.WriteLine("Exception {0}.", e);
+            }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.csproj
new file mode 100644
index 0000000..1fa2cc0
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.csproj
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{090A081D-E8B5-4949-AA43-EE182B7101E3}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.server</RootNamespace>
+    <AssemblyName>csharp.example.server</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.server.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Options.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Options.cs
new file mode 100644
index 0000000..be55c1e
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Options.cs
@@ -0,0 +1,189 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+namespace Org.Apache.Qpid.Messaging.Examples
+{
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.Collections.ObjectModel;
+    using System.Diagnostics;
+    using System.IO;
+    using System.Text;
+    using System.Xml;
+
+    public class Options
+    {
+        private string url;
+        private string address;
+        private int timeout;
+        private int count;
+        private string id;
+        private string replyTo;
+        private Collection<string> properties;
+        private Collection<string> entries;
+        private string content;
+        private string connectionOptions;
+        private bool forever;
+
+        public Options(string[] args)
+        {
+            this.url = "amqp:tcp:127.0.0.1:5672";
+            this.address = "";
+            this.timeout = 0;
+            this.count = 1;
+            this.id = "";
+            this.replyTo = "";
+            properties = new Collection<string>();
+            entries = new Collection<string>();
+            this.content = "";
+            this.connectionOptions = "";
+            this.forever = false;
+            Parse(args);
+        }
+
+        private void Parse(string[] args)
+        {
+            int argCount = args.Length;
+            int current = 0;
+
+            while ((current + 1) < argCount)
+            {
+                string arg = args[current];
+                if (arg == "--broker")
+                {
+                    this.url = args[++current];
+                }
+                else if (arg == "--address")
+                {
+                    this.address = args[++current];
+                }
+                else if (arg == "--timeout")
+                {
+                    arg = args[++current];
+                    int i = int.Parse(arg);
+                    if (i >= 0)
+                    {
+                        this.timeout = i;
+                    }
+                }
+                else if (arg == "--count")
+                {
+                    arg = args[++current];
+                    int i = int.Parse(arg);
+                    if (i >= 0)
+                    {
+                        this.count = i;
+                    }
+                }
+                else if (arg == "--id")
+                {
+                    this.id = args[++current];
+                }
+                else if (arg == "--reply-to")
+                {
+                    this.replyTo = args[++current];
+                }
+                else if (arg == "--properties")
+                {
+                    this.properties.Add(args[++current]);
+                }
+                else if (arg == "--map")
+                {
+                    this.entries.Add(args[++current]);
+                }
+                else if (arg == "--content")
+                {
+                    this.content = args[++current];
+                }
+                else if (arg == "--connection-options")
+                {
+                    this.connectionOptions = args[++current];
+                }
+                else if (arg == "--forever")
+                {
+                    this.forever = true;
+                }
+                else
+                {
+                    throw new ArgumentException(String.Format("unknown argument \"{0}\"", arg));
+                }
+
+                current++;
+            }
+
+            if (current == argCount)
+            {
+                throw new ArgumentException("missing argument: address");
+            }
+
+            address = args[current];
+        }
+
+        public string Url
+        {
+            get { return this.url; }
+        }
+
+        public string Address
+        {
+            get { return this.address; }
+        }
+
+        public int Timeout
+        {
+            get { return this.timeout; }
+        }
+
+        public int Count
+        {
+            get { return this.count; }
+        }
+
+        public string Id
+        {
+            get { return this.id; }
+        }
+
+        public string ReplyTo
+        {
+            get { return this.replyTo; }
+        }
+
+        public Collection<string> Entries
+        {
+            get { return this.entries; }
+        }
+
+        public string Content
+        {
+            get { return content; }
+        }
+
+        public string ConnectionOptions
+        {
+            get { return this.connectionOptions; }
+        }
+
+        public bool Forever
+        {
+            get { return this.forever; }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..95433e4
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.receiver")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.receiver")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("c60b17ab-a82c-4edf-ba95-1e88bd4c3e75")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
new file mode 100644
index 0000000..7eeece3
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
@@ -0,0 +1,117 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using System.Diagnostics;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging.Examples {
+    class Spout {
+        //
+        // Sample invocation: csharp.example.drain.exe --broker localhost:5672 --timeout 30 my-queue
+        // This pro
+        static bool NameVal(string In, out string nameOut, out string valueOut)
+        {
+            int pos = In.IndexOf("=");
+            if (-1 == pos) {
+                nameOut = In;
+                valueOut = "";
+                return false;
+            } else {
+                nameOut = In.Substring(0, pos);
+                if (pos + 1 < In.Length) {
+                    valueOut = In.Substring(pos + 1);
+                    return true;
+                } else {
+                    valueOut = "";
+                    return false;
+                }
+            }
+        }
+
+        static void SetEntries(Collection<string> entries, Dictionary<string, object> content)
+        {
+            foreach (String entry in entries)
+            {
+                string name = "";
+                string value = "";
+                if (NameVal(entry, out name, out value))
+                    content.Add(name, value);
+                else
+                    content.Add(name, "");
+            }
+        }
+
+        static void Main(string[] args) {
+            Options options = new Options(args);
+
+            Connection connection = null;
+            try
+            {
+                connection = new Connection(options.Url);
+                connection.Open();
+                Session session = connection.CreateSession();
+                Sender sender = session.CreateSender(options.Address);
+                Message message;
+                if (options.Entries.Count > 0)
+                {
+                    Dictionary<string, object> content = new Dictionary<string, object>();
+                    SetEntries(options.Entries, content);
+                    message = new Message(content);
+                }
+                else
+                {
+                    message = new Message(options.Content);
+                    message.SetContentType("text/plain");
+                }
+                Address replyToAddr = new Address(options.ReplyTo);
+
+                Stopwatch stopwatch = new Stopwatch();
+                TimeSpan timespan = new TimeSpan(0,0,options.Timeout);
+                stopwatch.Start();
+                for (int count = 0;
+                    (0 == options.Count || count < options.Count) &&
+                    (0 == options.Timeout || stopwatch.Elapsed <= timespan);
+                    count++) 
+                {
+                    if ("" != options.ReplyTo) message.SetReplyTo(replyToAddr);
+                    string id = options.Id ;
+                    if ("" == id) {
+                        Guid g = Guid.NewGuid();
+                        id = g.ToString();
+                    }
+                    string spoutid = id + ":" + count;
+                    message.SetProperty("spout-id", spoutid);
+                    sender.Send(message);
+                }
+                connection.Close();
+            } catch (Exception e) {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
+            }
+        }
+    }
+}
+
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.csproj
new file mode 100644
index 0000000..15fc644
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.csproj
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{EB36626D-36C2-41B3-B65E-762BAF27F137}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.spout</RootNamespace>
+    <AssemblyName>csharp.example.spout</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.spout.cs" />
+    <Compile Include="Options.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
index 24b5cd4..c32574a 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{68A43817-2358-4A31-8FDF-FE21722BFBCF}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
     <ProjectReference Include="..\..\src\sessionreceiver\org.apache.qpid.messaging.sessionreceiver.csproj">
       <Project>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
index 761ac0a..2b17052 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
@@ -100,20 +100,55 @@ namespace Org.Apache.Qpid.Messaging.Examples
             Dictionary<string, object> subMap = new Dictionary<string, object>();
             Collection<object> colors = new Collection<object>();
 
+            // add simple types
             content["id"] = 987654321;
             content["name"] = "Widget";
             content["percent"] = 0.99;
 
+            // add nested amqp/map
             subMap["name"] = "Smith";
             subMap["number"] = 354;
+            content["nestedMap"] = subMap;
 
-            content["nested"] = subMap;
-
+            // add an amqp/list
             colors.Add("red");
             colors.Add("green");
             colors.Add("white");
+            content["colorsList"] = colors;
+
+            // add one of each supported amqp data type
+            bool mybool = true;
+            content["mybool"] = mybool;
+
+            byte mybyte = 4;
+            content["mybyte"] = mybyte;
+
+            UInt16 myUInt16 = 5;
+            content["myUInt16"] = myUInt16;
+
+            UInt32 myUInt32 = 6;
+            content["myUInt32"] = myUInt32;
+
+            UInt64 myUInt64 = 7;
+            content["myUInt64"] = myUInt64;
+
+            char mychar = 'h';
+            content["mychar"] = mychar;
+
+            Int16 myInt16 = 9;
+            content["myInt16"] = myInt16;
+
+            Int32 myInt32 = 10;
+            content["myInt32"] = myInt32;
+
+            Int64 myInt64 = 11;
+            content["myInt64"] = myInt64;
+
+            Single mySingle = (Single)12.12;
+            content["mySingle"] = mySingle;
 
-            content["colors"] = colors;
+            Double myDouble = 13.13;
+            content["myDouble"] = myDouble;
 
             //
             // Construct a message with the map content and send it synchronously
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
index 26f2c5b..1f37ce8 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{12F1C14F-5C7D-4075-9BAE-C091394FF99A}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -69,7 +69,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
index 06017fb..c3d87ee 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.receiver.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
     <ProjectReference Include="..\..\src\sessionreceiver\org.apache.qpid.messaging.sessionreceiver.csproj">
       <Project>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
index 41ed9f3..242944b 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.receiver/csharp.map.recevier.cs
@@ -27,6 +27,11 @@ namespace Org.Apache.Qpid.Messaging.examples
 {
     class MapReceiver
     {
+        // csharp.map.receiver example
+        //
+        // Send an amqp/map message to amqp:tcp:localhost:5672 amq.direct/map_example
+        // The map message 
+        //
         static void Main(string[] args)
         {
             string url = "amqp:tcp:localhost:5672";
@@ -47,16 +52,16 @@ namespace Org.Apache.Qpid.Messaging.examples
             Receiver receiver = session.CreateReceiver("amq.direct/map_example");
 
             //
-            // Fetch the message from the broker (wait indefinitely by default)
+            // Fetch the message from the broker
             //
-            Message message = receiver.Fetch(new Duration(60000));
+            Message message = receiver.Fetch(DurationConstants.MINUTE);
 
             //
             // Extract the structured content from the message.
             //
             Dictionary<string, object> content = new Dictionary<string, object>();
             message.GetContent(content);
-            Console.WriteLine("Received: {0}", content);
+            Console.WriteLine("Received: {0}", message.AsString(content));
 
             //
             // Acknowledge the receipt of all received messages.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
index d1ccc65..5517226 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
@@ -30,6 +30,12 @@ namespace Org.Apache.Qpid.Messaging.examples
 {
     class MapSender
     {
+        // csharp.map.sender example
+        //
+        // Send an amqp/map message to amqp:tcp:localhost:5672 amq.direct/map_example
+        // The map message contains simple types, a nested amqp/map,
+        // an ampq/list, and specific instances of each supported type.
+        //
         static void Main(string[] args)
         {
             string url = "amqp:tcp:localhost:5672";
@@ -57,20 +63,55 @@ namespace Org.Apache.Qpid.Messaging.examples
             Dictionary<string, object> subMap = new Dictionary<string, object>();
             Collection<object> colors = new Collection<object>();
 
+            // add simple types
             content["id"] = 987654321;
             content["name"] = "Widget";
             content["percent"] = 0.99;
 
+            // add nested amqp/map
             subMap["name"] = "Smith";
             subMap["number"] = 354;
+            content["nestedMap"] = subMap;
 
-            content["nested"] = subMap;
-
+            // add an amqp/list
             colors.Add("red");
             colors.Add("green");
             colors.Add("white");
+            content["colorsList"] = colors;
+
+            // add one of each supported amqp data type
+            bool mybool = true;
+            content["mybool"] = mybool;
+
+            byte mybyte = 4;
+            content["mybyte"] = mybyte;
+
+            UInt16 myUInt16 = 5 ;
+            content["myUInt16"] = myUInt16;
+
+            UInt32 myUInt32 = 6;
+            content["myUInt32"] = myUInt32;
+
+            UInt64 myUInt64 = 7;
+            content["myUInt64"] = myUInt64;
+
+            char mychar = 'h';
+            content["mychar"] = mychar;
+
+            Int16 myInt16 = 9;
+            content["myInt16"] = myInt16;
+
+            Int32 myInt32 = 10;
+            content["myInt32"] = myInt32;
+
+            Int64 myInt64 = 11;
+            content["myInt64"] = myInt64;
+
+            Single mySingle = (Single)12.12;
+            content["mySingle"] = mySingle;
 
-            content["colors"] = colors;
+            Double myDouble = 13.13;
+            content["myDouble"] = myDouble;
 
             //
             // Construct a message with the map content and send it synchronously
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
index a3a2ac2..516e7cc 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{5D8252F5-E1D3-44A0-94C7-7CB75E843C10}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
diff --git a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
index 5cd4b1a..7269dad 100644
--- a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
+++ b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
@@ -1,6 +1,6 @@
 Microsoft Visual Studio Solution File, Format Version 10.00
 # Visual Studio 2008
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "org.apache.qpid.messaging", "src\org.apache.qpid.messaging.vcproj", "{AA5A3B83-5F98-406D-A01C-5A921467A57D}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Org.Apache.Qpid.Messaging", "src\org.apache.qpid.messaging.vcproj", "{AA5A3B83-5F98-406D-A01C-5A921467A57D}"
 EndProject
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Examples", "Examples", "{34C477FB-B0CC-4AB9-A346-EA7B055469AC}"
 EndProject
@@ -43,6 +43,20 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.callback.receive
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.map.callback.sender", "examples\csharp.map.callback.sender\csharp.map.callback.sender.csproj", "{12F1C14F-5C7D-4075-9BAE-C091394FF99A}"
 EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Client-Server", "Client-Server", "{9232212E-F3C6-4D18-8D25-0C31DD5FF3DB}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.client", "examples\csharp.example.client\csharp.example.client.csproj", "{0DE01712-C2D1-4CA4-B42C-5856456A8696}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.server", "examples\csharp.example.server\csharp.example.server.csproj", "{090A081D-E8B5-4949-AA43-EE182B7101E3}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Drain-Spout", "Drain-Spout", "{89CE04CB-21DE-4ABB-9236-50529DD8C022}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.drain", "examples\csharp.example.drain\csharp.example.drain.csproj", "{C43DEB69-8088-420B-B0CA-C699535E6D08}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.spout", "examples\csharp.example.spout\csharp.example.spout.csproj", "{EB36626D-36C2-41B3-B65E-762BAF27F137}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.declare_queues", "examples\csharp.example.declare_queues\csharp.example.declare_queues.csproj", "{E31B349C-830C-4583-8BD9-30DA4398349F}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -180,6 +194,76 @@ Global
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|Win32.ActiveCfg = Release|Any CPU
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|x86.ActiveCfg = Release|x86
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A}.Release|x86.Build.0 = Release|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|Win32.ActiveCfg = Debug|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|x86.ActiveCfg = Debug|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Debug|x86.Build.0 = Debug|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|Any CPU.Build.0 = Release|Any CPU
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|Mixed Platforms.Build.0 = Release|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|Win32.ActiveCfg = Release|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|x86.ActiveCfg = Release|x86
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696}.Release|x86.Build.0 = Release|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|Win32.ActiveCfg = Debug|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|x86.ActiveCfg = Debug|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Debug|x86.Build.0 = Debug|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|Any CPU.Build.0 = Release|Any CPU
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|Mixed Platforms.Build.0 = Release|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|Win32.ActiveCfg = Release|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|x86.ActiveCfg = Release|x86
+		{090A081D-E8B5-4949-AA43-EE182B7101E3}.Release|x86.Build.0 = Release|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|Win32.ActiveCfg = Debug|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|x86.ActiveCfg = Debug|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Debug|x86.Build.0 = Debug|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|Any CPU.Build.0 = Release|Any CPU
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|Mixed Platforms.Build.0 = Release|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|Win32.ActiveCfg = Release|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|x86.ActiveCfg = Release|x86
+		{C43DEB69-8088-420B-B0CA-C699535E6D08}.Release|x86.Build.0 = Release|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|Win32.ActiveCfg = Debug|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|x86.ActiveCfg = Debug|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Debug|x86.Build.0 = Debug|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|Any CPU.Build.0 = Release|Any CPU
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|Mixed Platforms.Build.0 = Release|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|Win32.ActiveCfg = Release|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|x86.ActiveCfg = Release|x86
+		{EB36626D-36C2-41B3-B65E-762BAF27F137}.Release|x86.Build.0 = Release|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|Win32.ActiveCfg = Debug|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|x86.ActiveCfg = Debug|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Debug|x86.Build.0 = Debug|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Any CPU.Build.0 = Release|Any CPU
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Mixed Platforms.Build.0 = Release|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Win32.ActiveCfg = Release|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|x86.ActiveCfg = Release|x86
+		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|x86.Build.0 = Release|x86
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -188,6 +272,8 @@ Global
 		{DE58D329-10DC-4C8D-9EFA-230A57314089} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{878FDDF8-A870-41D6-9E36-0A050EC5ACAB} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{E99FEFEE-B866-4BBA-9AA3-79DDF1C92960} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
+		{9232212E-F3C6-4D18-8D25-0C31DD5FF3DB} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
+		{89CE04CB-21DE-4ABB-9236-50529DD8C022} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068} = {DE58D329-10DC-4C8D-9EFA-230A57314089}
 		{52F880E7-D677-4C91-8516-D679CE0F46A8} = {DE58D329-10DC-4C8D-9EFA-230A57314089}
 		{AF2FBC78-266C-430C-BC29-9477AB596A36} = {39E9D1BF-3A0B-4D86-BF6B-F463E1A2245A}
@@ -195,5 +281,10 @@ Global
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
+		{0DE01712-C2D1-4CA4-B42C-5856456A8696} = {9232212E-F3C6-4D18-8D25-0C31DD5FF3DB}
+		{090A081D-E8B5-4949-AA43-EE182B7101E3} = {9232212E-F3C6-4D18-8D25-0C31DD5FF3DB}
+		{C43DEB69-8088-420B-B0CA-C699535E6D08} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
+		{EB36626D-36C2-41B3-B65E-762BAF27F137} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
+		{E31B349C-830C-4583-8BD9-30DA4398349F} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
 	EndGlobalSection
 EndGlobal
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
index 3f748f1..743afce 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
@@ -24,6 +24,7 @@
 #include <string>
 #include <limits>
 #include <iostream>
+#include <stdlib.h>
 
 #include "qpid/messaging/Message.h"
 #include "qpid/types/Variant.h"
@@ -100,6 +101,25 @@ namespace Messaging {
         }
     }
 
+
+	// Create from bytes
+	Message::Message(array<System::Byte> ^ bytes)
+	{
+		pin_ptr<unsigned char> pBytes = &bytes[0];
+		messagep = new ::qpid::messaging::Message((char *)pBytes, bytes->Length);
+	}
+
+    // Create from byte array slice
+	Message::Message(array<System::Byte> ^ bytes, int offset, int size)
+	{
+        if ((offset + size) > bytes->Length)
+			throw gcnew QpidException("Message::Message Create from byte array slice: buffer length exceeded");
+
+		pin_ptr<unsigned char> pBytes = &bytes[offset];
+		messagep = new ::qpid::messaging::Message((char *)pBytes, size);
+	}
+
+
     // Create from received message
     Message::Message(::qpid::messaging::Message * msgp) :
         messagep(msgp)
@@ -278,7 +298,7 @@ namespace Messaging {
         messagep->setRedelivered(redelivered);
     }
 
-
+	// Properties
     System::Collections::Generic::Dictionary<
             System::String^, System::Object^> ^ Message::GetProperties()
     {
@@ -297,7 +317,29 @@ namespace Messaging {
     }
 
 
-    void Message::SetContent(System::String ^ content)
+	void Message::SetProperty(System::String ^ name, System::Object ^ value)
+	{
+        ::qpid::types::Variant entryValue;
+        TypeTranslator::ManagedToNativeObject(value, entryValue);
+
+		messagep->getProperties()[QpidMarshal::ToNative(name)] = entryValue;
+	}
+
+
+	void Message::SetProperties(System::Collections::Generic::Dictionary<
+            System::String^, System::Object^> ^ properties)
+	{
+		for each (System::Collections::Generic::KeyValuePair
+			     <System::String^, System::Object^> kvp in properties)
+        {
+			SetProperty(kvp.Key, kvp.Value);
+		}
+	}
+
+
+	
+	// Content
+	void Message::SetContent(System::String ^ content)
     {
         messagep->setContent(QpidMarshal::ToNative(content));
     }
@@ -342,8 +384,9 @@ namespace Messaging {
     }
 
     //
-    // User wants content as bytes.
-    // result array must be correct size already
+    // Return message content to raw byte array.
+    // On entry message size must not be zero and
+	// caller's byte array must be equal to message size.
     //
     void Message::GetRaw(array<System::Byte> ^ arr)
     {
@@ -353,16 +396,11 @@ namespace Messaging {
             throw gcnew QpidException("Message::GetRaw - message size is zero");
 
         if (arr->Length != size)
-            throw gcnew QpidException("Message::GetRaw - receive buffer is too small");
+            throw gcnew QpidException("Message::GetRaw - receive buffer is wrong size");
 
-        const char * ptr = messagep->getContentPtr();
-
-        // TODO: System::Runtime::InteropServices::Marshal::Copy(ptr, arr, 0, size);
-
-        for (UInt32 i = 0; i < size; i++)
-        {
-            arr[i] = ptr[i];
-        }
+        const char * pMsgSrc = messagep->getContentPtr();
+		pin_ptr<unsigned char> pArr = &arr[0];
+		memcpy(pArr, pMsgSrc, size);
     }
 
 
@@ -370,4 +408,86 @@ namespace Messaging {
     {
         return messagep->getContentSize();
     }
+
+
+	System::String ^ Message::MapAsString(System::Collections::Generic::Dictionary<
+					           System::String^, System::Object^> ^ dict)
+    {
+		System::String ^ leading = "";
+		System::Text::StringBuilder ^ sb = gcnew System::Text::StringBuilder("{");
+
+		for each (System::Collections::Generic::KeyValuePair
+			     <System::String^, System::Object^> kvp in dict)
+        {
+            sb->Append(leading);
+            leading = ", ";
+
+			if (QpidTypeCheck::ObjectIsMap(kvp.Value))
+            {
+				sb->AppendFormat(
+					"{0}={1}", 
+					kvp.Key,
+					MapAsString((System::Collections::Generic::Dictionary<System::String^, System::Object^> ^)kvp.Value));
+            }
+			else if (QpidTypeCheck::ObjectIsList(kvp.Value))
+            {
+                sb->AppendFormat(
+					"{0}={1}", 
+					kvp.Key,
+					ListAsString((System::Collections::ObjectModel::Collection<
+							System::Object^> ^)kvp.Value));
+            }
+            else
+                sb->AppendFormat("{0}={1}", kvp.Key, kvp.Value);
+        }
+		sb->Append("}");
+
+		System::String ^ result = gcnew System::String(sb->ToString());
+		return result;
+    }
+
+    /// <summary>
+    /// A function to display a ampq/list message packaged as a List.
+    /// </summary>
+    /// <param name="list">The AMQP list</param>
+	System::String ^ Message::ListAsString(System::Collections::ObjectModel::Collection<System::Object^> ^ list)
+    {
+		System::String ^ leading = "";
+		System::Text::StringBuilder ^ sb = gcnew System::Text::StringBuilder("[");
+
+		for each (System::Object ^ obj in list)
+        {
+            sb->Append(leading);
+            leading = ", ";
+
+			if (QpidTypeCheck::ObjectIsMap(obj))
+            {
+                sb->Append(MapAsString((System::Collections::Generic::Dictionary<
+                                System::String^, System::Object^> ^)obj));
+            }
+			else if (QpidTypeCheck::ObjectIsList(obj))
+            {
+                sb->Append(ListAsString((System::Collections::ObjectModel::Collection<
+                                System::Object^> ^)obj));
+            }
+            else
+                sb->Append(obj->ToString());
+        }
+        sb->Append("]");
+
+		System::String ^ result = gcnew System::String(sb->ToString());
+		return result;
+    }
+
+	System::String ^ Message::AsString(System::Object ^ obj)
+	{
+		if (QpidTypeCheck::ObjectIsMap(obj))
+			return MapAsString((System::Collections::Generic::Dictionary<
+                                System::String^, System::Object^> ^)obj);
+		else if (QpidTypeCheck::ObjectIsList(obj))
+			return ListAsString((System::Collections::ObjectModel::Collection<
+                                System::Object^> ^)obj);
+		else
+			return obj->ToString();
+	}
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.h b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
index 0a932a9..99d0b86 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
@@ -58,8 +58,11 @@ namespace Messaging {
         // Create from object
         Message(System::Object ^ theValue);
 
-        // TODO: Create from bytes
-        // Message(System::Byte [] ^ bytes);
+        // Create from byte array
+		Message(array<System::Byte> ^ bytes);
+
+        // Create from byte array slice
+		Message(array<System::Byte> ^ bytes, int offset, int size);
 
         // Create from received message
         Message(::qpid::messaging::Message * msgp);
@@ -108,6 +111,11 @@ namespace Messaging {
         System::Collections::Generic::Dictionary<
             System::String^, System::Object^> ^ GetProperties();
 
+		void SetProperty(System::String ^ name, System::Object ^ value);
+
+		void SetProperties(System::Collections::Generic::Dictionary<
+            System::String^, System::Object^> ^ properties);
+
         void SetContent(System::String ^ content);
 
         //TODO:: void setContent(Bytes{} bytes, offset, length);
@@ -129,6 +137,16 @@ namespace Messaging {
 
         System::UInt64 GetContentSize();
 
+		// A message has been returned to managed code through GetContent().
+		// Display the content of that System::Object as a string.
+		System::String ^ AsString(System::Object ^ obj);
+
+		System::String ^ MapAsString(System::Collections::Generic::Dictionary<
+						System::String^, System::Object^> ^ dict);
+		
+		System::String ^ ListAsString(System::Collections::ObjectModel::Collection<
+			            System::Object^> ^ list);
+
         //TODO: EncodingException
 
         // Note: encode/decode functions are in TypeTranslator
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
index c8d85b0..04fbb61 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
@@ -27,6 +27,7 @@
 #include "qpid/messaging/exceptions.h"
 
 #include "QpidMarshal.h"
+#include "Address.h"
 #include "Session.h"
 #include "Connection.h"
 #include "Duration.h"
@@ -207,6 +208,54 @@ namespace Messaging {
     Sender ^ Session::CreateSender  (System::String ^ address)
     {
         System::Exception          ^ newException = nullptr;
+        ::qpid::messaging::Sender  * senderp      = NULL;
+        Sender                     ^ newSender    = nullptr;
+
+        try
+        {
+            // allocate a native sender
+            ::qpid::messaging::Sender * senderp = new ::qpid::messaging::Sender ;
+
+            // create the sender
+            *senderp = sessionp->::qpid::messaging::Session::createSender(QpidMarshal::ToNative(address));
+
+            // create a managed sender
+            newSender = gcnew Sender(senderp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        finally
+        {
+            if (newException != nullptr)
+            {
+				if (newSender != nullptr)
+				{
+					delete newSender;
+				}
+				else
+				{
+					if (senderp != NULL)
+					{
+						delete senderp;
+					}
+				}
+            }
+        }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
+
+        return newSender;
+    }
+
+
+    Sender ^ Session::CreateSender  (Address ^ address)
+    {
+        System::Exception          ^ newException = nullptr;
         ::qpid::messaging::Sender  * senderp         = NULL;
         Sender                     ^ newSender       = nullptr;
 
@@ -216,7 +265,7 @@ namespace Messaging {
             ::qpid::messaging::Sender * senderp = new ::qpid::messaging::Sender ;
 
             // create the sender
-            *senderp = sessionp->::qpid::messaging::Session::createSender(QpidMarshal::ToNative(address));
+            *senderp = sessionp->::qpid::messaging::Session::createSender(*(address->NativeAddress));
 
             // create a managed sender
             newSender = gcnew Sender(senderp, this);
@@ -251,7 +300,8 @@ namespace Messaging {
         return newSender;
     }
 
-    Receiver ^ Session::CreateReceiver(System::String ^ address)
+
+	Receiver ^ Session::CreateReceiver(System::String ^ address)
     {
         System::Exception           ^ newException = nullptr;
         ::qpid::messaging::Receiver * receiverp    = NULL;
@@ -299,6 +349,54 @@ namespace Messaging {
     }
 
 
+	Receiver ^ Session::CreateReceiver(Address ^ address)
+    {
+        System::Exception           ^ newException = nullptr;
+        ::qpid::messaging::Receiver * receiverp    = NULL;
+        Receiver                    ^ newReceiver  = nullptr;
+
+        try 
+		{
+            // allocate a native receiver
+            receiverp = new ::qpid::messaging::Receiver;
+
+            // create the receiver
+            *receiverp = sessionp->createReceiver(*(address->NativeAddress));
+
+            // create a managed receiver
+            newReceiver = gcnew Receiver(receiverp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+		{
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        finally 
+		{
+            if (newException != nullptr)
+			{
+				if (newReceiver != nullptr)
+				{
+					delete newReceiver;
+				}
+				else
+				{
+					if (receiverp != NULL)
+					{
+						delete receiverp;
+					}
+				}
+            }
+        }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
+
+        return newReceiver;
+    }
+
+
     Receiver ^ Session::CreateReceiver()
     {
         System::Exception           ^ newException = nullptr;
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.h b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
index babb99d..4b84eec 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
@@ -45,6 +45,7 @@ namespace Messaging {
     /// Session is a managed wrapper for a ::qpid::messaging::Session
     /// </summary>
 
+	ref class Address;
     ref class Connection;
     ref class Duration;
     ref class Receiver;
@@ -99,8 +100,11 @@ namespace Messaging {
         Receiver ^ NextReceiver(Duration ^ timeout);
 
 
-        Sender   ^ CreateSender  (System::String ^ address);
+        Sender   ^ CreateSender(System::String ^ address);
+		Sender   ^ CreateSender(Address ^ address);
+
         Receiver ^ CreateReceiver(System::String ^ address);
+		Receiver ^ CreateReceiver(Address ^ address);
         Receiver ^ CreateReceiver();
 
         Sender   ^ GetSender(System::String ^ name);
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
index 04ddc17..8e324a4 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/src/sessionreceiver/org.apache.qpid.messaging.sessionreceiver.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{B0A51CEC-30A2-4C2E-90BE-AE95107EAA05}</ProjectGuid>
     <OutputType>Library</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
index 923952b..5763077 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
@@ -83,6 +83,37 @@ namespace Org.Apache.Qpid.Messaging
             Console.WriteLine("Got raw array size {0}", m2Size);
             for (UInt64 i = 0; i < m2Size; i++)
                 Console.Write("{0} ", myRaw[i].ToString());
+            Console.WriteLine();
+
+            //
+            // Raw message creation
+            //
+            byte[] rawData = new byte[10];
+            for (byte i=0; i<10; i++)
+                rawData[i] = i;
+            Message m3 = new Message(rawData);
+
+            byte[] rawDataReadback = new byte[m3.GetContentSize()];
+            m3.GetRaw(rawDataReadback);
+            for (UInt64 i = 0; i < m3.GetContentSize(); i++)
+                Console.Write("{0} ", rawDataReadback[i].ToString());
+            Console.WriteLine();
+
+            //
+            // Raw message from array slice
+            //
+            byte[] rawData4 = new byte[256];
+            for (int i = 0; i <= 255; i++)
+                rawData4[i] = (byte)i;
+
+            Message m4 = new Message(rawData4, 246, 10);
+
+            byte[] rawDataReadback4 = new byte[m4.GetContentSize()];
+            m4.GetRaw(rawDataReadback4);
+            for (UInt64 i = 0; i < m4.GetContentSize(); i++)
+                Console.Write("{0} ", rawDataReadback4[i].ToString());
+            Console.WriteLine();
+
         }
     }
 }
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
index 5dddc59..e4f1175 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.csproj
@@ -3,7 +3,7 @@
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>9.0.21022</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{AF2FBC78-266C-430C-BC29-9477AB596A36}</ProjectGuid>
     <OutputType>Exe</OutputType>
@@ -67,7 +67,7 @@
   <ItemGroup>
     <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
       <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
-      <Name>org.apache.qpid.messaging</Name>
+      <Name>Org.Apache.Qpid.Messaging</Name>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-- 
1.7.1.1

From 7ae72bd17b22f6107f6f3e69779a7918fddfd1e3 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Thu, 24 Jun 2010 12:40:11 +0000
Subject: [PATCH 090/129] QPID-2589 - Patch from Chuck Rolke
 Visual Basic example added, UUID support added, C# Hello World example added.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@957531 13f79535-47bb-0310-9956-ffa450edef68
---
 .../Properties/AssemblyInfo.cs                     |   36 ++++++
 .../csharp.example.helloworld.cs                   |   55 ++++++++
 .../csharp.example.helloworld.csproj               |   81 ++++++++++++
 .../csharp.map.callback.sender.cs                  |    3 +
 .../csharp.map.sender/csharp.map.sender.cs         |    3 +
 .../MyProject/Application.Designer.vb              |   13 ++
 .../MyProject/Application.myapp                    |   10 ++
 .../MyProject/AssemblyInfo.vb                      |   35 +++++
 .../MyProject/Resources.Designer.vb                |   63 +++++++++
 .../MyProject/Resources.resx                       |  117 +++++++++++++++++
 .../MyProject/Settings.Designer.vb                 |   73 +++++++++++
 .../MyProject/Settings.settings                    |    7 +
 .../visualbasic.example.client.vb                  |   69 ++++++++++
 .../visualbasic.example.client.vbproj              |  134 ++++++++++++++++++++
 .../qpid/dotnet/org.apache.qpid.messaging.sln      |   37 ++++++
 .../bindings/qpid/dotnet/src/TypeTranslator.cpp    |   30 +++++-
 .../dotnet/test/messaging.test/messaging.test.cs   |   14 ++
 17 files changed, 779 insertions(+), 1 deletions(-)
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/Properties/AssemblyInfo.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.cs
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.csproj
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.Designer.vb
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.myapp
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/AssemblyInfo.vb
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.Designer.vb
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.resx
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.Designer.vb
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.settings
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vbproj

diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/Properties/AssemblyInfo.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..2b96ce9
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("csharp.direct.sender")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("csharp.direct.sender")]
+[assembly: AssemblyCopyright("Copyright ?  2010")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("19ce67e4-db90-4480-88c4-3721f47634c7")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.cs
new file mode 100644
index 0000000..336970a
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.cs
@@ -0,0 +1,55 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+using System;
+using Org.Apache.Qpid.Messaging;
+
+namespace Org.Apache.Qpid.Messaging {
+    class Program {
+        static void Main(string[] args) {
+            String broker = args.Length > 0 ? args[0] : "localhost:5672";
+            String address = args.Length > 1 ? args[1] : "amq.topic";
+
+            Connection connection = null;
+            try {
+                connection = new Connection(broker);
+                connection.Open();
+                Session session = connection.CreateSession();
+
+                Receiver receiver = session.CreateReceiver(address);
+                Sender sender = session.CreateSender(address);
+
+                sender.Send(new Message("Hello world!"));
+
+                Message message = new Message();
+                message = receiver.Fetch(DurationConstants.SECOND * 1);
+                Console.WriteLine("{0}", message.GetContent());
+                session.Acknowledge();
+
+                connection.Close();
+            } catch (Exception e) {
+                Console.WriteLine("Exception {0}.", e);
+                if (null != connection)
+                    connection.Close();
+            }
+        }
+    }
+}
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.csproj b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.csproj
new file mode 100644
index 0000000..3038ed6
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.helloworld/csharp.example.helloworld.csproj
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{8CC1C265-0507-44A3-9483-8FAF48513F4D}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>csharp.example.helloworld</RootNamespace>
+    <AssemblyName>csharp.example.helloworld</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <OutputPath>..\..\..\..\..\src\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="csharp.example.helloworld.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
index 2b17052..c987ad9 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.sender/csharp.map.callback.sender.cs
@@ -150,6 +150,9 @@ namespace Org.Apache.Qpid.Messaging.Examples
             Double myDouble = 13.13;
             content["myDouble"] = myDouble;
 
+            Guid myGuid = new Guid("000102030405060708090a0b0c0d0e0f");
+            content["myGuid"] = myGuid;
+
             //
             // Construct a message with the map content and send it synchronously
             // via the sender.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
index 5517226..0763b74 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.sender/csharp.map.sender.cs
@@ -113,6 +113,9 @@ namespace Org.Apache.Qpid.Messaging.examples
             Double myDouble = 13.13;
             content["myDouble"] = myDouble;
 
+            Guid myGuid = new Guid("000102030405060708090a0b0c0d0e0f");
+            content["myGuid"] = myGuid;
+
             //
             // Construct a message with the map content and send it synchronously
             // via the sender.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.Designer.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.Designer.vb
new file mode 100644
index 0000000..0c27414
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.Designer.vb
@@ -0,0 +1,13 @@
+'------------------------------------------------------------------------------
+' <auto-generated>
+'     This code was generated by a tool.
+'     Runtime Version:2.0.50727.4927
+'
+'     Changes to this file may cause incorrect behavior and will be lost if
+'     the code is regenerated.
+' </auto-generated>
+'------------------------------------------------------------------------------
+
+Option Strict On
+Option Explicit On
+
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.myapp b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.myapp
new file mode 100644
index 0000000..44772fe
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Application.myapp
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<MyApplicationData xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <MySubMain>false</MySubMain>
+  <SingleInstance>false</SingleInstance>
+  <ShutdownMode>0</ShutdownMode>
+  <EnableVisualStyles>true</EnableVisualStyles>
+  <AuthenticationMode>0</AuthenticationMode>
+  <ApplicationType>2</ApplicationType>
+  <SaveMySettingsOnExit>true</SaveMySettingsOnExit>
+</MyApplicationData>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/AssemblyInfo.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/AssemblyInfo.vb
new file mode 100644
index 0000000..100283c
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/AssemblyInfo.vb
@@ -0,0 +1,35 @@
+Imports System
+Imports System.Reflection
+Imports System.Runtime.InteropServices
+
+' General Information about an assembly is controlled through the following 
+' set of attributes. Change these attribute values to modify the information
+' associated with an assembly.
+
+' Review the values of the assembly attributes
+
+<Assembly: AssemblyTitle("visualbasic.example.client")> 
+<Assembly: AssemblyDescription("")> 
+<Assembly: AssemblyCompany("Microsoft")> 
+<Assembly: AssemblyProduct("visualbasic.example.client")> 
+<Assembly: AssemblyCopyright("Copyright  Microsoft 2010")> 
+<Assembly: AssemblyTrademark("")> 
+
+<Assembly: ComVisible(False)>
+
+'The following GUID is for the ID of the typelib if this project is exposed to COM
+<Assembly: Guid("ec9df8cf-c1d4-4938-9e72-93fb81d55700")> 
+
+' Version information for an assembly consists of the following four values:
+'
+'      Major Version
+'      Minor Version 
+'      Build Number
+'      Revision
+'
+' You can specify all the values or you can default the Build and Revision Numbers 
+' by using the '*' as shown below:
+' <Assembly: AssemblyVersion("1.0.*")> 
+
+<Assembly: AssemblyVersion("1.0.0.0")> 
+<Assembly: AssemblyFileVersion("1.0.0.0")> 
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.Designer.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.Designer.vb
new file mode 100644
index 0000000..19d7b32
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.Designer.vb
@@ -0,0 +1,63 @@
+'------------------------------------------------------------------------------
+' <auto-generated>
+'     This code was generated by a tool.
+'     Runtime Version:2.0.50727.4927
+'
+'     Changes to this file may cause incorrect behavior and will be lost if
+'     the code is regenerated.
+' </auto-generated>
+'------------------------------------------------------------------------------
+
+Option Strict On
+Option Explicit On
+
+Imports System
+
+Namespace My.Resources
+    
+    'This class was auto-generated by the StronglyTypedResourceBuilder
+    'class via a tool like ResGen or Visual Studio.
+    'To add or remove a member, edit your .ResX file then rerun ResGen
+    'with the /str option, or rebuild your VS project.
+    '''<summary>
+    '''  A strongly-typed resource class, for looking up localized strings, etc.
+    '''</summary>
+    <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0"),  _
+     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
+     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
+     Global.Microsoft.VisualBasic.HideModuleNameAttribute()>  _
+    Friend Module Resources
+        
+        Private resourceMan As Global.System.Resources.ResourceManager
+        
+        Private resourceCulture As Global.System.Globalization.CultureInfo
+        
+        '''<summary>
+        '''  Returns the cached ResourceManager instance used by this class.
+        '''</summary>
+        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
+        Friend ReadOnly Property ResourceManager() As Global.System.Resources.ResourceManager
+            Get
+                If Object.ReferenceEquals(resourceMan, Nothing) Then
+                    Dim temp As Global.System.Resources.ResourceManager = New Global.System.Resources.ResourceManager("Org.Apache.Qpid.Messaging.Examples.Resources", GetType(Resources).Assembly)
+                    resourceMan = temp
+                End If
+                Return resourceMan
+            End Get
+        End Property
+        
+        '''<summary>
+        '''  Overrides the current thread's CurrentUICulture property for all
+        '''  resource lookups using this strongly typed resource class.
+        '''</summary>
+        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
+        Friend Property Culture() As Global.System.Globalization.CultureInfo
+            Get
+                Return resourceCulture
+            End Get
+            Set
+                resourceCulture = value
+            End Set
+        End Property
+    End Module
+End Namespace
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.resx b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.resx
new file mode 100644
index 0000000..3a752df
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Resources.resx
@@ -0,0 +1,117 @@
+<?xml version="1.0" encoding="utf-8"?>
+<root>
+  <!-- 
+    Microsoft ResX Schema 
+    
+    Version 2.0
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
+    associated with the data types.
+    
+    Example:
+    
+    ... ado.net/XML headers & schema ...
+    <resheader name="resmimetype">text/microsoft-resx</resheader>
+    <resheader name="version">2.0</resheader>
+    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
+    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
+    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
+    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
+    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
+        <value>[base64 mime encoded serialized .NET Framework object]</value>
+    </data>
+    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
+        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
+        <comment>This is a comment</comment>
+    </data>
+                
+    There are any number of "resheader" rows that contain simple 
+    name/value pairs.
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
+    mimetype set.
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
+    extensible. For a given mimetype the value must be set accordingly:
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
+    read any of the formats listed below.
+    
+    mimetype: application/x-microsoft.net.object.binary.base64
+    value   : The object must be serialized with 
+            : System.Serialization.Formatters.Binary.BinaryFormatter
+            : and then encoded with base64 encoding.
+    
+    mimetype: application/x-microsoft.net.object.soap.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
+            : and then encoded with base64 encoding.
+
+    mimetype: application/x-microsoft.net.object.bytearray.base64
+    value   : The object must be serialized into a byte array 
+            : using a System.ComponentModel.TypeConverter
+            : and then encoded with base64 encoding.
+    -->
+  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
+    <xsd:element name="root" msdata:IsDataSet="true">
+      <xsd:complexType>
+        <xsd:choice maxOccurs="unbounded">
+          <xsd:element name="metadata">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" />
+              <xsd:attribute name="type" type="xsd:string" />
+              <xsd:attribute name="mimetype" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="assembly">
+            <xsd:complexType>
+              <xsd:attribute name="alias" type="xsd:string" />
+              <xsd:attribute name="name" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="data">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
+              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
+              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="resheader">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" use="required" />
+            </xsd:complexType>
+          </xsd:element>
+        </xsd:choice>
+      </xsd:complexType>
+    </xsd:element>
+  </xsd:schema>
+  <resheader name="resmimetype">
+    <value>text/microsoft-resx</value>
+  </resheader>
+  <resheader name="version">
+    <value>2.0</value>
+  </resheader>
+  <resheader name="reader">
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+  <resheader name="writer">
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+</root>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.Designer.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.Designer.vb
new file mode 100644
index 0000000..fd9a759
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.Designer.vb
@@ -0,0 +1,73 @@
+'------------------------------------------------------------------------------
+' <auto-generated>
+'     This code was generated by a tool.
+'     Runtime Version:2.0.50727.4927
+'
+'     Changes to this file may cause incorrect behavior and will be lost if
+'     the code is regenerated.
+' </auto-generated>
+'------------------------------------------------------------------------------
+
+Option Strict On
+Option Explicit On
+
+
+Namespace My
+    
+    <Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
+     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0"),  _
+     Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
+    Partial Friend NotInheritable Class MySettings
+        Inherits Global.System.Configuration.ApplicationSettingsBase
+        
+        Private Shared defaultInstance As MySettings = CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New MySettings),MySettings)
+        
+#Region "My.Settings Auto-Save Functionality"
+#If _MyType = "WindowsForms" Then
+    Private Shared addedHandler As Boolean
+
+    Private Shared addedHandlerLockObject As New Object
+
+    <Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
+    Private Shared Sub AutoSaveSettings(ByVal sender As Global.System.Object, ByVal e As Global.System.EventArgs)
+        If My.Application.SaveMySettingsOnExit Then
+            My.Settings.Save()
+        End If
+    End Sub
+#End If
+#End Region
+        
+        Public Shared ReadOnly Property [Default]() As MySettings
+            Get
+                
+#If _MyType = "WindowsForms" Then
+               If Not addedHandler Then
+                    SyncLock addedHandlerLockObject
+                        If Not addedHandler Then
+                            AddHandler My.Application.Shutdown, AddressOf AutoSaveSettings
+                            addedHandler = True
+                        End If
+                    End SyncLock
+                End If
+#End If
+                Return defaultInstance
+            End Get
+        End Property
+    End Class
+End Namespace
+
+Namespace My
+    
+    <Global.Microsoft.VisualBasic.HideModuleNameAttribute(),  _
+     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
+     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute()>  _
+    Friend Module MySettingsProperty
+        
+        <Global.System.ComponentModel.Design.HelpKeywordAttribute("My.Settings")>  _
+        Friend ReadOnly Property Settings() As Global.Org.Apache.Qpid.Messaging.Examples.My.MySettings
+            Get
+                Return Global.Org.Apache.Qpid.Messaging.Examples.My.MySettings.Default
+            End Get
+        End Property
+    End Module
+End Namespace
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.settings b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.settings
new file mode 100644
index 0000000..73b4a10
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/MyProject/Settings.settings
@@ -0,0 +1,7 @@
+<?xml version='1.0' encoding='utf-8'?>
+<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)" UseMySettingsClassName="true">
+  <Profiles>
+    <Profile Name="(Default)" />
+  </Profiles>
+  <Settings />
+</SettingsFile>
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
new file mode 100644
index 0000000..96300ec
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
@@ -0,0 +1,69 @@
+'
+'
+' Licensed to the Apache Software Foundation (ASF) under one
+' or more contributor license agreements.  See the NOTICE file
+' distributed with this work for additional information
+' regarding copyright ownership.  The ASF licenses this file
+' to you under the Apache License, Version 2.0 (the
+' "License"); you may not use this file except in compliance
+' with the License.  You may obtain a copy of the License at
+' 
+'   http://www.apache.org/licenses/LICENSE-2.0
+' 
+' Unless required by applicable law or agreed to in writing,
+' software distributed under the License is distributed on an
+' "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+' KIND, either express or implied.  See the License for the
+' specific language governing permissions and limitations
+' under the License.
+'
+'
+
+Imports System
+Imports Org.Apache.Qpid.Messaging
+Namespace Org.Apache.Qpid.Messaging.Examples
+    Module Module1
+        Class Client
+            Public Shared Sub Main(ByVal args() As String)
+                Dim url As String = "amqp:tcp:127.0.0.1:5672"
+
+                If args.Length > 0 Then url = args(0)
+
+                Dim connection As Connection
+                Try
+                    connection = New Connection(url)
+                    connection.Open()
+
+                    Dim session As Session = connection.CreateSession()
+
+                    Dim sender As Sender = session.CreateSender("service_queue")
+
+                    Dim responseQueue As Address = New Address("#response-queue; {create:always, delete:always}")
+                    Dim receiver As Receiver = session.CreateReceiver(responseQueue)
+
+                    Dim s(3) As String
+                    s(0) = "Twas brillig, and the slithy toves"
+                    s(1) = "Did gire and gymble in the wabe."
+                    s(2) = "All mimsy were the borogroves,"
+                    s(3) = "And the mome raths outgrabe."
+
+                    Dim request As Message = New Message("")
+                    request.SetReplyTo(responseQueue)
+
+                    Dim i As Integer
+                    For i = 0 To s.Length - 1
+                        request.SetContent(s(i))
+                        sender.Send(request)
+                        Dim response As Message = receiver.Fetch()
+                        Console.WriteLine("{0} -> {1}", request.GetContent(), response.GetContent())
+                    Next i
+                    connection.Close()
+
+                Catch e As Exception
+                    Console.WriteLine("Exception {0}.", e)
+                    connection.Close()
+                End Try
+            End Sub
+        End Class
+    End Module
+End Namespace
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vbproj b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vbproj
new file mode 100644
index 0000000..ae1c012
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vbproj
@@ -0,0 +1,134 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{CFEA696E-115B-4AD1-AB56-804E360EDD51}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <StartupObject>Sub Main</StartupObject>
+    <RootNamespace>Org.Apache.Qpid.Messaging.Examples</RootNamespace>
+    <AssemblyName>visualbasic.example.client</AssemblyName>
+    <FileAlignment>512</FileAlignment>
+    <MyType>Console</MyType>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <OptionExplicit>On</OptionExplicit>
+    <OptionCompare>Binary</OptionCompare>
+    <OptionStrict>Off</OptionStrict>
+    <OptionInfer>On</OptionInfer>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DocumentationFile>visualbasic.example.client.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <DefineDebug>false</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DocumentationFile>visualbasic.example.client.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\..\..\..\..\src\Debug\</OutputPath>
+    <DocumentationFile>visualbasic.example.client.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\x86\Release\</OutputPath>
+    <DocumentationFile>visualbasic.example.client.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Data" />
+    <Reference Include="System.Deployment" />
+    <Reference Include="System.Xml" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Data.DataSetExtensions">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <Import Include="Microsoft.VisualBasic" />
+    <Import Include="System" />
+    <Import Include="System.Collections" />
+    <Import Include="System.Collections.Generic" />
+    <Import Include="System.Data" />
+    <Import Include="System.Diagnostics" />
+    <Import Include="System.Linq" />
+    <Import Include="System.Xml.Linq" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="visualbasic.example.client.vb" />
+    <Compile Include="MyProject\AssemblyInfo.vb" />
+    <Compile Include="MyProject\Application.Designer.vb">
+      <AutoGen>True</AutoGen>
+      <DependentUpon>Application.myapp</DependentUpon>
+    </Compile>
+    <Compile Include="MyProject\Resources.Designer.vb">
+      <AutoGen>True</AutoGen>
+      <DesignTime>True</DesignTime>
+      <DependentUpon>Resources.resx</DependentUpon>
+    </Compile>
+    <Compile Include="MyProject\Settings.Designer.vb">
+      <AutoGen>True</AutoGen>
+      <DependentUpon>Settings.settings</DependentUpon>
+      <DesignTimeSharedInput>True</DesignTimeSharedInput>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <EmbeddedResource Include="MyProject\Resources.resx">
+      <Generator>VbMyResourcesResXFileCodeGenerator</Generator>
+      <LastGenOutput>Resources.Designer.vb</LastGenOutput>
+      <CustomToolNamespace>My.Resources</CustomToolNamespace>
+      <SubType>Designer</SubType>
+    </EmbeddedResource>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="MyProject\Application.myapp">
+      <Generator>MyApplicationCodeGenerator</Generator>
+      <LastGenOutput>Application.Designer.vb</LastGenOutput>
+    </None>
+    <None Include="MyProject\Settings.settings">
+      <Generator>SettingsSingleFileGenerator</Generator>
+      <CustomToolNamespace>My</CustomToolNamespace>
+      <LastGenOutput>Settings.Designer.vb</LastGenOutput>
+    </None>
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\src\org.apache.qpid.messaging.vcproj">
+      <Project>{AA5A3B83-5F98-406D-A01C-5A921467A57D}</Project>
+      <Name>Org.Apache.Qpid.Messaging</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.VisualBasic.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
diff --git a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
index 7269dad..8df1ea6 100644
--- a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
+++ b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
@@ -57,6 +57,12 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.spout", "exa
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.declare_queues", "examples\csharp.example.declare_queues\csharp.example.declare_queues.csproj", "{E31B349C-830C-4583-8BD9-30DA4398349F}"
 EndProject
+Project("{F184B08F-C81C-45F6-A57F-5ABD9991F28F}") = "visualbasic.example.client", "examples\visualbasic.example.client\visualbasic.example.client.vbproj", "{CFEA696E-115B-4AD1-AB56-804E360EDD51}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Hello World", "Hello World", "{4408A2DA-ED2D-44AE-A465-0B6D75E1FF86}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.helloworld", "examples\csharp.example.helloworld\csharp.example.helloworld.csproj", "{8CC1C265-0507-44A3-9483-8FAF48513F4D}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -264,6 +270,34 @@ Global
 		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|Win32.ActiveCfg = Release|x86
 		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|x86.ActiveCfg = Release|x86
 		{E31B349C-830C-4583-8BD9-30DA4398349F}.Release|x86.Build.0 = Release|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|Win32.ActiveCfg = Debug|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|x86.ActiveCfg = Debug|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Debug|x86.Build.0 = Debug|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|Any CPU.Build.0 = Release|Any CPU
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|Mixed Platforms.Build.0 = Release|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|Win32.ActiveCfg = Release|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|x86.ActiveCfg = Release|x86
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51}.Release|x86.Build.0 = Release|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|Win32.ActiveCfg = Debug|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|x86.ActiveCfg = Debug|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Debug|x86.Build.0 = Debug|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|Any CPU.Build.0 = Release|Any CPU
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|Mixed Platforms.Build.0 = Release|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|Win32.ActiveCfg = Release|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|x86.ActiveCfg = Release|x86
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D}.Release|x86.Build.0 = Release|x86
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -274,6 +308,7 @@ Global
 		{E99FEFEE-B866-4BBA-9AA3-79DDF1C92960} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{9232212E-F3C6-4D18-8D25-0C31DD5FF3DB} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{89CE04CB-21DE-4ABB-9236-50529DD8C022} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
+		{4408A2DA-ED2D-44AE-A465-0B6D75E1FF86} = {34C477FB-B0CC-4AB9-A346-EA7B055469AC}
 		{7B71CE78-8E78-4632-ADBE-F4D5DFAE0068} = {DE58D329-10DC-4C8D-9EFA-230A57314089}
 		{52F880E7-D677-4C91-8516-D679CE0F46A8} = {DE58D329-10DC-4C8D-9EFA-230A57314089}
 		{AF2FBC78-266C-430C-BC29-9477AB596A36} = {39E9D1BF-3A0B-4D86-BF6B-F463E1A2245A}
@@ -281,10 +316,12 @@ Global
 		{AD9E53D7-DB10-4DA2-84D2-A81BE09B04E9} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{68A43817-2358-4A31-8FDF-FE21722BFBCF} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{12F1C14F-5C7D-4075-9BAE-C091394FF99A} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
+		{CFEA696E-115B-4AD1-AB56-804E360EDD51} = {E99FEFEE-B866-4BBA-9AA3-79DDF1C92960}
 		{0DE01712-C2D1-4CA4-B42C-5856456A8696} = {9232212E-F3C6-4D18-8D25-0C31DD5FF3DB}
 		{090A081D-E8B5-4949-AA43-EE182B7101E3} = {9232212E-F3C6-4D18-8D25-0C31DD5FF3DB}
 		{C43DEB69-8088-420B-B0CA-C699535E6D08} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
 		{EB36626D-36C2-41B3-B65E-762BAF27F137} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
 		{E31B349C-830C-4583-8BD9-30DA4398349F} = {89CE04CB-21DE-4ABB-9236-50529DD8C022}
+		{8CC1C265-0507-44A3-9483-8FAF48513F4D} = {4408A2DA-ED2D-44AE-A465-0B6D75E1FF86}
 	EndGlobalSection
 EndGlobal
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
index d463e66..c4587fe 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/TypeTranslator.cpp
@@ -221,7 +221,25 @@ namespace Messaging {
             }
             break;
 
-            
+        case System::TypeCode::Object :
+            {
+                //
+                // Derived classes
+                //
+                if ("System.Guid" == typeP->ToString())
+                {
+                    cli::array<System::Byte> ^ guidBytes = ((System::Guid)managedValue).ToByteArray();
+                    pin_ptr<unsigned char> pinnedBuf = &guidBytes[0];
+                    ::qpid::types::Uuid newUuid = ::qpid::types::Uuid(pinnedBuf);
+                    qpidVariant = newUuid;
+                }
+                else
+                {
+                    throw gcnew System::NotImplementedException();
+                }
+            }
+            break;
+
         default:
 
             throw gcnew System::NotImplementedException();
@@ -318,6 +336,11 @@ namespace Messaging {
                 }
                 
             case ::qpid::types::VAR_UUID:
+                {
+                    System::String ^ elementValue = gcnew System::String(variant.asUuid().str().c_str());
+                    System::Guid ^ newGuid = System::Guid(elementValue);
+                    dict[elementName] = newGuid;
+                }
                 break;
             }
         }
@@ -406,6 +429,11 @@ namespace Messaging {
                 }
                 
             case ::qpid::types::VAR_UUID:
+                {
+                    System::String ^ elementValue = gcnew System::String(variant.asUuid().str().c_str());
+                    System::Guid ^ newGuid = System::Guid(elementValue);
+                    (*managedList).Add(newGuid);
+                }
                 break;
             }
         }
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
index 5763077..2e0e481 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
@@ -114,6 +114,20 @@ namespace Org.Apache.Qpid.Messaging
                 Console.Write("{0} ", rawDataReadback4[i].ToString());
             Console.WriteLine();
 
+            //
+            // Guid factoids
+            //
+            Guid myGuid = new Guid("000102030405060708090a0b0c0d0e0f");
+            System.Type typeP = myGuid.GetType();
+            System.TypeCode typeCode = System.Type.GetTypeCode(typeP);
+
+            Console.WriteLine("Guid Type = {0}, TypeCode = {1}",
+                typeP.ToString(), typeCode.ToString());
+            // typeP="System.Guid", typeCode="Object"
+            byte[] guidReadback;
+            guidReadback = myGuid.ToByteArray();
+
+            Console.WriteLine("GuidReadback len = {0}", guidReadback.Length);
         }
     }
 }
-- 
1.7.1.1

From 55095229ebc4764c1add9810ea41a76296656c23 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Fri, 25 Jun 2010 17:55:46 +0000
Subject: [PATCH 091/129] QPID-2589 - Patch from Chuck Rolke
 * Convert c-style Get() functions to c#-style properties.
 * Add powershell helloworld example.
 * Fix message SetContent to accept byte array or byte array slice.
 * Re-code Session GetReceiver and GetSender not to malloc new objects but to create the objects on the stack.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958052 13f79535-47bb-0310-9956-ffa450edef68
---
 .../csharp.direct.receiver.cs                      |    2 +-
 .../csharp.direct.sender/csharp.direct.sender.cs   |    2 +-
 .../csharp.example.client/csharp.example.client.cs |    2 +-
 .../csharp.example.drain/csharp.example.drain.cs   |    6 +-
 .../csharp.example.server/csharp.example.server.cs |    2 +-
 .../csharp.example.spout/csharp.example.spout.cs   |    8 +-
 .../csharp.map.callback.receiver.cs                |    8 +-
 .../powershell.example.helloworld.ps1              |   34 +++
 .../visualbasic.example.client.vb                  |    2 +-
 .../qpid/dotnet/org.apache.qpid.messaging.sln      |    3 +
 qpid/cpp/bindings/qpid/dotnet/src/Address.cpp      |   81 +------
 qpid/cpp/bindings/qpid/dotnet/src/Address.h        |   90 ++++++-
 qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp   |    5 -
 qpid/cpp/bindings/qpid/dotnet/src/Connection.h     |    9 +-
 qpid/cpp/bindings/qpid/dotnet/src/Message.cpp      |  194 ++--------------
 qpid/cpp/bindings/qpid/dotnet/src/Message.h        |  254 +++++++++++++++++---
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp     |   32 +---
 qpid/cpp/bindings/qpid/dotnet/src/Receiver.h       |   66 +++++-
 qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp       |    7 +-
 qpid/cpp/bindings/qpid/dotnet/src/Sender.h         |   11 +-
 qpid/cpp/bindings/qpid/dotnet/src/Session.cpp      |   22 +-
 qpid/cpp/bindings/qpid/dotnet/src/Session.h        |    9 +-
 .../dotnet/test/messaging.test/messaging.test.cs   |   27 ++-
 23 files changed, 498 insertions(+), 378 deletions(-)
 create mode 100644 qpid/cpp/bindings/qpid/dotnet/examples/powershell.example.helloworld/powershell.example.helloworld.ps1

diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
index af0b398..69f7a0d 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.receiver/csharp.direct.receiver.cs
@@ -58,7 +58,7 @@ namespace CSharpDirect
             {
                 connection = new Connection(host);
                 connection.Open();
-                if (!connection.IsOpen()) {
+                if (!connection.IsOpen) {
                     Console.WriteLine("Failed to open connection to host : {0}", host);
                 } else {
                     Session session = connection.CreateSession();
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
index b287af2..2e80e8c 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.direct.sender/csharp.direct.sender.cs
@@ -59,7 +59,7 @@ namespace csharp.direct.sender
                 connection = new Connection(host);
                 connection.Open();
 
-                if (!connection.IsOpen()) {
+                if (!connection.IsOpen) {
                     Console.WriteLine("Failed to open connection to host : {0}", host);
                 } else {
                     Session session = connection.CreateSession();
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
index 93459b6..79b798e 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.client/csharp.example.client.cs
@@ -50,7 +50,7 @@ namespace Org.Apache.Qpid.Messaging.Examples {
                 };
 
                 Message request = new Message("");
-                request.SetReplyTo(responseQueue);
+                request.ReplyTo = responseQueue;
 
                 for (int i = 0; i < s.Length; i++) {
                     request.SetContent(s[i]);
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
index 6740e6a..2d763a3 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.drain/csharp.example.drain.cs
@@ -47,17 +47,17 @@ namespace Org.Apache.Qpid.Messaging.Examples {
                 while (receiver.Fetch(message, timeout))
                 {
                     Dictionary<string, object> properties = new Dictionary<string, object>();
-                    properties = message.GetProperties();
+                    properties = message.Properties;
                     Console.Write("Message(properties={0}, content='", 
                                   message.MapAsString(properties));
 
-                    if ("amqp/map" == message.GetContentType())
+                    if ("amqp/map" == message.ContentType)
                     {
                         Dictionary<string, object> content = new Dictionary<string, object>();
                         message.GetContent(content);
                         Console.Write(message.MapAsString(content));
                     }
-                    else if ("amqp/list" == message.GetContentType())
+                    else if ("amqp/list" == message.ContentType)
                     {
                         Collection<object> content = new Collection<object>();
                         message.GetContent(content);
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
index af01e4b..4ec5649 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.server/csharp.example.server.cs
@@ -38,7 +38,7 @@ namespace Org.Apache.Qpid.Messaging.Examples {
 
                 while (true) {
                     Message request = receiver.Fetch();
-                    Address address = request.GetReplyTo();
+                    Address address = request.ReplyTo;
 
                     if (null != address) {
                         Sender sender = session.CreateSender(address);
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
index 7eeece3..59ba35f 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.example.spout/csharp.example.spout.cs
@@ -29,8 +29,8 @@ using Org.Apache.Qpid.Messaging;
 namespace Org.Apache.Qpid.Messaging.Examples {
     class Spout {
         //
-        // Sample invocation: csharp.example.drain.exe --broker localhost:5672 --timeout 30 my-queue
-        // This pro
+        // Sample invocation: csharp.example.spout.exe --broker localhost:5672 my-queue
+        // 
         static bool NameVal(string In, out string nameOut, out string valueOut)
         {
             int pos = In.IndexOf("=");
@@ -83,7 +83,7 @@ namespace Org.Apache.Qpid.Messaging.Examples {
                 else
                 {
                     message = new Message(options.Content);
-                    message.SetContentType("text/plain");
+                    message.ContentType = "text/plain";
                 }
                 Address replyToAddr = new Address(options.ReplyTo);
 
@@ -95,7 +95,7 @@ namespace Org.Apache.Qpid.Messaging.Examples {
                     (0 == options.Timeout || stopwatch.Elapsed <= timespan);
                     count++) 
                 {
-                    if ("" != options.ReplyTo) message.SetReplyTo(replyToAddr);
+                    if ("" != options.ReplyTo) message.ReplyTo = replyToAddr;
                     string id = options.Id ;
                     if ("" == id) {
                         Guid g = Guid.NewGuid();
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
index 2ef7854..965b494 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver/csharp.map.callback.receiver.cs
@@ -93,14 +93,14 @@ namespace Org.Apache.Qpid.Messaging.Examples
         /// <param name="message">The Message</param>
         public static void ShowMessage(Message message)
         {
-            if ("amqp/map" == message.GetContentType())
+            if ("amqp/map" == message.ContentType)
             {
                 Console.WriteLine("Received a Dictionary");
                 Dictionary<string, object> content = new Dictionary<string, object>();
                 message.GetContent(content);
                 ShowDictionary(content, 0);
             }
-            else if ("amqp/list" == message.GetContentType())
+            else if ("amqp/list" == message.ContentType)
             {
                 Console.WriteLine("Received a List");
                 Collection<object> content = new Collection<object>();
@@ -148,7 +148,7 @@ namespace Org.Apache.Qpid.Messaging.Examples
             //
             // Acknowledge the receipt of all received messages.
             //
-            receiver.GetSession().Acknowledge();
+            receiver.Session.Acknowledge();
         }
 
 
@@ -241,7 +241,7 @@ namespace Org.Apache.Qpid.Messaging.Examples
             //
             // Establish a capacity
             //
-            receiver.SetCapacity(100);
+            receiver.Capacity = 100;
 
             //
             // Wait so many seconds for messages to arrive.
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/powershell.example.helloworld/powershell.example.helloworld.ps1 b/qpid/cpp/bindings/qpid/dotnet/examples/powershell.example.helloworld/powershell.example.helloworld.ps1
new file mode 100644
index 0000000..e8c21bc
--- /dev/null
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/powershell.example.helloworld/powershell.example.helloworld.ps1
@@ -0,0 +1,34 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+#
+# Script for 32-bit powershell
+#
+
+[Reflection.Assembly]::LoadFile('W:\cpp\src\Debug\org.apache.qpid.messagingd.dll')
+$conn = new-object Org.Apache.Qpid.Messaging.Connection("localhost:5672")
+$conn.Open()
+$sess = $conn.CreateSession()
+$rcvr = $sess.CreateReceiver("amq.topic")
+$sender = $sess.CreateSender("amq.topic")
+$msg1 = new-object Org.Apache.Qpid.Messaging.Message("Hello world!")
+$sender.Send($msg1)
+$dur = new-object Org.Apache.Qpid.Messaging.Duration(1000)
+$msg2 = $rcvr.Fetch($dur)
+$msg2.GetContent()
diff --git a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
index 96300ec..ccdc0d6 100644
--- a/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
+++ b/qpid/cpp/bindings/qpid/dotnet/examples/visualbasic.example.client/visualbasic.example.client.vb
@@ -48,7 +48,7 @@ Namespace Org.Apache.Qpid.Messaging.Examples
                     s(3) = "And the mome raths outgrabe."
 
                     Dim request As Message = New Message("")
-                    request.SetReplyTo(responseQueue)
+                    request.ReplyTo = responseQueue
 
                     Dim i As Integer
                     For i = 0 To s.Length - 1
diff --git a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
index 8df1ea6..38fd6dc 100644
--- a/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
+++ b/qpid/cpp/bindings/qpid/dotnet/org.apache.qpid.messaging.sln
@@ -60,6 +60,9 @@ EndProject
 Project("{F184B08F-C81C-45F6-A57F-5ABD9991F28F}") = "visualbasic.example.client", "examples\visualbasic.example.client\visualbasic.example.client.vbproj", "{CFEA696E-115B-4AD1-AB56-804E360EDD51}"
 EndProject
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Hello World", "Hello World", "{4408A2DA-ED2D-44AE-A465-0B6D75E1FF86}"
+	ProjectSection(SolutionItems) = preProject
+		examples\powershell.example.helloworld\powershell.example.helloworld.ps1 = examples\powershell.example.helloworld\powershell.example.helloworld.ps1
+	EndProjectSection
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "csharp.example.helloworld", "examples\csharp.example.helloworld\csharp.example.helloworld.csproj", "{8CC1C265-0507-44A3-9483-8FAF48513F4D}"
 EndProject
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
index f0bbe13..2da40e6 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.cpp
@@ -58,10 +58,10 @@ namespace Messaging {
                          System::String ^, System::Object ^> ^ options) :
         addressp(new ::qpid::messaging::Address())
     {
-        SetName(name);
-        SetSubject(subject);
-        SetOptions(options);
-        SetType("");
+        Name = name;
+        Subject = subject;
+        Options = options;
+        Type = "";
     }
 
 
@@ -72,10 +72,10 @@ namespace Messaging {
                      System::String ^ type) :
         addressp(new ::qpid::messaging::Address())
     {
-        SetName(name);
-        SetSubject(subject);
-        SetOptions(options);
-        SetType(type);
+        Name = name;
+        Subject = subject;
+        Options = options;
+        Type = type;
     }
 
 
@@ -112,71 +112,6 @@ namespace Messaging {
 
 
     //
-    // name
-    //
-    System::String ^ Address::GetName()
-    {
-        return gcnew System::String(addressp->getName().c_str());
-    }
-
-    void Address::SetName(System::String ^ name)
-    {
-        addressp->::qpid::messaging::Address::setName(QpidMarshal::ToNative(name));
-    }
-
-    //
-    // subject
-    //
-    System::String ^ Address::GetSubject()
-    {
-        return gcnew System::String(addressp->getSubject().c_str());
-    }
-
-    void Address::SetSubject(System::String ^ subject)
-    {
-        addressp->setSubject(QpidMarshal::ToNative(subject));
-    }
-
-    //
-    // options
-    //
-    System::Collections::Generic::Dictionary<
-        System::String ^, System::Object ^> ^ Address::GetOptions()
-    {
-        ::qpid::types::Variant::Map map;
-        System::Collections::Generic::Dictionary<
-            System::String ^, System::Object ^> ^ newMap = 
-            gcnew System::Collections::Generic::Dictionary<
-                  System::String ^, System::Object ^>;
-        map = addressp->getOptions();
-        TypeTranslator::NativeToManaged(map, newMap);
-        return newMap;
-    }
-
-
-    void Address::SetOptions(System::Collections::Generic::Dictionary<
-                        System::String ^, System::Object ^> ^ options)
-    {
-        ::qpid::types::Variant::Map map;
-        TypeTranslator::ManagedToNative(options, map);
-        addressp->setOptions(map);
-    }
-
-    //
-    // type
-    //
-    System::String ^ Address::GetType()
-    {
-        return gcnew System::String(addressp->getType().c_str());
-    }
-
-
-    void Address::SetType(System::String ^ type)
-    {
-        addressp->setName(QpidMarshal::ToNative(type));
-    }
-
-    //
     // ToString
     //
     System::String ^ Address::ToStr()
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Address.h b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
index 60e24da..9f940d6 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Address.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Address.h
@@ -27,6 +27,10 @@
 
 #include "qpid/messaging/Address.h"
 
+#include "QpidMarshal.h"
+#include "QpidTypeCheck.h"
+#include "TypeTranslator.h"
+
 namespace Org {
 namespace Apache {
 namespace Qpid {
@@ -73,20 +77,86 @@ namespace Messaging {
             ::qpid::messaging::Address * get () { return addressp; }
         }
 
-        System::String ^ GetName();
-        void SetName(System::String ^ name);
+        //
+        // name
+        //
+        property System::String ^ Name
+        {
+            System::String ^ get ()
+            {
+                return gcnew System::String(addressp->getName().c_str());
+            }
+
+            void set (System::String ^ name)
+            {
+                addressp->::qpid::messaging::Address::setName(QpidMarshal::ToNative(name));
+            }
+        }
+
+
+        //
+        // subject
+        //
+        property System::String ^ Subject
+        {
+            System::String ^ get ()
+            {
+                return gcnew System::String(addressp->getSubject().c_str());
+            }
+
+            void set (System::String ^ subject)
+            {
+                addressp->setSubject(QpidMarshal::ToNative(subject));
+            }
+        }
+
 
-        System::String ^ GetSubject();
-        void SetSubject(System::String ^ subject);
+        //
+        // options
+        //
+        property  System::Collections::Generic::Dictionary<
+            System::String ^, System::Object ^> ^ Options
+        {
+            System::Collections::Generic::Dictionary<
+                System::String ^, System::Object ^> ^ get ()
+            {
+                ::qpid::types::Variant::Map map;
+                System::Collections::Generic::Dictionary<
+                    System::String ^, System::Object ^> ^ newMap = 
+                    gcnew System::Collections::Generic::Dictionary<
+                          System::String ^, System::Object ^>;
+                map = addressp->getOptions();
+                TypeTranslator::NativeToManaged(map, newMap);
+                return newMap;
+            }
+
+
+            void set (System::Collections::Generic::Dictionary<
+                                System::String ^, System::Object ^> ^ options)
+            {
+                ::qpid::types::Variant::Map map;
+                TypeTranslator::ManagedToNative(options, map);
+                addressp->setOptions(map);
+            }
+        }
 
-        System::Collections::Generic::Dictionary<
-            System::String ^, System::Object ^> ^ GetOptions();
 
-        void SetOptions(System::Collections::Generic::Dictionary<
-                            System::String ^, System::Object ^> ^ options);
+        //
+        // type
+        //
+        property System::String ^ Type
+        {
+            System::String ^ get ()
+            {
+                return gcnew System::String(addressp->getType().c_str());
+            }
+
 
-        System::String ^ GetType();
-        void SetType(System::String ^ type);
+            void set (System::String ^ type)
+            {
+                addressp->setName(QpidMarshal::ToNative(type));
+            }
+        }
 
         System::String ^ ToStr();
     };
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
index 590cc5e..0e59c41 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.cpp
@@ -107,11 +107,6 @@ namespace Messaging {
         connectionp->open();
     }
 
-    System::Boolean Connection::IsOpen()
-    {
-        return connectionp->isOpen();
-    }
-
     void Connection::Close()
     {
         connectionp->close();
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
index e93e078..8e0f40f 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Connection.h
@@ -62,9 +62,16 @@ namespace Messaging {
         void SetOption(System::String ^ name, System::Object ^ value);
 
         void Open();
-        System::Boolean IsOpen();
         void Close();
 
+        property System::Boolean IsOpen
+        {
+            System::Boolean get ()
+            {
+                return connectionp->isOpen();
+            }
+        }
+
         // CreateTransactionalSession()
         Session ^ CreateTransactionalSession();
         Session ^ CreateTransactionalSession(System::String ^ name);
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
index 743afce..f620a09 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.cpp
@@ -158,190 +158,36 @@ namespace Messaging {
         }
     }
 
-
-    //
-    // ReplyTo
-    //
-    void Message::SetReplyTo(Address ^ address)
-    {
-        messagep->setReplyTo(*(address->NativeAddress));
-    }
-
-    Address ^ Message::GetReplyTo()
-    {
-        const ::qpid::messaging::Address & addrp =
-            messagep->::qpid::messaging::Message::getReplyTo();
-
-        return gcnew Address(const_cast<::qpid::messaging::Address *>(&addrp));
-    }
-
-
-    //
-    // Subject
-    //
-    void Message::SetSubject(System::String ^ subject)
-    {
-        messagep->setSubject(QpidMarshal::ToNative(subject));
-    }
-    
-    System::String ^ Message::GetSubject()
-    {
-        return gcnew String(messagep->getSubject().c_str());
-    }
-    
-
-    //
-    // ContentType
-    //
-    void Message::SetContentType(System::String ^ ct)
-    {
-        messagep->setContentType(QpidMarshal::ToNative(ct));
-    }
-    
-	System::String ^ Message::GetContentType()
-    {
-		return gcnew String(messagep->::qpid::messaging::Message::getContentType().c_str());
-    }
-    
-    
-    //
-    // MessageId
-    //
-    void Message::SetMessageId(System::String ^ messageId)
-    {
-        messagep->setMessageId(QpidMarshal::ToNative(messageId));
-    }
-    
-    System::String ^ Message::GetMessageId()
-    {
-        return gcnew String(messagep->getMessageId().c_str());
-    }
-    
-    
-    //
-    // UserId
-    //
-    void Message::SetUserId(System::String ^ uId)
-    {
-        messagep->setUserId(QpidMarshal::ToNative(uId));
-    }
-    
-    System::String ^ Message::GetUserId()
-    {
-        return gcnew String(messagep->getUserId().c_str());
-    }
-    
-    
-    //
-    // CorrelationId
-    //
-    void Message::SetCorrelationId(System::String ^ correlationId)
-    {
-        messagep->setCorrelationId(QpidMarshal::ToNative(correlationId));
-    }
-    
-    System::String ^ Message::GetCorrelationId()
-    {
-        return gcnew String(messagep->getCorrelationId().c_str());
-    }
-    
-
-    //
-    // Priority
-    //
-    void Message::SetPriority(unsigned char priority)
-    {
-        messagep->setPriority(priority);
-    }
-    
-    unsigned char Message::GetPriority()
-    {
-        return messagep->getPriority();
-    }
-    
-
-    //
-    // Ttl
-    //
-    void Message::SetTtl(Duration ^ ttl)
-    {
-        ::qpid::messaging::Duration dur(ttl->Milliseconds);
-
-        messagep->setTtl(dur);
-    }
-    
-    Duration ^ Message::GetTtl()
+	// Property
+    void Message::SetProperty(System::String ^ name, System::Object ^ value)
     {
-        Duration ^ dur = gcnew Duration(messagep->getTtl().getMilliseconds());
+        ::qpid::types::Variant entryValue;
+        TypeTranslator::ManagedToNativeObject(value, entryValue);
 
-        return dur;
+        messagep->getProperties()[QpidMarshal::ToNative(name)] = entryValue;
     }
 
-    void Message::SetDurable(bool durable)
-    {
-        messagep->setDurable(durable);
-    }
-    
-    bool Message::GetDurable()
+	// Content
+	void Message::SetContent(System::String ^ content)
     {
-        return messagep->getDurable();
+        messagep->setContent(QpidMarshal::ToNative(content));
     }
 
 
-    bool Message::GetRedelivered()
+    void Message::SetContent(cli::array<System::Byte> ^ bytes)
     {
-        return messagep->getRedelivered();
+		pin_ptr<unsigned char> pBytes = &bytes[0];
+		messagep->setContent((char *)pBytes, bytes->Length);
     }
 
-    void Message::SetRedelivered(bool redelivered)
-    {
-        messagep->setRedelivered(redelivered);
-    }
 
-	// Properties
-    System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ Message::GetProperties()
+    void Message::SetContent(cli::array<System::Byte> ^ bytes, int offset, int size)
     {
-        ::qpid::types::Variant::Map map;
-
-        map = messagep->getProperties();
-
-        System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ dict =
-            gcnew System::Collections::Generic::Dictionary<
-                      System::String^, System::Object^> ;
-
-        TypeTranslator::NativeToManaged(map, dict);
-
-        return dict;
-    }
-
-
-	void Message::SetProperty(System::String ^ name, System::Object ^ value)
-	{
-        ::qpid::types::Variant entryValue;
-        TypeTranslator::ManagedToNativeObject(value, entryValue);
-
-		messagep->getProperties()[QpidMarshal::ToNative(name)] = entryValue;
-	}
-
-
-	void Message::SetProperties(System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ properties)
-	{
-		for each (System::Collections::Generic::KeyValuePair
-			     <System::String^, System::Object^> kvp in properties)
-        {
-			SetProperty(kvp.Key, kvp.Value);
-		}
-	}
-
+        if ((offset + size) > bytes->Length)
+			throw gcnew QpidException("Message::SetContent from byte array slice: buffer length exceeded");
 
-	
-	// Content
-	void Message::SetContent(System::String ^ content)
-    {
-        messagep->setContent(QpidMarshal::ToNative(content));
+		pin_ptr<unsigned char> pBytes = &bytes[offset];
+		messagep->setContent((char *)pBytes, size);
     }
 
 
@@ -388,7 +234,7 @@ namespace Messaging {
     // On entry message size must not be zero and
 	// caller's byte array must be equal to message size.
     //
-    void Message::GetRaw(array<System::Byte> ^ arr)
+    void Message::GetContent(array<System::Byte> ^ arr)
     {
         System::UInt32 size = messagep->getContentSize();
      
@@ -404,12 +250,6 @@ namespace Messaging {
     }
 
 
-    System::UInt64 Message::GetContentSize()
-    {
-        return messagep->getContentSize();
-    }
-
-
 	System::String ^ Message::MapAsString(System::Collections::Generic::Dictionary<
 					           System::String^, System::Object^> ^ dict)
     {
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Message.h b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
index 99d0b86..d5b4beb 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Message.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Message.h
@@ -26,6 +26,11 @@
 
 #include "qpid/messaging/Message.h"
 
+#include "QpidMarshal.h"
+#include "Address.h"
+#include "Duration.h"
+#include "TypeTranslator.h"
+
 namespace Org {
 namespace Apache {
 namespace Qpid {
@@ -78,46 +83,227 @@ namespace Messaging {
             ::qpid::messaging::Message * get () { return messagep; }
         }
 
-        void SetReplyTo(Address ^ address);
-        Address ^ GetReplyTo();
+        //
+        // ReplyTo
+        //
+        property Address ^ ReplyTo 
+        {
+            void set (Address ^ address)
+            {
+                 messagep->setReplyTo(*(address->NativeAddress));
+            }
+
+            Address ^ get () 
+            {
+                const ::qpid::messaging::Address & addrp =
+                    messagep->::qpid::messaging::Message::getReplyTo();
+
+                return gcnew Address(const_cast<::qpid::messaging::Address *>(&addrp));
+            }
+        }
+
+        //
+        // Subject
+        //
+        property System::String ^ Subject
+        {
+            void set (System::String ^ subject)
+            {
+                messagep->setSubject(QpidMarshal::ToNative(subject));
+            }
+            
+            
+            System::String ^ get ()
+            {
+                return gcnew String(messagep->getSubject().c_str());
+            }
+        }
 
-        void SetSubject(System::String ^ subject);
-        System::String ^ GetSubject();
 
-        void SetContentType(System::String ^ ct);
-        System::String ^ GetContentType();
-        
-        void SetMessageId(System::String ^ messageId);
-        System::String ^ GetMessageId();
-        
-        void SetUserId(System::String ^ uId);
-        System::String ^ GetUserId();
+        //
+        // ContentType
+        //
+        property System::String ^ ContentType
+        {
+            void set (System::String ^ ct)
+            {
+                messagep->setContentType(QpidMarshal::ToNative(ct));
+            }
+            
+	        System::String ^ get ()
+            {
+		        return gcnew String(messagep->::qpid::messaging::Message::getContentType().c_str());
+            }
+        }
+    
+
+        //
+        // MessageId
+        //
+        property System::String ^ MessageId
+        {
+            void set (System::String ^ messageId)
+            {
+                messagep->setMessageId(QpidMarshal::ToNative(messageId));
+            }
+
+            System::String ^ get ()
+            {
+                return gcnew String(messagep->getMessageId().c_str());
+            }
+        }
+
         
-        void SetCorrelationId(System::String ^ correlationId);
-        System::String ^ GetCorrelationId();
+        //
+        // UserId
+        //
+        property System::String ^ UserId
+        {
+            void set (System::String ^ uId)
+            {
+                messagep->setUserId(QpidMarshal::ToNative(uId));
+            }
+            
+            System::String ^ get ()
+            {
+                return gcnew String(messagep->getUserId().c_str());
+            }
+        }
 
-        void SetPriority(unsigned char priority);
-        unsigned char GetPriority();
+            
+        //
+        // CorrelationId
+        //
+        property System::String ^ CorrelationId
+        {
+            void set (System::String ^ correlationId)
+            {
+                messagep->setCorrelationId(QpidMarshal::ToNative(correlationId));
+            }
+            
+            System::String ^ get ()
+            {
+                return gcnew String(messagep->getCorrelationId().c_str());
+            }
+        }
 
-        void SetTtl(Duration ^ ttl);
-        Duration ^ GetTtl();
 
-        void SetDurable(bool durable);
-        bool GetDurable();
+        //
+        // Priority
+        //
+        property unsigned char Priority
+        {
+            void set (unsigned char priority)
+            {
+                messagep->setPriority(priority);
+            }
+            
+            unsigned char get ()
+            {
+                return messagep->getPriority();
+            }
+        }   
+
+
+        //
+        // Ttl
+        //
+        property Duration ^ Ttl
+        {
+            void set (Duration ^ ttl)
+            {
+                ::qpid::messaging::Duration dur(ttl->Milliseconds);
+
+                messagep->setTtl(dur);
+            }
+            
+            Duration ^ get ()
+            {
+                Duration ^ dur = gcnew Duration(messagep->getTtl().getMilliseconds());
+
+                return dur;
+            }
+        }
+
+        //
+        // Durable
+        //
+        property bool Durable
+        {
+            void set (bool durable)
+            {
+                messagep->setDurable(durable);
+            }
+            
+            bool get ()
+            {
+                return messagep->getDurable();
+            }
+        }
+
+        //
+        // Redelivered
+        //
+        property bool Redelivered
+        {
+            bool get ()
+            {
+                return messagep->getRedelivered();
+            }
+
+            void set (bool redelivered)
+            {
+                messagep->setRedelivered(redelivered);
+            }
+        }
+
+        //
+        // Property
+        //
+        void Message::SetProperty(System::String ^ name, System::Object ^ value);
+
+        //
+        // Properties
+        //
+        property System::Collections::Generic::Dictionary<
+                    System::String^, System::Object^> ^ Properties
+        {
+            System::Collections::Generic::Dictionary<
+                    System::String^, System::Object^> ^ get ()
+            {
+                ::qpid::types::Variant::Map map;
 
-        bool GetRedelivered();
-        void SetRedelivered(bool redelivered);
+                map = messagep->getProperties();
 
-        System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ GetProperties();
+                System::Collections::Generic::Dictionary<
+                    System::String^, System::Object^> ^ dict =
+                    gcnew System::Collections::Generic::Dictionary<
+                              System::String^, System::Object^> ;
 
-		void SetProperty(System::String ^ name, System::Object ^ value);
+                TypeTranslator::NativeToManaged(map, dict);
+
+                return dict;
+            }
+
+
+	        void set (System::Collections::Generic::Dictionary<
+                    System::String^, System::Object^> ^ properties)
+	        {
+		        for each (System::Collections::Generic::KeyValuePair
+			             <System::String^, System::Object^> kvp in properties)
+                {
+			        SetProperty(kvp.Key, kvp.Value);
+		        }
+	        }
+        }
 
-		void SetProperties(System::Collections::Generic::Dictionary<
-            System::String^, System::Object^> ^ properties);
 
         void SetContent(System::String ^ content);
 
+        void SetContent(cli::array<System::Byte> ^ bytes);
+
+        void SetContent(cli::array<System::Byte> ^ bytes, int offset, int size);
+
         //TODO:: void setContent(Bytes{} bytes, offset, length);
 
         // get content as string
@@ -133,9 +319,19 @@ namespace Messaging {
                             System::Object^> ^);
 
         // get content as bytes
-        void GetRaw(cli::array<System::Byte> ^ arr);
+        void GetContent(cli::array<System::Byte> ^ arr);
+
+        //
+        // ContentSize
+        //
+        property System::UInt64 ContentSize
+        {
+            System::UInt64 get ()
+            {
+                return messagep->getContentSize();
+            }
+        }
 
-        System::UInt64 GetContentSize();
 
 		// A message has been returned to managed code through GetContent().
 		// Display the content of that System::Object as a string.
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
index 15f8572..96df8cc 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.cpp
@@ -44,7 +44,7 @@ namespace Messaging {
     /// </summary>
 
     Receiver::Receiver(::qpid::messaging::Receiver * r,
-                       Session ^ sessRef) :
+                       Org::Apache::Qpid::Messaging::Session ^ sessRef) :
         receiverp(r),
         parentSession(sessRef)
     {
@@ -227,38 +227,8 @@ namespace Messaging {
         return newMessage;
     }
 
-    void Receiver::SetCapacity(System::UInt32 capacity)
-    {
-        receiverp->setCapacity(capacity);
-    }
-
-    System::UInt32 Receiver::GetCapacity()
-    {
-        return receiverp->getCapacity();
-    }
-
-    System::UInt32 Receiver::GetAvailable()
-    {
-        return receiverp->getAvailable();
-    }
-
-    System::UInt32 Receiver::GetUnsettled()
-    {
-        return receiverp->getUnsettled();
-    }
-
     void Receiver::Close()
     {
         receiverp->close();
     }
-
-    System::String ^ Receiver::GetName()
-    {
-        return gcnew System::String(receiverp->getName().c_str());
-    }
-
-    Session ^ Receiver::GetSession()
-    {
-        return parentSession;
-    }
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
index 0dc2f61..436f3f2 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Receiver.h
@@ -88,12 +88,66 @@ namespace Messaging {
         Message ^ Fetch();
         Message ^ Fetch(Duration ^ durationp);
 
-        void SetCapacity(System::UInt32 capacity);
-        System::UInt32 GetCapacity();
-        System::UInt32 GetAvailable();
-        System::UInt32 GetUnsettled();
+        //
+        // Capacity
+        //
+        property System::UInt32 Capacity
+        {
+            void set (System::UInt32 capacity)
+            {
+                receiverp->setCapacity(capacity);
+            }
+
+            System::UInt32 get ()
+            {
+                return receiverp->getCapacity();
+            }
+        }
+
+        //
+        // Available
+        //
+        property System::UInt32 Available
+        {
+            System::UInt32 get ()
+            {
+                return receiverp->getAvailable();
+            }
+        }
+
+        //
+        // Unsettled
+        //
+        property System::UInt32 Unsettled
+        {
+            System::UInt32 get ()
+            {
+                return receiverp->getUnsettled();
+            }
+        }
+
         void Close();
-        System::String ^ GetName();
-        Session ^ GetSession();
+        
+        //
+        // Name
+        //
+        property System::String ^ Name
+        {
+            System::String ^ get ()
+            {
+                return gcnew System::String(receiverp->getName().c_str());
+            }
+        }
+
+        //
+        // Session
+        //
+        property Org::Apache::Qpid::Messaging::Session ^ Session
+        {
+            Org::Apache::Qpid::Messaging::Session ^ get ()
+            {
+                return parentSession;
+            }
+        }
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
index e0911b3..0d394f8 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.cpp
@@ -40,7 +40,7 @@ namespace Messaging {
     /// </summary>
 
     Sender::Sender(::qpid::messaging::Sender * s,
-                     Session ^ sessRef) :
+                     Org::Apache::Qpid::Messaging::Session ^ sessRef) :
         senderp(s),
         parentSession(sessRef)
     {
@@ -96,9 +96,4 @@ namespace Messaging {
     {
         senderp->close();
     }
-
-    Session ^ Sender::GetSession()
-    {
-        return parentSession;
-    }
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
index 705c7d5..de114ab 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Sender.h
@@ -95,6 +95,15 @@ namespace Messaging {
             }
         }
 
-        Session ^ GetSession();
+        //
+        // Session
+        //
+        property Org::Apache::Qpid::Messaging::Session ^ Session
+        {
+            Org::Apache::Qpid::Messaging::Session ^ get ()
+            {
+                return parentSession;
+            }
+        }
     };
 }}}}
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
index 04fbb61..d5f4584 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
@@ -46,7 +46,8 @@ namespace Messaging {
     /// </summary>
 
     // constructor
-    Session::Session(::qpid::messaging::Session * sp, Connection ^ connRef) :
+    Session::Session(::qpid::messaging::Session * sp, 
+                     Org::Apache::Qpid::Messaging::Connection ^ connRef) :
         sessionp(sp),
         parentConnectionp(connRef)
     {
@@ -444,11 +445,10 @@ namespace Messaging {
 
     Sender ^ Session::GetSender(System::String ^ name)
     {
-        ::qpid::messaging::Sender * sender = new ::qpid::messaging::Sender;
+        ::qpid::messaging::Sender sender = ::qpid::messaging::Sender(
+            sessionp->::qpid::messaging::Session::getSender(QpidMarshal::ToNative(name)) );
 
-        *sender = sessionp->::qpid::messaging::Session::getSender(QpidMarshal::ToNative(name));
-
-        Sender ^ newSender = gcnew Sender(sender, this);
+        Sender ^ newSender = gcnew Sender(&sender, this);
 
         return newSender;
     }
@@ -457,22 +457,16 @@ namespace Messaging {
 
     Receiver ^ Session::GetReceiver(System::String ^ name)
     {
-        ::qpid::messaging::Receiver * receiver = new ::qpid::messaging::Receiver;
-
-        *receiver = sessionp->::qpid::messaging::Session::getReceiver(QpidMarshal::ToNative(name));
+        ::qpid::messaging::Receiver receiver = ::qpid::messaging::Receiver(
+            sessionp->::qpid::messaging::Session::getReceiver(QpidMarshal::ToNative(name)) );
 
-        Receiver ^ newReceiver = gcnew Receiver(receiver, this);
+        Receiver ^ newReceiver = gcnew Receiver(&receiver, this);
 
         return newReceiver;
     }
 
 
 
-    Connection ^ Session::GetConnection()
-    {
-        return parentConnectionp;
-    }
-
     void Session::CheckError()
     {
         sessionp->checkError();
diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.h b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
index 4b84eec..a5affc6 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.h
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.h
@@ -110,7 +110,14 @@ namespace Messaging {
         Sender   ^ GetSender(System::String ^ name);
         Receiver ^ GetReceiver(System::String ^ name);
 
-        Connection ^ GetConnection();
+        property Org::Apache::Qpid::Messaging::Connection ^ Connection
+        {
+            Org::Apache::Qpid::Messaging::Connection ^ get ()
+            {
+                return parentConnectionp;
+            }
+        }
+
 
         property System::Boolean HasError
         {
diff --git a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
index 2e0e481..c1b3035 100644
--- a/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
+++ b/qpid/cpp/bindings/qpid/dotnet/test/messaging.test/messaging.test.cs
@@ -74,12 +74,12 @@ namespace Org.Apache.Qpid.Messaging
             //
 
             Message m2 = new Message("rarey");
-            UInt64 m2Size = m2.GetContentSize();
+            UInt64 m2Size = m2.ContentSize;
 
 
             byte[] myRaw = new byte [m2Size];
 
-            m2.GetRaw(myRaw);
+            m2.GetContent(myRaw);
             Console.WriteLine("Got raw array size {0}", m2Size);
             for (UInt64 i = 0; i < m2Size; i++)
                 Console.Write("{0} ", myRaw[i].ToString());
@@ -93,9 +93,9 @@ namespace Org.Apache.Qpid.Messaging
                 rawData[i] = i;
             Message m3 = new Message(rawData);
 
-            byte[] rawDataReadback = new byte[m3.GetContentSize()];
-            m3.GetRaw(rawDataReadback);
-            for (UInt64 i = 0; i < m3.GetContentSize(); i++)
+            byte[] rawDataReadback = new byte[m3.ContentSize];
+            m3.GetContent(rawDataReadback);
+            for (UInt64 i = 0; i < m3.ContentSize; i++)
                 Console.Write("{0} ", rawDataReadback[i].ToString());
             Console.WriteLine();
 
@@ -108,13 +108,24 @@ namespace Org.Apache.Qpid.Messaging
 
             Message m4 = new Message(rawData4, 246, 10);
 
-            byte[] rawDataReadback4 = new byte[m4.GetContentSize()];
-            m4.GetRaw(rawDataReadback4);
-            for (UInt64 i = 0; i < m4.GetContentSize(); i++)
+            byte[] rawDataReadback4 = new byte[m4.ContentSize];
+            m4.GetContent(rawDataReadback4);
+            for (UInt64 i = 0; i < m4.ContentSize; i++)
                 Console.Write("{0} ", rawDataReadback4[i].ToString());
             Console.WriteLine();
 
             //
+            // Set content from array slice
+            //
+            m4.SetContent(rawData4, 100, 5);
+
+            byte[] rawDataReadback4a = new byte[m4.ContentSize];
+            m4.GetContent(rawDataReadback4a);
+            for (UInt64 i = 0; i < m4.ContentSize; i++)
+                Console.Write("{0} ", rawDataReadback4a[i].ToString());
+            Console.WriteLine();
+
+            //
             // Guid factoids
             //
             Guid myGuid = new Guid("000102030405060708090a0b0c0d0e0f");
-- 
1.7.1.1

From 0d9a38bd4ec42aeaf7f05035483f8227f8b72cdd Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Fri, 25 Jun 2010 22:35:28 +0000
Subject: [PATCH 092/129] QPID-2589 - Patch from Chuck Rolke
 Re-do changes to Session.cpp.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958141 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/bindings/qpid/dotnet/src/Session.cpp |   80 +++++++++++++++++++++++--
 1 files changed, 74 insertions(+), 6 deletions(-)

diff --git a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
index d5f4584..bafc9b3 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
+++ b/qpid/cpp/bindings/qpid/dotnet/src/Session.cpp
@@ -445,10 +445,44 @@ namespace Messaging {
 
     Sender ^ Session::GetSender(System::String ^ name)
     {
-        ::qpid::messaging::Sender sender = ::qpid::messaging::Sender(
-            sessionp->::qpid::messaging::Session::getSender(QpidMarshal::ToNative(name)) );
+        System::Exception           ^ newException = nullptr;
+        ::qpid::messaging::Sender   * senderp      = NULL;
+        Sender                      ^ newSender    = nullptr;
 
-        Sender ^ newSender = gcnew Sender(&sender, this);
+        try
+        {
+            senderp = new ::qpid::messaging::Sender;
+
+            *senderp = sessionp->::qpid::messaging::Session::getSender(QpidMarshal::ToNative(name));
+
+            newSender = gcnew Sender(senderp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        finally 
+		{
+            if (newException != nullptr)
+			{
+				if (newSender != nullptr)
+				{
+					delete newSender;
+				}
+				else
+				{
+					if (senderp != NULL)
+					{
+						delete senderp;
+					}
+				}
+            }
+        }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
         return newSender;
     }
@@ -457,10 +491,44 @@ namespace Messaging {
 
     Receiver ^ Session::GetReceiver(System::String ^ name)
     {
-        ::qpid::messaging::Receiver receiver = ::qpid::messaging::Receiver(
-            sessionp->::qpid::messaging::Session::getReceiver(QpidMarshal::ToNative(name)) );
+        System::Exception           ^ newException = nullptr;
+        ::qpid::messaging::Receiver * receiverp    = NULL;
+        Receiver                    ^ newReceiver  = nullptr;
+
+        try
+        {
+            receiverp = new ::qpid::messaging::Receiver;
 
-        Receiver ^ newReceiver = gcnew Receiver(&receiver, this);
+            *receiverp = sessionp->::qpid::messaging::Session::getReceiver(QpidMarshal::ToNative(name));
+
+            newReceiver = gcnew Receiver(receiverp, this);
+        } 
+        catch (const ::qpid::types::Exception & error) 
+        {
+            String ^ errmsg = gcnew String(error.what());
+            newException    = gcnew QpidException(errmsg);
+        }
+        finally 
+		{
+            if (newException != nullptr)
+			{
+				if (newReceiver != nullptr)
+				{
+					delete newReceiver;
+				}
+				else
+				{
+					if (receiverp != NULL)
+					{
+						delete receiverp;
+					}
+				}
+            }
+        }
+        if (newException != nullptr) 
+		{
+	        throw newException;
+		}
 
         return newReceiver;
     }
-- 
1.7.1.1

From 500df302fb0bdad8eb1f0b3ad9253d379bb1c7e1 Mon Sep 17 00:00:00 2001
From: Andrew Stitcher <astitcher@apache.org>
Date: Mon, 28 Jun 2010 20:22:25 +0000
Subject: [PATCH 093/129] Bug 603085: Install and package Visual Studio debugging symbols (.pdb) files,
 in the windows sdk zip package.

A Modified version of a patch from Chuck Rolke

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@958703 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/bld-winsdk.ps1     |  278 ++++++++++++++++++++++---------------------
 qpid/cpp/src/CMakeLists.txt |   81 +++++++------
 2 files changed, 191 insertions(+), 168 deletions(-)

diff --git a/qpid/cpp/bld-winsdk.ps1 b/qpid/cpp/bld-winsdk.ps1
index 8618160..7aa6df8 100644
--- a/qpid/cpp/bld-winsdk.ps1
+++ b/qpid/cpp/bld-winsdk.ps1
@@ -1,133 +1,145 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-# This script requires cmake, and 7z to be already on the path devenv should be on the path as
-# a result of installing Visual Studio
-
-Set-PSDebug -strict
-$ErrorActionPreference='Stop'
-
-if ($args.length -lt 1) {
-  Write-Host 'Need to specify location of qpid src tree'
-  exit
-}
-
-$qpid_src=$args[0]
-$ver=$args[1]
-if ($ver -eq $null) {
-  $qpid_version_file="$qpid_src\QPID_VERSION.txt"
-
-  if ( !(Test-Path $qpid_version_file)) {
-    Write-Host "Path doesn't seem to be a qpid src tree (no QPID_VERSION.txt)"
-    exit
-  }
-  $ver=Get-Content $qpid_version_file
-}
-
-$randomness=[System.IO.Path]::GetRandomFileName()
-
-$qpid_cpp_src="$qpid_src\cpp"
-$install_dir="install_$randomness"
-$preserve_dir="preserve_$randomness"
-$zipfile="qpid-cpp-$ver.zip"
-
-# This assumes Visual Studio 2008
-cmake -G "Visual Studio 9 2008" "-DCMAKE_INSTALL_PREFIX=$install_dir" $qpid_cpp_src
-
-# Need to build doxygen api docs separately as nothing depends on them
-devenv qpid-cpp.sln /build "Release|Win32" /project docs-user-api
-
-# Build both debug and release so we can ship both sets of libs
-# (Do release after debug  so that the release executables overwrite the
-# debug executables)
-devenv qpid-cpp.sln /build "Debug|Win32" /project INSTALL
-devenv qpid-cpp.sln /build "Release|Win32" /project INSTALL
-
-# This would be kludgy if we have only one entry as the array declaration syntax
-# can't cope with just one nested array
-# Target must be a directory
-$move=(
-	('bin/*.lib','lib'),
-	('bin/boost/*.dll','bin')
-)
-
-$preserve=(
-	'include/qpid/agent',
-	'include/qpid/amqp_0_10',
-	'include/qpid/management',
-	'include/qpid/messaging',
-	'include/qpid/sys/IntegerTypes.h',
-	'include/qpid/sys/windows/IntegerTypes.h', 'include/qpid/sys/posix/IntegerTypes.h',
-	'include/qpid/types',
-	'include/qpid/CommonImportExport.h')
-$remove=(
-	'bin/qpidd.exe', 'bin/qpidbroker*.*',
-	'bin/qmfengine*.*', 'bin/qpidxarm*.*',
-	'bin/boost_regex*.*',
-	'bin/boost',
-	'conf',
-	'examples/direct',
-	'examples/failover',
-	'examples/fanout',
-	'examples/pub-sub',
-	'examples/qmf-console',
-	'examples/request-response',
-	'examples/tradedemo',
-	'examples/old-examples.sln',
-	'examples/README.*',
-	'examples/verify*',
-	'include',
-	'plugins')
-
-# Move some files around in the install tree
-foreach ($pattern in $move) {
-	$target = Join-Path $install_dir $pattern[1]
-	New-Item -force -type directory $target
-	Move-Item -force -path "$install_dir/$($pattern[0])" -destination "$install_dir/$($pattern[1])"
-}
-# Copy aside the files to preserve
-New-Item -path $preserve_dir -type directory
-foreach ($pattern in $preserve) {
-	$target = Join-Path $preserve_dir $pattern
-	$tparent = Split-Path -parent $target
-	New-Item -force -type directory $tparent
-	Move-Item -force -path "$install_dir/$pattern" -destination "$preserve_dir/$pattern"
-}
-# Remove everything to remove
-foreach ($pattern in $remove) {
-	Remove-Item -recurse "$install_dir/$pattern"
-}
-# Copy back the preserved things
-foreach ($pattern in $preserve) {
-	$target = Join-Path $install_dir $pattern
-	$tparent = Split-Path -parent $target
-	New-Item -force -type directory $tparent
-	Move-Item -force -path "$preserve_dir/$pattern" -destination "$install_dir/$pattern"
-}
-Remove-Item -recurse $preserve_dir
-
-# It would be very good to cut down on the shipped boost include files too, ideally by
-# starting with the qpid files and recursively noting all boost headers actually needed
-
-# Create a new zip
-if (Test-Path $zipfile) {Remove-Item $zipfile}
-&'7z' a $zipfile ".\$install_dir\*"
-
-# Remove temporary install area
-# Remove-Item -recurse $install_dir
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+# This script requires cmake, and 7z to be already on the path devenv should be on the path as
+# a result of installing Visual Studio
+
+Set-PSDebug -strict
+$ErrorActionPreference='Stop'
+
+if ($args.length -lt 1) {
+  Write-Host 'Need to specify location of qpid src tree'
+  exit
+}
+
+$qpid_src=$args[0]
+$ver=$args[1]
+if ($ver -eq $null) {
+  $qpid_version_file="$qpid_src\QPID_VERSION.txt"
+
+  if ( !(Test-Path $qpid_version_file)) {
+    Write-Host "Path doesn't seem to be a qpid src tree (no QPID_VERSION.txt)"
+    exit
+  }
+  $ver=Get-Content $qpid_version_file
+}
+
+$randomness=[System.IO.Path]::GetRandomFileName()
+
+$qpid_cpp_src="$qpid_src\cpp"
+$install_dir="install_$randomness"
+$preserve_dir="preserve_$randomness"
+$zipfile="qpid-cpp-$ver.zip"
+
+# This assumes Visual Studio 2008
+cmake -G "Visual Studio 9 2008" "-DCMAKE_INSTALL_PREFIX=$install_dir" $qpid_cpp_src
+
+# Need to build doxygen api docs separately as nothing depends on them
+devenv qpid-cpp.sln /build "Release|Win32" /project docs-user-api
+
+# Build both Debug and Release builds so we can ship both sets of libs:
+# Make RelWithDebInfo for debuggable release code.
+# (Do Release after Debug so that the release executables overwrite the
+# debug executables. Don't skip Debug as it creates some needed content.)
+devenv qpid-cpp.sln /build "Debug|Win32" /project INSTALL
+devenv qpid-cpp.sln /build "RelWithDebInfo|Win32" /project INSTALL
+
+# This would be kludgy if we have only one entry as the array declaration syntax
+# can't cope with just one nested array
+# Target must be a directory
+$move=(
+	('bin/*.lib','lib'),
+	('bin/boost/*.dll','bin')
+)
+
+$preserve=(
+	'include/qpid/agent',
+	'include/qpid/amqp_0_10',
+	'include/qpid/management',
+	'include/qpid/messaging',
+	'include/qpid/sys/IntegerTypes.h',
+	'include/qpid/sys/windows/IntegerTypes.h', 'include/qpid/sys/posix/IntegerTypes.h',
+	'include/qpid/types',
+	'include/qpid/CommonImportExport.h')
+$remove=(
+	'bin/qpidd.exe', 'bin/qpidbroker*.*',
+	'bin/*PDB/qpidd.exe', 'bin/*PDB/qpidbroker*.*',
+	'bin/qmfengine*.*', 'bin/qpidxarm*.*',
+	'bin/*PDB/qmfengine*.*', 'bin/*PDB/qpidxarm*.*',
+	'bin/boost_regex*.*',
+	'bin/boost',
+	'conf',
+	'examples/direct',
+	'examples/failover',
+	'examples/fanout',
+	'examples/pub-sub',
+	'examples/qmf-console',
+	'examples/request-response',
+	'examples/tradedemo',
+	'examples/old-examples.sln',
+	'examples/README.*',
+	'examples/verify*',
+	'include',
+	'plugins')
+
+# Move some files around in the install tree
+foreach ($pattern in $move) {
+	$target = Join-Path $install_dir $pattern[1]
+	New-Item -force -type directory $target
+	Move-Item -force -path "$install_dir/$($pattern[0])" -destination "$install_dir/$($pattern[1])"
+}
+
+# Copy aside the files to preserve
+New-Item -path $preserve_dir -type directory
+foreach ($pattern in $preserve) {
+	$target = Join-Path $preserve_dir $pattern
+	$tparent = Split-Path -parent $target
+	New-Item -force -type directory $tparent
+	Move-Item -force -path "$install_dir/$pattern" -destination "$preserve_dir/$pattern"
+}
+# Remove everything to remove
+foreach ($pattern in $remove) {
+	Remove-Item -recurse "$install_dir/$pattern"
+}
+# Copy back the preserved things
+foreach ($pattern in $preserve) {
+	$target = Join-Path $install_dir $pattern
+	$tparent = Split-Path -parent $target
+	New-Item -force -type directory $tparent
+	Move-Item -force -path "$preserve_dir/$pattern" -destination "$install_dir/$pattern"
+}
+Remove-Item -recurse $preserve_dir
+
+# Zip the /bin PDB files into two zip files.
+# we previously arranged that the Debug pdbs go in the DebugPDB subdirectory
+# and the Release pdbs go in the ReleasePDB subdirectory
+&'7z' a -mx9 ".\$install_dir\bin\symbols-debug.zip" ".\$install_dir\bin\DebugPDB\*.pdb"
+&'7z' a -mx9 ".\$install_dir\bin\symbols-release.zip" ".\$install_dir\bin\ReleasePDB\*.pdb"
+
+# It would be very good to cut down on the shipped boost include files too, ideally by
+# starting with the qpid files and recursively noting all boost headers actually needed
+
+
+# Create a new zip for the whole kit.
+# Exclude *.pdb so as not include the debug symbols twice
+if (Test-Path $zipfile) {Remove-Item $zipfile}
+&'7z' a $zipfile ".\$install_dir\*" -xr!*pdb
+
+# Remove temporary install area
+# Remove-Item -recurse $install_dir
diff --git a/qpid/cpp/src/CMakeLists.txt b/qpid/cpp/src/CMakeLists.txt
index 7083574..cf9161d 100644
--- a/qpid/cpp/src/CMakeLists.txt
+++ b/qpid/cpp/src/CMakeLists.txt
@@ -34,6 +34,37 @@ include(FindDoxygen)
 
 #set (CMAKE_VERBOSE_MAKEFILE ON)  # for debugging
 
+#
+# Set up installation of .pdb files if the compiler is Visual Studio
+#
+# Sample: install_pdb (qpidcommon ${QPID_COMPONENT_COMMON})
+#
+MACRO (install_pdb theLibrary theComponent)
+    if (MSVC)
+        get_target_property(library_dll ${theLibrary} LOCATION)
+        string(REPLACE .dll .pdb library_pdb ${library_dll})
+        string(REPLACE $(OutDir) \${CMAKE_INSTALL_CONFIG_NAME} library_pdb ${library_pdb})
+        string(REPLACE .pdb d.pdb libraryd_pdb ${library_pdb})
+        #message(STATUS "_pdb: ${library_pdb}, ${libraryd_pdb}")
+        install (PROGRAMS
+                ${library_pdb}
+                DESTINATION ${QPID_INSTALL_LIBDIR}/ReleasePDB
+                COMPONENT ${theComponent}
+				OPTIONAL
+                CONFIGURATIONS Release|MinSizeRel)
+        install (PROGRAMS
+                ${library_pdb}
+                DESTINATION ${QPID_INSTALL_LIBDIR}/ReleasePDB
+                COMPONENT ${theComponent}
+                CONFIGURATIONS RelWithDebInfo)
+        install (PROGRAMS
+                ${libraryd_pdb}
+                DESTINATION ${QPID_INSTALL_LIBDIR}/DebugPDB
+                COMPONENT ${theComponent}
+                CONFIGURATIONS Debug)
+    endif (MSVC)
+ENDMACRO (install_pdb)
+
 # check if we generate source as part of the build
 #   - rubygen generates the amqp spec and clustering
 #   - managementgen generates the broker management code
@@ -460,6 +491,10 @@ if (CMAKE_SYSTEM_NAME STREQUAL Windows)
     if (MSVC80)
       add_definitions(/D "_WIN32_WINNT=0x0501")
     endif (MSVC80)
+
+    # set the RelWithDebInfo compile/link switchs to equal Release
+    set (CMAKE_CXX_FLAGS_RELWITHDEBINFO "/MD /O2 /Ob2 /D NDEBUG")
+    set (CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO "/debug /INCREMENTAL:NO")
   endif (MSVC)
 
   set (qpidcommon_platform_SOURCES
@@ -544,7 +579,7 @@ else (CMAKE_SYSTEM_NAME STREQUAL Windows)
 
     ${qpid_poller_module}
   )
-  set (qpidcommon_platform_LIBS      
+  set (qpidcommon_platform_LIBS
     ${Boost_PROGRAM_OPTIONS_LIBRARY}
     ${Boost_FILESYSTEM_LIBRARY}
     uuid
@@ -646,19 +681,8 @@ set_target_properties (qpidcommon PROPERTIES
 install (TARGETS qpidcommon
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_COMMON})
+install_pdb (qpidcommon ${QPID_COMPONENT_COMMON})
 
-if (WIN32)
-    # Need the .pdb file, which isn't installed with the .dll/.lib
-    # Not built... if needed, add the build option then uncomment this.
-    #get_target_property(qpidcommon_dll qpidcommon LOCATION)
-    #string(REPLACE .dll .pdb qpidcommon_pdb ${qpidcommon_dll})
-    #string(REPLACE $(OutDir) \${CMAKE_INSTALL_CONFIG_NAME} qpidcommon_pdb ${qpidcommon_pdb})
-    #message(STATUS "_pdb: ${qpidcommon_pdb}")
-    #install (PROGRAMS
-    #         ${qpidcommon_pdb}
-    #         DESTINATION ${QPID_INSTALL_LIBDIR}
-    #         COMPONENT ${QPID_COMPONENT_CLIENT})
-endif (WIN32)
 
 set (qpidclient_SOURCES
      ${rgen_client_srcs}
@@ -709,6 +733,8 @@ install (DIRECTORY ../include/qpid
          DESTINATION ${QPID_INSTALL_INCLUDEDIR}
          COMPONENT ${QPID_COMPONENT_CLIENT_INCLUDE}
          PATTERN ".svn" EXCLUDE)
+install_pdb (qpidclient ${QPID_COMPONENT_CLIENT})
+
 
 set (qpidmessaging_SOURCES
      qpid/messaging/Address.cpp
@@ -756,6 +782,7 @@ set_target_properties (qpidmessaging PROPERTIES VERSION ${qpidc_version})
 install (TARGETS qpidmessaging
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_CLIENT})
+install_pdb (qpidmessaging ${QPID_COMPONENT_CLIENT})
 
 # Released source artifacts from Apache have the generated headers included in
 # the source tree, not the binary tree. So don't attempt to grab them when
@@ -766,17 +793,6 @@ if (NOT QPID_GENERATED_HEADERS_IN_SOURCE)
            COMPONENT ${QPID_COMPONENT_CLIENT_INCLUDE})
 endif (NOT QPID_GENERATED_HEADERS_IN_SOURCE)
 
-if (WIN32)
-    # Need the .pdb file, which isn't installed with the .dll/.lib
-    #get_target_property(qpidclient_dll qpidclient LOCATION)
-    #string(REPLACE .dll .pdb qpidclient_pdb ${qpidclient_dll})
-    #string(REPLACE $(OutDir) \${CMAKE_INSTALL_CONFIG_NAME} qpidclient_pdb ${qpidclient_pdb})
-    #message(STATUS "_pdb: ${qpidclient_pdb}")
-    #install (PROGRAMS
-    #         ${qpidclient_pdb}
-    #         DESTINATION ${QPID_INSTALL_LIBDIR}
-    #         COMPONENT ${QPID_COMPONENT_CLIENT})
-endif (WIN32)
 
 if (WIN32)
     set(AMQP_WCF_DIR ${qpid-cpp_SOURCE_DIR}/../wcf)
@@ -787,6 +803,7 @@ if (WIN32)
         install (TARGETS qpidxarm
                  DESTINATION ${QPID_INSTALL_LIBDIR}
                  COMPONENT ${QPID_COMPONENT_CLIENT})
+        install_pdb (qpidxarm ${QPID_COMPONENT_CLIENT})
     endif (EXISTS ${DTC_PLUGIN_SOURCE})
 endif (WIN32)
 
@@ -867,6 +884,8 @@ endif (MSVC)
 install (TARGETS qpidbroker
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_BROKER})
+install_pdb (qpidbroker ${QPID_COMPONENT_BROKER})
+
 
 set (qpidd_SOURCES
      ${qpidd_platform_SOURCES}
@@ -905,6 +924,7 @@ set_target_properties (qmf PROPERTIES
 install (TARGETS qmf OPTIONAL
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_QMF})
+install_pdb (qmf ${QPID_COMPONENT_QMF})
 
 set (qmfengine_SOURCES
      qmf/engine/Agent.cpp
@@ -944,6 +964,7 @@ set_target_properties (qmfengine PROPERTIES
 install (TARGETS qmfengine OPTIONAL
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_QMF})
+install_pdb (qmfengine ${QPID_COMPONENT_QMF})
 
 # QMF console library
 #module_hdr += \
@@ -993,17 +1014,7 @@ set_target_properties (qmfconsole PROPERTIES
 install (TARGETS qmfconsole
          DESTINATION ${QPID_INSTALL_LIBDIR}
          COMPONENT ${QPID_COMPONENT_QMF})
-if (WIN32)
-    # Need the .pdb file, which isn't installed with the .dll/.lib
-    #get_target_property(qmfconsole_dll qmfconsole LOCATION)
-    #string(REPLACE .dll .pdb qmfconsole_pdb ${qmfconsole_dll})
-    #string(REPLACE $(OutDir) \${CMAKE_INSTALL_CONFIG_NAME} qmfconsole_pdb ${qmfconsole_pdb})
-    #message(STATUS "_pdb: ${qmfconsole_pdb}")
-    #install (PROGRAMS
-    #         ${qmfconsole_pdb}
-    #         DESTINATION ${QPID_INSTALL_LIBDIR}
-    #         COMPONENT ${QPID_COMPONENT_QMF})
-endif (WIN32)
+install_pdb (qmfconsole ${QPID_COMPONENT_QMF})
 
 # A queue event listener plugin that creates messages on a replication
 # queue corresponding to enqueue and dequeue events:
-- 
1.7.1.1

From 62d79016f13c729abccba7a84d1dbb33ec94d9d5 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Wed, 30 Jun 2010 12:44:58 +0000
Subject: [PATCH 094/129] BZ-608807 fixed concurrent close

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@959289 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/endpoints.py       |  123 ++++++++++++++++--------
 qpid/python/qpid/messaging/exceptions.py      |    9 ++
 qpid/python/qpid/tests/messaging/endpoints.py |   72 ++++++++++++++-
 3 files changed, 162 insertions(+), 42 deletions(-)

diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index 62423ca..f7afc66 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -44,7 +44,14 @@ log = getLogger("qpid.messaging")
 
 static = staticmethod
 
-class Connection:
+class Endpoint:
+
+  def _ecwait(self, predicate, timeout=None):
+    result = self._ewait(lambda: self.closed or predicate(), timeout)
+    self.check_closed()
+    return result
+
+class Connection(Endpoint):
 
   """
   A Connection manages a group of L{Sessions<Session>} and connects
@@ -186,6 +193,11 @@ class Connection:
     self.check_error()
     return result
 
+  def check_closed(self):
+    if self.closed:
+      self._condition.gc()
+      raise ConnectionClosed()
+
   @synchronized
   def session(self, name=None, transactional=False):
     """
@@ -215,7 +227,7 @@ class Connection:
 
   @synchronized
   def _remove_session(self, ssn):
-    del self.sessions[ssn.name]
+    self.sessions.pop(ssn.name, 0)
 
   @synchronized
   def open(self):
@@ -239,9 +251,10 @@ class Connection:
     """
     Attach to the remote endpoint.
     """
-    self._connected = True
-    self._driver.start()
-    self._wakeup()
+    if not self._connected:
+      self._connected = True
+      self._driver.start()
+      self._wakeup()
     self._ewait(lambda: self._transport_connected and not self._unlinked())
 
   def _unlinked(self):
@@ -255,13 +268,18 @@ class Connection:
     """
     Detach from the remote endpoint.
     """
-    self._connected = False
-    self._wakeup()
+    if self._connected:
+      self._connected = False
+      self._wakeup()
+      cleanup = True
+    else:
+      cleanup = False
     try:
       if not self._wait(lambda: not self._transport_connected, timeout=timeout):
         raise Timeout("detach timed out")
     finally:
-      self._driver.stop()
+      if cleanup:
+        self._driver.stop()
       self._condition.gc()
 
   @synchronized
@@ -283,7 +301,7 @@ class Connection:
       self.detach(timeout=timeout)
       self._open = False
 
-class Session:
+class Session(Endpoint):
 
   """
   Sessions provide a linear context for sending and receiving
@@ -532,6 +550,10 @@ class Session:
     self.check_error()
     return result
 
+  def check_closed(self):
+    if self.closed:
+      raise SessionClosed()
+
   @synchronized
   def sender(self, target, **options):
     """
@@ -588,26 +610,27 @@ class Session:
         result += 1
     return result
 
-  def _peek(self, predicate):
+  def _peek(self, receiver):
     for msg in self.incoming:
-      if predicate(msg):
+      if msg._receiver == receiver:
         return msg
 
-  def _pop(self, predicate):
+  def _pop(self, receiver):
     i = 0
     while i < len(self.incoming):
       msg = self.incoming[i]
-      if predicate(msg):
+      if msg._receiver == receiver:
         del self.incoming[i]
         return msg
       else:
         i += 1
 
   @synchronized
-  def _get(self, predicate, timeout=None):
-    if self._ewait(lambda: ((self._peek(predicate) is not None) or self.closing),
+  def _get(self, receiver, timeout=None):
+    if self._ewait(lambda: ((self._peek(receiver) is not None) or
+                            self.closing or receiver.closed),
                    timeout):
-      msg = self._pop(predicate)
+      msg = self._pop(receiver)
       if msg is not None:
         msg._receiver.returned += 1
         self.unacked.append(msg)
@@ -617,7 +640,7 @@ class Session:
 
   @synchronized
   def next_receiver(self, timeout=None):
-    if self._ewait(lambda: self.incoming, timeout):
+    if self._ecwait(lambda: self.incoming, timeout):
       return self.incoming[0]._receiver
     else:
       raise Empty
@@ -644,14 +667,14 @@ class Session:
           # XXX: this is currently a SendError, maybe it should be a SessionError?
           raise InsufficientCapacity("ack_capacity = %s" % self.ack_capacity)
         self._wakeup()
-        self._ewait(lambda: len(self.acked) < self.ack_capacity)
+        self._ecwait(lambda: len(self.acked) < self.ack_capacity)
       m._disposition = disposition
       self.unacked.remove(m)
       self.acked.append(m)
 
     self._wakeup()
     if sync:
-      self._ewait(lambda: not [m for m in messages if m in self.acked])
+      self._ecwait(lambda: not [m for m in messages if m in self.acked])
 
   @synchronized
   def commit(self):
@@ -663,7 +686,7 @@ class Session:
       raise NontransactionalSession()
     self.committing = True
     self._wakeup()
-    self._ewait(lambda: not self.committing)
+    self._ecwait(lambda: not self.committing)
     if self.aborted:
       raise TransactionAborted()
     assert self.committed
@@ -678,7 +701,7 @@ class Session:
       raise NontransactionalSession()
     self.aborting = True
     self._wakeup()
-    self._ewait(lambda: not self.aborting)
+    self._ecwait(lambda: not self.aborting)
     assert self.aborted
 
   @synchronized
@@ -701,8 +724,10 @@ class Session:
     for link in self.receivers + self.senders:
       link.close(timeout=timeout)
 
-    self.closing = True
-    self._wakeup()
+    if not self.closing:
+      self.closing = True
+      self._wakeup()
+
     try:
       if not self._ewait(lambda: self.closed, timeout=timeout):
         raise Timeout("session close timed out")
@@ -715,7 +740,7 @@ def _mangle(addr):
   else:
     return addr
 
-class Sender:
+class Sender(Endpoint):
 
   """
   Sends outgoing messages.
@@ -758,6 +783,10 @@ class Sender:
     self.check_error()
     return result
 
+  def check_closed(self):
+    if self.closed:
+      raise LinkClosed()
+
   @synchronized
   def unsettled(self):
     """
@@ -799,7 +828,7 @@ class Sender:
     if not self.session.connection._connected or self.session.closing:
       raise Detached()
 
-    self._ewait(lambda: self.linked)
+    self._ecwait(lambda: self.linked)
 
     if isinstance(object, Message):
       message = object
@@ -812,7 +841,7 @@ class Sender:
     if self.capacity is not UNLIMITED:
       if self.capacity <= 0:
         raise InsufficientCapacity("capacity = %s" % self.capacity)
-      if not self._ewait(self.available, timeout=timeout):
+      if not self._ecwait(self.available, timeout=timeout):
         raise InsufficientCapacity("capacity = %s" % self.capacity)
 
     # XXX: what if we send the same message to multiple senders?
@@ -849,15 +878,20 @@ class Sender:
     if self.acked < self.queued:
       self.sync(timeout=timeout)
 
-    self.closing = True
-    self._wakeup()
+    if not self.closing:
+      self.closing = True
+      self._wakeup()
+
     try:
       if not self.session._ewait(lambda: self.closed, timeout=timeout):
         raise Timeout("sender close timed out")
     finally:
-      self.session.senders.remove(self)
+      try:
+        self.session.senders.remove(self)
+      except ValueError:
+        pass
 
-class Receiver(object):
+class Receiver(Endpoint, object):
 
   """
   Receives incoming messages from a remote source. Messages may be
@@ -923,6 +957,10 @@ class Receiver(object):
     self.check_error()
     return result
 
+  def check_closed(self):
+    if self.closed:
+      raise LinkClosed()
+
   @synchronized
   def unsettled(self):
     """
@@ -941,9 +979,6 @@ class Receiver(object):
     """
     return self.received - self.returned
 
-  def _pred(self, msg):
-    return msg._receiver == self
-
   @synchronized
   def fetch(self, timeout=None):
     """
@@ -955,20 +990,21 @@ class Receiver(object):
     @param timeout: the time to wait for a message to be available
     """
 
-    self._ewait(lambda: self.linked)
+    self._ecwait(lambda: self.linked)
 
     if self._capacity == 0:
       self.granted = self.returned + 1
       self._wakeup()
-    self._ewait(lambda: self.impending >= self.granted)
-    msg = self.session._get(self._pred, timeout=timeout)
+    self._ecwait(lambda: self.impending >= self.granted)
+    msg = self.session._get(self, timeout=timeout)
     if msg is None:
+      self.check_closed()
       self.draining = True
       self._wakeup()
-      self._ewait(lambda: not self.draining)
+      self._ecwait(lambda: not self.draining)
       self._grant()
       self._wakeup()
-      msg = self.session._get(self._pred, timeout=0)
+      msg = self.session._get(self, timeout=0)
       if msg is None:
         raise Empty()
     elif self._capacity not in (0, UNLIMITED.value):
@@ -988,12 +1024,17 @@ class Receiver(object):
     """
     Close the receiver.
     """
-    self.closing = True
-    self._wakeup()
+    if not self.closing:
+      self.closing = True
+      self._wakeup()
+
     try:
       if not self.session._ewait(lambda: self.closed, timeout=timeout):
         raise Timeout("receiver close timed out")
     finally:
-      self.session.receivers.remove(self)
+      try:
+        self.session.receivers.remove(self)
+      except ValueError:
+        pass
 
 __all__ = ["Connection", "Session", "Sender", "Receiver"]
diff --git a/qpid/python/qpid/messaging/exceptions.py b/qpid/python/qpid/messaging/exceptions.py
index f640b6b..27bc5af 100644
--- a/qpid/python/qpid/messaging/exceptions.py
+++ b/qpid/python/qpid/messaging/exceptions.py
@@ -60,6 +60,9 @@ class VersionError(ConnectError):
 class AuthenticationFailure(ConnectError):
   pass
 
+class ConnectionClosed(ConnectionError):
+  pass
+
 ## Session Errors
 
 class SessionError(MessagingError):
@@ -91,6 +94,9 @@ class UnauthorizedAccess(SessionError):
 class ServerError(SessionError):
   pass
 
+class SessionClosed(SessionError):
+  pass
+
 ## Link Errors
 
 class LinkError(MessagingError):
@@ -117,6 +123,9 @@ class AssertionFailed(ResolutionError):
 class NotFound(ResolutionError):
   pass
 
+class LinkClosed(LinkError):
+  pass
+
 ## Sender Errors
 
 class SenderError(LinkError):
diff --git a/qpid/python/qpid/tests/messaging/endpoints.py b/qpid/python/qpid/tests/messaging/endpoints.py
index c01f16e..52ca9f3 100644
--- a/qpid/python/qpid/tests/messaging/endpoints.py
+++ b/qpid/python/qpid/tests/messaging/endpoints.py
@@ -20,12 +20,13 @@
 # setup, usage, teardown, errors(sync), errors(async), stress, soak,
 # boundary-conditions, config
 
-import errno, os, socket, time
+import errno, os, socket, sys, time
 from qpid import compat
 from qpid.compat import set
 from qpid.messaging import *
 from qpid.messaging.transports import TRANSPORTS
 from qpid.tests.messaging import Base
+from threading import Thread
 
 class SetupTests(Base):
 
@@ -212,6 +213,32 @@ class ConnectionTests(Base):
     self.conn.close()
     assert not self.conn.attached()
 
+  def testSimultaneousClose(self):
+    ssns = [self.conn.session() for i in range(3)]
+    for s in ssns:
+      for i in range(3):
+        s.receiver("amq.topic")
+        s.sender("amq.topic")
+
+    def closer(errors):
+      try:
+        self.conn.close()
+      except:
+        _, e, _ = sys.exc_info()
+        errors.append(compat.format_exc(e))
+
+    t1_errors = []
+    t2_errors = []
+    t1 = Thread(target=lambda: closer(t1_errors))
+    t2 = Thread(target=lambda: closer(t2_errors))
+    t1.start()
+    t2.start()
+    t1.join(self.delay())
+    t2.join(self.delay())
+
+    assert not t1_errors, t1_errors[0]
+    assert not t2_errors, t2_errors[0]
+
 class hangable:
 
   def __init__(self, host, port):
@@ -655,6 +682,49 @@ class ReceiverTests(Base):
     assert msg.content == three
     self.ssn.acknowledge()
 
+  def fetchFromClosedTest(self, entry):
+    entry.close()
+    try:
+      msg = self.rcv.fetch(0)
+      assert False, "unexpected result: %s" % msg
+    except Empty, e:
+      assert False, "unexpected exception: %s" % e
+    except LinkClosed, e:
+      pass
+
+  def testFetchFromClosedReceiver(self):
+    self.fetchFromClosedTest(self.rcv)
+
+  def testFetchFromClosedSession(self):
+    self.fetchFromClosedTest(self.ssn)
+
+  def testFetchFromClosedConnection(self):
+    self.fetchFromClosedTest(self.conn)
+
+  def fetchFromConcurrentCloseTest(self, entry):
+    def closer():
+      time.sleep(self.delay())
+      entry.close()
+    t = Thread(target=closer)
+    t.start()
+    try:
+      msg = self.rcv.fetch()
+      assert False, "unexpected result: %s" % msg
+    except Empty, e:
+      assert False, "unexpected exception: %s" % e
+    except LinkClosed, e:
+      pass
+    t.join()
+
+  def testFetchFromConcurrentCloseReceiver(self):
+    self.fetchFromConcurrentCloseTest(self.rcv)
+
+  def testFetchFromConcurrentCloseSession(self):
+    self.fetchFromConcurrentCloseTest(self.ssn)
+
+  def testFetchFromConcurrentCloseConnection(self):
+    self.fetchFromConcurrentCloseTest(self.conn)
+
   def testCapacityIncrease(self):
     content = self.send("testCapacityIncrease")
     self.sleep()
-- 
1.7.1.1

From d31918432748c8e6f3596548796fb45bf778b20e Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Wed, 30 Jun 2010 14:25:03 +0000
Subject: [PATCH 095/129] BZ-609258 added accessor for auth_username

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@959326 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py    |    1 +
 qpid/python/qpid/messaging/endpoints.py |    1 +
 qpid/python/qpid/sasl.py                |    6 ++++++
 3 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index a732a60..2175715 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -674,6 +674,7 @@ class Engine:
     self._sasl_encode = True
 
   def do_connection_open_ok(self, open_ok):
+    self.connection.auth_username = self._sasl.auth_username()
     self._connected = True
     self._sasl_decode = True
     self.connection._transport_connected = True
diff --git a/qpid/python/qpid/messaging/endpoints.py b/qpid/python/qpid/messaging/endpoints.py
index f7afc66..f989d6c 100644
--- a/qpid/python/qpid/messaging/endpoints.py
+++ b/qpid/python/qpid/messaging/endpoints.py
@@ -137,6 +137,7 @@ class Connection(Endpoint):
     self.heartbeat = options.get("heartbeat")
     self.username = default(url.user, options.get("username", None))
     self.password = default(url.password, options.get("password", None))
+    self.auth_username = None
 
     self.sasl_mechanisms = options.get("sasl_mechanisms")
     self.sasl_service = options.get("sasl_service", "qpidd")
diff --git a/qpid/python/qpid/sasl.py b/qpid/python/qpid/sasl.py
index 6b00dda..6645903 100644
--- a/qpid/python/qpid/sasl.py
+++ b/qpid/python/qpid/sasl.py
@@ -65,6 +65,9 @@ class WrapperClient:
     else:
       raise SASLError(self._cli.getError())
 
+  def auth_username(self):
+    return self._cli.getUserId()
+
 class PlainClient:
 
   def __init__(self):
@@ -92,6 +95,9 @@ class PlainClient:
   def decode(self, bytes):
     return bytes
 
+  def auth_username(self):
+    return self.attrs.get("username")
+
 try:
   from saslwrapper import Client as _Client
   Client = WrapperClient
-- 
1.7.1.1

From 5c3a50f97f327161fd5bd991c8ef4a8b6aece62a Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Wed, 30 Jun 2010 14:36:43 +0000
Subject: [PATCH 096/129] BZ-609258 fixed auth username for sasl

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@959333 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/sasl.py |    6 +++++-
 1 files changed, 5 insertions(+), 1 deletions(-)

diff --git a/qpid/python/qpid/sasl.py b/qpid/python/qpid/sasl.py
index 6645903..d4c15bd 100644
--- a/qpid/python/qpid/sasl.py
+++ b/qpid/python/qpid/sasl.py
@@ -66,7 +66,11 @@ class WrapperClient:
       raise SASLError(self._cli.getError())
 
   def auth_username(self):
-    return self._cli.getUserId()
+    status, result = self._cli.getUserId()
+    if status:
+      return result
+    else:
+      raise SASLError(self._cli.getError())
 
 class PlainClient:
 
-- 
1.7.1.1

From d8dc61cf1ba154f8ff373313d4416421b6649d33 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Wed, 30 Jun 2010 19:54:00 +0000
Subject: [PATCH 097/129] Bug 588766  - Create separate library for messaging API and implementation

QPID-2708: Create a separate qpidtypes library for the types namespace.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@959419 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit d991ec04ca246220148a1efff7eb6995d80cd676)
---
 qpid/cpp/include/qpid/types/Exception.h    |    8 +-
 qpid/cpp/include/qpid/types/ImportExport.h |   33 ++++++
 qpid/cpp/include/qpid/types/Uuid.h         |   58 +++++-----
 qpid/cpp/include/qpid/types/Variant.h      |  168 ++++++++++++++--------------
 qpid/cpp/src/CMakeLists.txt                |   34 +++++-
 qpid/cpp/src/Makefile.am                   |   20 ++--
 qpid/cpp/src/qpid/sys/windows/uuid.h       |   16 ++--
 7 files changed, 197 insertions(+), 140 deletions(-)
 create mode 100644 qpid/cpp/include/qpid/types/ImportExport.h

diff --git a/qpid/cpp/include/qpid/types/Exception.h b/qpid/cpp/include/qpid/types/Exception.h
index a8b7d12..d061a7d 100644
--- a/qpid/cpp/include/qpid/types/Exception.h
+++ b/qpid/cpp/include/qpid/types/Exception.h
@@ -23,7 +23,7 @@
  */
 
 #include <string>
-#include "qpid/CommonImportExport.h"
+#include "qpid/types/ImportExport.h"
 
 namespace qpid {
 namespace types {
@@ -31,9 +31,9 @@ namespace types {
 class Exception : public std::exception
 {
   public:
-    QPID_COMMON_EXTERN explicit Exception(const std::string& message=std::string()) throw();
-    QPID_COMMON_EXTERN virtual ~Exception() throw();
-    QPID_COMMON_EXTERN virtual const char* what() const throw();
+    QPID_TYPES_EXTERN explicit Exception(const std::string& message=std::string()) throw();
+    QPID_TYPES_EXTERN virtual ~Exception() throw();
+    QPID_TYPES_EXTERN virtual const char* what() const throw();
 
   private:
     const std::string message;
diff --git a/qpid/cpp/include/qpid/types/ImportExport.h b/qpid/cpp/include/qpid/types/ImportExport.h
new file mode 100644
index 0000000..bb10575
--- /dev/null
+++ b/qpid/cpp/include/qpid/types/ImportExport.h
@@ -0,0 +1,33 @@
+#ifndef QPID_TYPES_IMPORTEXPORT_H
+#define QPID_TYPES_IMPORTEXPORT_H
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#if defined(WIN32) && !defined(QPID_DECLARE_STATIC)
+#if defined(TYPES_EXPORT) || defined (qpidtypes_EXPORTS)
+#define QPID_TYPES_EXTERN __declspec(dllexport)
+#else
+#define QPID_TYPES_EXTERN __declspec(dllimport)
+#endif
+#else
+#define QPID_TYPES_EXTERN
+#endif
+
+#endif  /*!QPID_TYPES_IMPORTEXPORT_H*/
diff --git a/qpid/cpp/include/qpid/types/Uuid.h b/qpid/cpp/include/qpid/types/Uuid.h
index 41042a0..467a895 100644
--- a/qpid/cpp/include/qpid/types/Uuid.h
+++ b/qpid/cpp/include/qpid/types/Uuid.h
@@ -22,7 +22,7 @@
  *
  */
 
-#include "qpid/CommonImportExport.h"
+#include "qpid/types/ImportExport.h"
 #include <iosfwd>
 #include <string>
 
@@ -37,57 +37,57 @@ class Uuid
      * If unique is true, this will generate a new unique uuid, if not
      * it will construct a null uuid.
      */
-    QPID_COMMON_EXTERN Uuid(bool unique=false);
-    QPID_COMMON_EXTERN Uuid(const Uuid&);
-    QPID_COMMON_EXTERN Uuid& operator=(const Uuid&);
+    QPID_TYPES_EXTERN Uuid(bool unique=false);
+    QPID_TYPES_EXTERN Uuid(const Uuid&);
+    QPID_TYPES_EXTERN Uuid& operator=(const Uuid&);
     /** Copy the UUID from data16, which must point to a 16-byte UUID */
-    QPID_COMMON_EXTERN Uuid(const unsigned char* data16);
+    QPID_TYPES_EXTERN Uuid(const unsigned char* data16);
 
     /** Set to a new unique identifier. */
-    QPID_COMMON_EXTERN void generate();
+    QPID_TYPES_EXTERN void generate();
 
     /** Set to all zeros. */
-    QPID_COMMON_EXTERN void clear();
+    QPID_TYPES_EXTERN void clear();
 
     /** Test for null (all zeros). */
-    QPID_COMMON_EXTERN bool isNull() const;
-    QPID_COMMON_EXTERN operator bool() const;
-    QPID_COMMON_EXTERN bool operator!() const;
+    QPID_TYPES_EXTERN bool isNull() const;
+    QPID_TYPES_EXTERN operator bool() const;
+    QPID_TYPES_EXTERN bool operator!() const;
 
     /** String value in format 1b4e28ba-2fa1-11d2-883f-b9a761bde3fb. */
-    QPID_COMMON_EXTERN std::string str() const;
+    QPID_TYPES_EXTERN std::string str() const;
 
-    QPID_COMMON_EXTERN size_t size() const;
-    QPID_COMMON_EXTERN const unsigned char* data() const;
+    QPID_TYPES_EXTERN size_t size() const;
+    QPID_TYPES_EXTERN const unsigned char* data() const;
 
-    friend QPID_COMMON_EXTERN bool operator==(const Uuid&, const Uuid&);
-    friend QPID_COMMON_EXTERN bool operator!=(const Uuid&, const Uuid&);
-    friend QPID_COMMON_EXTERN bool operator<(const Uuid&, const Uuid&);
-    friend QPID_COMMON_EXTERN bool operator>(const Uuid&, const Uuid&);
-    friend QPID_COMMON_EXTERN bool operator<=(const Uuid&, const Uuid&);
-    friend QPID_COMMON_EXTERN bool operator>=(const Uuid&, const Uuid&);
-    friend QPID_COMMON_EXTERN std::ostream& operator<<(std::ostream&, Uuid);
-    friend QPID_COMMON_EXTERN std::istream& operator>>(std::istream&, Uuid&);
+    friend QPID_TYPES_EXTERN bool operator==(const Uuid&, const Uuid&);
+    friend QPID_TYPES_EXTERN bool operator!=(const Uuid&, const Uuid&);
+    friend QPID_TYPES_EXTERN bool operator<(const Uuid&, const Uuid&);
+    friend QPID_TYPES_EXTERN bool operator>(const Uuid&, const Uuid&);
+    friend QPID_TYPES_EXTERN bool operator<=(const Uuid&, const Uuid&);
+    friend QPID_TYPES_EXTERN bool operator>=(const Uuid&, const Uuid&);
+    friend QPID_TYPES_EXTERN std::ostream& operator<<(std::ostream&, Uuid);
+    friend QPID_TYPES_EXTERN std::istream& operator>>(std::istream&, Uuid&);
 
   private:
     unsigned char bytes[16];
 };
 
 /** Returns true if the uuids are equal, false otherwise. **/
-QPID_COMMON_EXTERN bool operator==(const Uuid&, const Uuid&);
+QPID_TYPES_EXTERN bool operator==(const Uuid&, const Uuid&);
 /** Returns true if the uuids are NOT equal, false if they are. **/
-QPID_COMMON_EXTERN bool operator!=(const Uuid&, const Uuid&);
+QPID_TYPES_EXTERN bool operator!=(const Uuid&, const Uuid&);
 
-QPID_COMMON_EXTERN bool operator<(const Uuid&, const Uuid&);
-QPID_COMMON_EXTERN bool operator>(const Uuid&, const Uuid&);
-QPID_COMMON_EXTERN bool operator<=(const Uuid&, const Uuid&);
-QPID_COMMON_EXTERN bool operator>=(const Uuid&, const Uuid&);
+QPID_TYPES_EXTERN bool operator<(const Uuid&, const Uuid&);
+QPID_TYPES_EXTERN bool operator>(const Uuid&, const Uuid&);
+QPID_TYPES_EXTERN bool operator<=(const Uuid&, const Uuid&);
+QPID_TYPES_EXTERN bool operator>=(const Uuid&, const Uuid&);
 
 /** Print in format 1b4e28ba-2fa1-11d2-883f-b9a761bde3fb. */
-QPID_COMMON_EXTERN std::ostream& operator<<(std::ostream&, Uuid);
+QPID_TYPES_EXTERN std::ostream& operator<<(std::ostream&, Uuid);
 
 /** Read from format 1b4e28ba-2fa1-11d2-883f-b9a761bde3fb. */
-QPID_COMMON_EXTERN std::istream& operator>>(std::istream&, Uuid&);
+QPID_TYPES_EXTERN std::istream& operator>>(std::istream&, Uuid&);
 
 }} // namespace qpid::types
 
diff --git a/qpid/cpp/include/qpid/types/Variant.h b/qpid/cpp/include/qpid/types/Variant.h
index 059550b..7b43422 100644
--- a/qpid/cpp/include/qpid/types/Variant.h
+++ b/qpid/cpp/include/qpid/types/Variant.h
@@ -28,7 +28,7 @@
 #include "Uuid.h"
 #include "qpid/types/Exception.h"
 #include "qpid/sys/IntegerTypes.h"
-#include "qpid/CommonImportExport.h"
+#include "qpid/types/ImportExport.h"
 
 namespace qpid {
 namespace types {
@@ -71,101 +71,101 @@ class Variant
     typedef std::map<std::string, Variant> Map;
     typedef std::list<Variant> List;
 
-    QPID_COMMON_EXTERN Variant();
-    QPID_COMMON_EXTERN Variant(bool);
-    QPID_COMMON_EXTERN Variant(uint8_t);
-    QPID_COMMON_EXTERN Variant(uint16_t);
-    QPID_COMMON_EXTERN Variant(uint32_t);
-    QPID_COMMON_EXTERN Variant(uint64_t);
-    QPID_COMMON_EXTERN Variant(int8_t);
-    QPID_COMMON_EXTERN Variant(int16_t);
-    QPID_COMMON_EXTERN Variant(int32_t);
-    QPID_COMMON_EXTERN Variant(int64_t);
-    QPID_COMMON_EXTERN Variant(float);
-    QPID_COMMON_EXTERN Variant(double);
-    QPID_COMMON_EXTERN Variant(const std::string&);
-    QPID_COMMON_EXTERN Variant(const char*);
-    QPID_COMMON_EXTERN Variant(const Map&);
-    QPID_COMMON_EXTERN Variant(const List&);
-    QPID_COMMON_EXTERN Variant(const Variant&);
-    QPID_COMMON_EXTERN Variant(const Uuid&);
-
-    QPID_COMMON_EXTERN ~Variant();
-
-    QPID_COMMON_EXTERN VariantType getType() const;
-    QPID_COMMON_EXTERN bool isVoid() const;
+    QPID_TYPES_EXTERN Variant();
+    QPID_TYPES_EXTERN Variant(bool);
+    QPID_TYPES_EXTERN Variant(uint8_t);
+    QPID_TYPES_EXTERN Variant(uint16_t);
+    QPID_TYPES_EXTERN Variant(uint32_t);
+    QPID_TYPES_EXTERN Variant(uint64_t);
+    QPID_TYPES_EXTERN Variant(int8_t);
+    QPID_TYPES_EXTERN Variant(int16_t);
+    QPID_TYPES_EXTERN Variant(int32_t);
+    QPID_TYPES_EXTERN Variant(int64_t);
+    QPID_TYPES_EXTERN Variant(float);
+    QPID_TYPES_EXTERN Variant(double);
+    QPID_TYPES_EXTERN Variant(const std::string&);
+    QPID_TYPES_EXTERN Variant(const char*);
+    QPID_TYPES_EXTERN Variant(const Map&);
+    QPID_TYPES_EXTERN Variant(const List&);
+    QPID_TYPES_EXTERN Variant(const Variant&);
+    QPID_TYPES_EXTERN Variant(const Uuid&);
+
+    QPID_TYPES_EXTERN ~Variant();
+
+    QPID_TYPES_EXTERN VariantType getType() const;
+    QPID_TYPES_EXTERN bool isVoid() const;
     
-    QPID_COMMON_EXTERN Variant& operator=(bool);
-    QPID_COMMON_EXTERN Variant& operator=(uint8_t);
-    QPID_COMMON_EXTERN Variant& operator=(uint16_t);
-    QPID_COMMON_EXTERN Variant& operator=(uint32_t);
-    QPID_COMMON_EXTERN Variant& operator=(uint64_t);
-    QPID_COMMON_EXTERN Variant& operator=(int8_t);
-    QPID_COMMON_EXTERN Variant& operator=(int16_t);
-    QPID_COMMON_EXTERN Variant& operator=(int32_t);
-    QPID_COMMON_EXTERN Variant& operator=(int64_t);
-    QPID_COMMON_EXTERN Variant& operator=(float);
-    QPID_COMMON_EXTERN Variant& operator=(double);
-    QPID_COMMON_EXTERN Variant& operator=(const std::string&);
-    QPID_COMMON_EXTERN Variant& operator=(const char*);
-    QPID_COMMON_EXTERN Variant& operator=(const Map&);
-    QPID_COMMON_EXTERN Variant& operator=(const List&);
-    QPID_COMMON_EXTERN Variant& operator=(const Variant&);
-    QPID_COMMON_EXTERN Variant& operator=(const Uuid&);
-
-    QPID_COMMON_EXTERN bool asBool() const;
-    QPID_COMMON_EXTERN uint8_t asUint8() const;
-    QPID_COMMON_EXTERN uint16_t asUint16() const;
-    QPID_COMMON_EXTERN uint32_t asUint32() const;
-    QPID_COMMON_EXTERN uint64_t asUint64() const;
-    QPID_COMMON_EXTERN int8_t asInt8() const;
-    QPID_COMMON_EXTERN int16_t asInt16() const;
-    QPID_COMMON_EXTERN int32_t asInt32() const;
-    QPID_COMMON_EXTERN int64_t asInt64() const;
-    QPID_COMMON_EXTERN float asFloat() const;
-    QPID_COMMON_EXTERN double asDouble() const;
-    QPID_COMMON_EXTERN std::string asString() const;
-    QPID_COMMON_EXTERN Uuid asUuid() const;
-
-    QPID_COMMON_EXTERN operator bool() const;
-    QPID_COMMON_EXTERN operator uint8_t() const;
-    QPID_COMMON_EXTERN operator uint16_t() const;
-    QPID_COMMON_EXTERN operator uint32_t() const;
-    QPID_COMMON_EXTERN operator uint64_t() const;
-    QPID_COMMON_EXTERN operator int8_t() const;
-    QPID_COMMON_EXTERN operator int16_t() const;
-    QPID_COMMON_EXTERN operator int32_t() const;
-    QPID_COMMON_EXTERN operator int64_t() const;
-    QPID_COMMON_EXTERN operator float() const;
-    QPID_COMMON_EXTERN operator double() const;
-    QPID_COMMON_EXTERN operator std::string() const;
-    QPID_COMMON_EXTERN operator Uuid() const;
-
-    QPID_COMMON_EXTERN const Map& asMap() const;
-    QPID_COMMON_EXTERN Map& asMap();
-    QPID_COMMON_EXTERN const List& asList() const;
-    QPID_COMMON_EXTERN List& asList();
+    QPID_TYPES_EXTERN Variant& operator=(bool);
+    QPID_TYPES_EXTERN Variant& operator=(uint8_t);
+    QPID_TYPES_EXTERN Variant& operator=(uint16_t);
+    QPID_TYPES_EXTERN Variant& operator=(uint32_t);
+    QPID_TYPES_EXTERN Variant& operator=(uint64_t);
+    QPID_TYPES_EXTERN Variant& operator=(int8_t);
+    QPID_TYPES_EXTERN Variant& operator=(int16_t);
+    QPID_TYPES_EXTERN Variant& operator=(int32_t);
+    QPID_TYPES_EXTERN Variant& operator=(int64_t);
+    QPID_TYPES_EXTERN Variant& operator=(float);
+    QPID_TYPES_EXTERN Variant& operator=(double);
+    QPID_TYPES_EXTERN Variant& operator=(const std::string&);
+    QPID_TYPES_EXTERN Variant& operator=(const char*);
+    QPID_TYPES_EXTERN Variant& operator=(const Map&);
+    QPID_TYPES_EXTERN Variant& operator=(const List&);
+    QPID_TYPES_EXTERN Variant& operator=(const Variant&);
+    QPID_TYPES_EXTERN Variant& operator=(const Uuid&);
+
+    QPID_TYPES_EXTERN bool asBool() const;
+    QPID_TYPES_EXTERN uint8_t asUint8() const;
+    QPID_TYPES_EXTERN uint16_t asUint16() const;
+    QPID_TYPES_EXTERN uint32_t asUint32() const;
+    QPID_TYPES_EXTERN uint64_t asUint64() const;
+    QPID_TYPES_EXTERN int8_t asInt8() const;
+    QPID_TYPES_EXTERN int16_t asInt16() const;
+    QPID_TYPES_EXTERN int32_t asInt32() const;
+    QPID_TYPES_EXTERN int64_t asInt64() const;
+    QPID_TYPES_EXTERN float asFloat() const;
+    QPID_TYPES_EXTERN double asDouble() const;
+    QPID_TYPES_EXTERN std::string asString() const;
+    QPID_TYPES_EXTERN Uuid asUuid() const;
+
+    QPID_TYPES_EXTERN operator bool() const;
+    QPID_TYPES_EXTERN operator uint8_t() const;
+    QPID_TYPES_EXTERN operator uint16_t() const;
+    QPID_TYPES_EXTERN operator uint32_t() const;
+    QPID_TYPES_EXTERN operator uint64_t() const;
+    QPID_TYPES_EXTERN operator int8_t() const;
+    QPID_TYPES_EXTERN operator int16_t() const;
+    QPID_TYPES_EXTERN operator int32_t() const;
+    QPID_TYPES_EXTERN operator int64_t() const;
+    QPID_TYPES_EXTERN operator float() const;
+    QPID_TYPES_EXTERN operator double() const;
+    QPID_TYPES_EXTERN operator std::string() const;
+    QPID_TYPES_EXTERN operator Uuid() const;
+
+    QPID_TYPES_EXTERN const Map& asMap() const;
+    QPID_TYPES_EXTERN Map& asMap();
+    QPID_TYPES_EXTERN const List& asList() const;
+    QPID_TYPES_EXTERN List& asList();
     /**
      * Unlike asString(), getString() will not do any conversions and
      * will throw InvalidConversion if the type is not STRING.
      */
-    QPID_COMMON_EXTERN const std::string& getString() const;
-    QPID_COMMON_EXTERN std::string& getString();
+    QPID_TYPES_EXTERN const std::string& getString() const;
+    QPID_TYPES_EXTERN std::string& getString();
 
-    QPID_COMMON_EXTERN void setEncoding(const std::string&);
-    QPID_COMMON_EXTERN const std::string& getEncoding() const;
+    QPID_TYPES_EXTERN void setEncoding(const std::string&);
+    QPID_TYPES_EXTERN const std::string& getEncoding() const;
 
-    QPID_COMMON_EXTERN bool isEqualTo(const Variant& a) const;
+    QPID_TYPES_EXTERN bool isEqualTo(const Variant& a) const;
 
-    QPID_COMMON_EXTERN void reset();    
+    QPID_TYPES_EXTERN void reset();
   private:
     VariantImpl* impl;
 };
 
-QPID_COMMON_EXTERN std::ostream& operator<<(std::ostream& out, const Variant& value);
-QPID_COMMON_EXTERN std::ostream& operator<<(std::ostream& out, const Variant::Map& map);
-QPID_COMMON_EXTERN std::ostream& operator<<(std::ostream& out, const Variant::List& list);
-QPID_COMMON_EXTERN bool operator==(const Variant& a, const Variant& b);
+QPID_TYPES_EXTERN std::ostream& operator<<(std::ostream& out, const Variant& value);
+QPID_TYPES_EXTERN std::ostream& operator<<(std::ostream& out, const Variant::Map& map);
+QPID_TYPES_EXTERN std::ostream& operator<<(std::ostream& out, const Variant::List& list);
+QPID_TYPES_EXTERN bool operator==(const Variant& a, const Variant& b);
 }} // namespace qpid::types
 
 #endif  /*!QPID_TYPES_VARIANT_H*/
diff --git a/qpid/cpp/src/CMakeLists.txt b/qpid/cpp/src/CMakeLists.txt
index cf9161d..5ac5373 100644
--- a/qpid/cpp/src/CMakeLists.txt
+++ b/qpid/cpp/src/CMakeLists.txt
@@ -497,6 +497,13 @@ if (CMAKE_SYSTEM_NAME STREQUAL Windows)
     set (CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO "/debug /INCREMENTAL:NO")
   endif (MSVC)
 
+  set (qpidtypes_platform_SOURCES
+    qpid/sys/windows/uuid.cpp
+  )
+  set (qpidtypes_platform_LIBS
+    rpcrt4
+  )
+
   set (qpidcommon_platform_SOURCES
     qpid/log/windows/SinkOptions.cpp
     qpid/sys/windows/AsynchIO.cpp
@@ -513,11 +520,11 @@ if (CMAKE_SYSTEM_NAME STREQUAL Windows)
     qpid/sys/windows/SystemInfo.cpp
     qpid/sys/windows/Thread.cpp
     qpid/sys/windows/Time.cpp
-    qpid/sys/windows/uuid.cpp
     ${sslcommon_windows_SOURCES}
   )
+
   set (qpidcommon_platform_LIBS
-    ${windows_ssl_libs} rpcrt4 ws2_32
+    ${windows_ssl_libs} ws2_32
   )
   set (qpidbroker_platform_SOURCES
     qpid/broker/windows/BrokerDefaults.cpp
@@ -560,6 +567,11 @@ else (CMAKE_SYSTEM_NAME STREQUAL Windows)
     )
   endif (CMAKE_SYSTEM_NAME STREQUAL SunOS)
 
+  set (qpidtypes_platform_SOURCES)
+  set (qpidtypes_platform_LIBS
+    uuid
+  )
+
   set (qpidcommon_platform_SOURCES
     qpid/sys/posix/AsynchIO.cpp
     qpid/sys/posix/Fork.cpp
@@ -582,7 +594,6 @@ else (CMAKE_SYSTEM_NAME STREQUAL Windows)
   set (qpidcommon_platform_LIBS
     ${Boost_PROGRAM_OPTIONS_LIBRARY}
     ${Boost_FILESYSTEM_LIBRARY}
-    uuid
     ${CMAKE_DL_LIBS}
   )
 
@@ -663,9 +674,6 @@ set (qpidcommon_SOURCES
      qpid/sys/Runnable.cpp
      qpid/sys/Shlib.cpp
      qpid/sys/Timer.cpp
-     qpid/types/Exception.cpp
-     qpid/types/Uuid.cpp
-     qpid/types/Variant.cpp
      qpid/amqp_0_10/Codecs.cpp
 )
 
@@ -673,7 +681,7 @@ add_library (qpidcommon SHARED ${qpidcommon_SOURCES})
 if (CLOCK_GETTIME_IN_RT)
   set (qpidcommon_platform_LIBS ${qpidcommon_platform_LIBS} rt)
 endif (CLOCK_GETTIME_IN_RT)
-target_link_libraries (qpidcommon
+target_link_libraries (qpidcommon qpidtypes
                        ${qpidcommon_platform_LIBS}
                        ${qpidcommon_sasl_lib})
 set_target_properties (qpidcommon PROPERTIES
@@ -683,6 +691,18 @@ install (TARGETS qpidcommon
          COMPONENT ${QPID_COMPONENT_COMMON})
 install_pdb (qpidcommon ${QPID_COMPONENT_COMMON})
 
+set(qpidtypes_SOURCES
+  qpid/types/Exception.cpp
+  qpid/types/Uuid.cpp
+  qpid/types/Variant.cpp
+  ${qpidtypes_platform_SOURCES}
+)
+add_library(qpidtypes SHARED ${qpidtypes_SOURCES})
+target_link_libraries(qpidtypes ${qpidtypes_platform_LIBS})
+set_target_properties (qpidtypes PROPERTIES VERSION ${qpidc_version})
+install(TARGETS qpidtypes
+  DESTINATION ${QPID_INSTALL_LIBDIR}
+  COMPONENT ${QPID_COMPONENT_COMMON})
 
 set (qpidclient_SOURCES
      ${rgen_client_srcs}
diff --git a/qpid/cpp/src/Makefile.am b/qpid/cpp/src/Makefile.am
index 27a60e4..6340bf2 100644
--- a/qpid/cpp/src/Makefile.am
+++ b/qpid/cpp/src/Makefile.am
@@ -185,7 +185,7 @@ libqpidcommon_la_SOURCES += $(poller) $(systeminfo)
 posix_broker_src = \
   qpid/broker/posix/BrokerDefaults.cpp
 
-lib_LTLIBRARIES = libqpidcommon.la libqpidbroker.la libqpidclient.la libqpidmessaging.la
+lib_LTLIBRARIES = libqpidcommon.la libqpidbroker.la libqpidclient.la libqpidmessaging.la libqpidtypes.la
 
 # Definitions for client and daemon plugins
 PLUGINLDFLAGS=-no-undefined -module -avoid-version
@@ -309,6 +309,7 @@ EXTRA_DIST +=\
   qpid/store
 
 libqpidcommon_la_LIBADD = \
+  libqpidtypes.la \
   -lboost_program_options \
   -lboost_filesystem \
   -luuid \
@@ -477,10 +478,7 @@ libqpidcommon_la_SOURCES +=			\
   qpid/sys/Waitable.h				\
   qpid/sys/alloca.h				\
   qpid/sys/uuid.h				\
-  qpid/amqp_0_10/Codecs.cpp			\
-  qpid/types/Exception.cpp			\
-  qpid/types/Uuid.cpp				\
-  qpid/types/Variant.cpp
+  qpid/amqp_0_10/Codecs.cpp
 
 if HAVE_SASL
 libqpidcommon_la_SOURCES += qpid/sys/cyrus/CyrusSecurityLayer.h
@@ -491,8 +489,7 @@ endif
 QPIDCOMMON_VERSION_INFO = 2:0:0
 libqpidcommon_la_LDFLAGS=-version-info $(QPIDCOMMON_VERSION_INFO)
 
-libqpidbroker_la_LIBADD = libqpidcommon.la -luuid
-
+libqpidbroker_la_LIBADD = libqpidcommon.la
 libqpidbroker_la_SOURCES = \
   $(mgen_broker_cpp) \
   $(posix_broker_src) \
@@ -714,8 +711,15 @@ libqpidclient_la_SOURCES =			\
 QPIDCLIENT_VERSION_INFO  = 2:0:0
 libqpidclient_la_LDFLAGS = -version-info $(QPIDCLIENT_VERSION_INFO)
 
-libqpidmessaging_la_LIBADD = libqpidclient.la
+libqpidtypes_la_libadd=-luuid
+libqpidtypes_la_SOURCES=			\
+  qpid/types/Exception.cpp			\
+  qpid/types/Uuid.cpp				\
+  qpid/types/Variant.cpp
+QPIDTYPES_VERSION_INFO  = 1:0:0
+libqpidtypes_la_LDFLAGS = -version-info $(QPIDTYPES_VERSION_INFO)
 
+libqpidmessaging_la_LIBADD = libqpidclient.la libqpidtypes.la
 libqpidmessaging_la_SOURCES =			\
   qpid/messaging/Address.cpp			\
   qpid/messaging/AddressParser.h		\
diff --git a/qpid/cpp/src/qpid/sys/windows/uuid.h b/qpid/cpp/src/qpid/sys/windows/uuid.h
index 9c32814..8ab132e 100644
--- a/qpid/cpp/src/qpid/sys/windows/uuid.h
+++ b/qpid/cpp/src/qpid/sys/windows/uuid.h
@@ -22,18 +22,18 @@
  *
  */
 
-#include "qpid/CommonImportExport.h"
+#include "qpid/types/ImportExport.h"
 #include <qpid/sys/IntegerTypes.h>
 
 namespace qpid { namespace sys { const size_t UuidSize = 16; }}
 typedef uint8_t uuid_t[qpid::sys::UuidSize];
 
-QPID_COMMON_EXTERN void uuid_clear (uuid_t uu);
-QPID_COMMON_EXTERN void uuid_copy (uuid_t dst, const uuid_t src);
-QPID_COMMON_EXTERN void uuid_generate (uuid_t out);
-QPID_COMMON_EXTERN int  uuid_is_null (const uuid_t uu);          // Returns 1 if null, else 0
-QPID_COMMON_EXTERN int  uuid_parse (const char *in, uuid_t uu);  // Returns 0 on success, else -1
-QPID_COMMON_EXTERN void uuid_unparse (const uuid_t uu, char *out);
-QPID_COMMON_EXTERN int  uuid_compare (const uuid_t a, const uuid_t b);
+QPID_TYPES_EXTERN void uuid_clear (uuid_t uu);
+QPID_TYPES_EXTERN void uuid_copy (uuid_t dst, const uuid_t src);
+QPID_TYPES_EXTERN void uuid_generate (uuid_t out);
+QPID_TYPES_EXTERN int  uuid_is_null (const uuid_t uu);          // Returns 1 if null, else 0
+QPID_TYPES_EXTERN int  uuid_parse (const char *in, uuid_t uu);  // Returns 0 on success, else -1
+QPID_TYPES_EXTERN void uuid_unparse (const uuid_t uu, char *out);
+QPID_TYPES_EXTERN int  uuid_compare (const uuid_t a, const uuid_t b);
 
 #endif  /*!_sys_windows_uuid_h*/
-- 
1.7.1.1

From e3645c7205e726a7215aa00a96d12b3abe4d052a Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 30 Jun 2010 21:55:17 +0000
Subject: [PATCH 099/129] Bug 609801 - Fixed - Address option for exclusive subscribe is incorrect

QPID-664: corrected option name for setting subscribe options on a queue

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@959451 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 0787688bfce0afdfba92b3143fffae9bf652bf1d)
---
 .../src/qpid/client/amqp0_10/AddressResolution.cpp |    4 ++--
 qpid/cpp/src/tests/MessagingSessionTests.cpp       |   13 +++++++++++++
 2 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/amqp0_10/AddressResolution.cpp b/qpid/cpp/src/qpid/client/amqp0_10/AddressResolution.cpp
index b819906..f1295a3 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/AddressResolution.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/AddressResolution.cpp
@@ -452,8 +452,8 @@ QueueSource::QueueSource(const Address& address) :
     //extract subscription arguments from address options (nb: setting
     //of accept-mode/acquire-mode/destination controlled though other
     //options)
-    exclusive = Opt(address)/NODE/LINK/X_SUBSCRIBE/EXCLUSIVE;
-    (Opt(address)/NODE/LINK/X_SUBSCRIBE/ARGUMENTS).collect(options);
+    exclusive = Opt(address)/LINK/X_SUBSCRIBE/EXCLUSIVE;
+    (Opt(address)/LINK/X_SUBSCRIBE/ARGUMENTS).collect(options);
 }
 
 void QueueSource::subscribe(qpid::client::AsyncSession& session, const std::string& destination)
diff --git a/qpid/cpp/src/tests/MessagingSessionTests.cpp b/qpid/cpp/src/tests/MessagingSessionTests.cpp
index 6fee123..c22cb4b 100644
--- a/qpid/cpp/src/tests/MessagingSessionTests.cpp
+++ b/qpid/cpp/src/tests/MessagingSessionTests.cpp
@@ -756,6 +756,19 @@ QPID_AUTO_TEST_CASE(testSendSpecialProperties)
     BOOST_CHECK_EQUAL(in.getMessageProperties().getMessageId().str(), out.getMessageId());
 }
 
+QPID_AUTO_TEST_CASE(testExclusiveSubscriber)
+{
+    QueueFixture fix;
+    std::string address = (boost::format("%1%; { link: { x-subscribe : { exclusive:true } } }") % fix.queue).str();
+    Receiver receiver = fix.session.createReceiver(address);
+    ScopedSuppressLogging sl;
+    try {
+        fix.session.createReceiver(address);
+        fix.session.sync();
+        BOOST_FAIL("Expected exception.");
+    } catch (const MessagingException& e) {}
+}
+
 
 QPID_AUTO_TEST_SUITE_END()
 
-- 
1.7.1.1

From 8d55e9d8981053f2bf584ae446dfe404293f11c9 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Wed, 30 Jun 2010 22:22:50 +0000
Subject: [PATCH 100/129] Bug 609803 - Fixed - Need to expose authenticated username via messaging API

QPID-664: expose authenticated username for connection

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@959461 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 62a1dcddbc7f087df2d8cd1ee19f8f4b5c50bc3d)
---
 qpid/cpp/include/qpid/messaging/Connection.h       |    1 +
 .../src/qpid/client/amqp0_10/ConnectionImpl.cpp    |    4 ++++
 qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h |    1 +
 qpid/cpp/src/qpid/messaging/Connection.cpp         |    5 ++++-
 qpid/cpp/src/qpid/messaging/ConnectionImpl.h       |    1 +
 qpid/cpp/src/tests/MessagingSessionTests.cpp       |    6 ++++++
 6 files changed, 17 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/include/qpid/messaging/Connection.h b/qpid/cpp/include/qpid/messaging/Connection.h
index a7f67ce..9f3102d 100644
--- a/qpid/cpp/include/qpid/messaging/Connection.h
+++ b/qpid/cpp/include/qpid/messaging/Connection.h
@@ -98,6 +98,7 @@ class Connection : public qpid::messaging::Handle<ConnectionImpl>
     QPID_MESSAGING_EXTERN Session createSession(const std::string& name = std::string());
 
     QPID_MESSAGING_EXTERN Session getSession(const std::string& name) const;
+    QPID_MESSAGING_EXTERN std::string getAuthenticatedUsername();
   private:
   friend class qpid::messaging::PrivateImplRef<Connection>;
 
diff --git a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
index f93df90..2fe55cc 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
@@ -325,5 +325,9 @@ bool ConnectionImpl::backoff()
         return false;
     }
 }
+std::string ConnectionImpl::getAuthenticatedUsername()
+{
+    return connection.getNegotiatedSettings().username;
+}
 
 }}} // namespace qpid::client::amqp0_10
diff --git a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h
index 904cef7..8467376 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h
+++ b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.h
@@ -51,6 +51,7 @@ class ConnectionImpl : public qpid::messaging::ConnectionImpl
     void detach();
     void setOption(const std::string& name, const qpid::types::Variant& value);
     bool backoff();
+    std::string getAuthenticatedUsername();
   private:
     typedef std::map<std::string, qpid::messaging::Session> Sessions;
 
diff --git a/qpid/cpp/src/qpid/messaging/Connection.cpp b/qpid/cpp/src/qpid/messaging/Connection.cpp
index 2bd5ba9..e132b6e 100644
--- a/qpid/cpp/src/qpid/messaging/Connection.cpp
+++ b/qpid/cpp/src/qpid/messaging/Connection.cpp
@@ -74,5 +74,8 @@ void Connection::setOption(const std::string& name, const Variant& value)
 { 
     impl->setOption(name, value);
 }
-
+std::string Connection::getAuthenticatedUsername()
+{
+    return impl->getAuthenticatedUsername();
+}
 }} // namespace qpid::messaging
diff --git a/qpid/cpp/src/qpid/messaging/ConnectionImpl.h b/qpid/cpp/src/qpid/messaging/ConnectionImpl.h
index 23ab527..fb45ee5 100644
--- a/qpid/cpp/src/qpid/messaging/ConnectionImpl.h
+++ b/qpid/cpp/src/qpid/messaging/ConnectionImpl.h
@@ -44,6 +44,7 @@ class ConnectionImpl : public virtual qpid::RefCounted
     virtual Session newSession(bool transactional, const std::string& name) = 0;
     virtual Session getSession(const std::string& name) const = 0;
     virtual void setOption(const std::string& name, const qpid::types::Variant& value) = 0;
+    virtual std::string getAuthenticatedUsername() = 0;
   private:
 };
 }} // namespace qpid::messaging
diff --git a/qpid/cpp/src/tests/MessagingSessionTests.cpp b/qpid/cpp/src/tests/MessagingSessionTests.cpp
index c22cb4b..ce1d885 100644
--- a/qpid/cpp/src/tests/MessagingSessionTests.cpp
+++ b/qpid/cpp/src/tests/MessagingSessionTests.cpp
@@ -769,6 +769,12 @@ QPID_AUTO_TEST_CASE(testExclusiveSubscriber)
     } catch (const MessagingException& e) {}
 }
 
+QPID_AUTO_TEST_CASE(testAuthenticatedUsername)
+{
+    MessagingFixture fix;
+    BOOST_CHECK_EQUAL(fix.connection.getAuthenticatedUsername(), std::string("anonymous"));
+}
+
 
 QPID_AUTO_TEST_SUITE_END()
 
-- 
1.7.1.1

From c3e6ea43dcfbb328fa693667b056f237397e4cb9 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Thu, 1 Jul 2010 12:42:41 +0000
Subject: [PATCH 101/129] Bug 588766  - Create separate library for messaging API and implementation

Add qpid/types/ImportExport.h to distribution.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@959638 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit fa2ed0433c91a141ababb2c219b4183ac4dc27f8)
---
 qpid/cpp/src/Makefile.am |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/Makefile.am b/qpid/cpp/src/Makefile.am
index 6340bf2..c8d0402 100644
--- a/qpid/cpp/src/Makefile.am
+++ b/qpid/cpp/src/Makefile.am
@@ -715,7 +715,9 @@ libqpidtypes_la_libadd=-luuid
 libqpidtypes_la_SOURCES=			\
   qpid/types/Exception.cpp			\
   qpid/types/Uuid.cpp				\
-  qpid/types/Variant.cpp
+  qpid/types/Variant.cpp			\
+  ../include/qpid/types/ImportExport.h
+
 QPIDTYPES_VERSION_INFO  = 1:0:0
 libqpidtypes_la_LDFLAGS = -version-info $(QPIDTYPES_VERSION_INFO)
 
-- 
1.7.1.1

From cc8011cbd558e4fbc000c0156720d54c156a5e82 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Thu, 1 Jul 2010 13:47:11 +0000
Subject: [PATCH 102/129] Bug 609682  - Broker crash on exit with assertion in Thread::join

Ensure broker is deleted in main thread, not by global destructors.

Fixes core dumps during shutdown.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@959661 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 62793fa314f2e3821f7035b74087793867e3d71a)
---
 qpid/cpp/src/posix/QpiddBroker.cpp |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/posix/QpiddBroker.cpp b/qpid/cpp/src/posix/QpiddBroker.cpp
index 7eef187..b340e3e 100644
--- a/qpid/cpp/src/posix/QpiddBroker.cpp
+++ b/qpid/cpp/src/posix/QpiddBroker.cpp
@@ -128,6 +128,7 @@ struct QpiddDaemon : public Daemon {
         uint16_t port=brokerPtr->getPort(options->daemon.transport);
         ready(port);            // Notify parent.
         brokerPtr->run();
+        broker::SignalHandler::setBroker(0); // Delete broker in this thread.
     }
 };
 
@@ -174,6 +175,7 @@ int QpiddBroker::execute (QpiddOptions *options) {
         if (options->broker.port == 0 || myOptions->daemon.transport != TCP)
             cout << uint16_t(brokerPtr->getPort(myOptions->daemon.transport)) << endl;
         brokerPtr->run();
+        broker::SignalHandler::setBroker(0); // Delete broker in this thread.
     }
     return 0;
 }
-- 
1.7.1.1

From 9a005978daf378f235f2806a1e50eeb0dd44bd94 Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Thu, 1 Jul 2010 16:49:22 +0000
Subject: [PATCH 103/129] Bug 610156 - Fixed - The qpid::messaging API sometimes uses exceptions from the qpid:: namespace

QPID-664: Translate exceptions to correct type when occuring on creating new session.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@959721 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit cd8ce28d8fd26c434d69ea949167b7e56418246f)
---
 .../src/qpid/client/amqp0_10/ConnectionImpl.cpp    |    4 ++++
 qpid/cpp/src/tests/MessagingSessionTests.cpp       |    8 ++++++++
 2 files changed, 12 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
index 2fe55cc..f3cc4f7 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp
@@ -213,6 +213,10 @@ qpid::messaging::Session ConnectionImpl::newSession(bool transactional, const st
             break;
         } catch (const qpid::TransportFailure&) {
             open();
+        } catch (const qpid::SessionException& e) {
+            throw qpid::messaging::SessionError(e.what());
+        } catch (const std::exception& e) {
+            throw qpid::messaging::MessagingException(e.what());            
         }
     }
     return impl;
diff --git a/qpid/cpp/src/tests/MessagingSessionTests.cpp b/qpid/cpp/src/tests/MessagingSessionTests.cpp
index ce1d885..a23e8c3 100644
--- a/qpid/cpp/src/tests/MessagingSessionTests.cpp
+++ b/qpid/cpp/src/tests/MessagingSessionTests.cpp
@@ -775,6 +775,14 @@ QPID_AUTO_TEST_CASE(testAuthenticatedUsername)
     BOOST_CHECK_EQUAL(fix.connection.getAuthenticatedUsername(), std::string("anonymous"));
 }
 
+QPID_AUTO_TEST_CASE(testExceptionOnClosedConnection)
+{
+    MessagingFixture fix;
+    fix.connection.close();
+    BOOST_CHECK_THROW(fix.connection.createSession(), MessagingException);
+    Connection connection("blah");
+    BOOST_CHECK_THROW(connection.createSession(), MessagingException);
+}
 
 QPID_AUTO_TEST_SUITE_END()
 
-- 
1.7.1.1

From 2d688a2c7b161daf424b84879a70fa253b4aea28 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Thu, 1 Jul 2010 18:59:20 +0000
Subject: [PATCH 104/129] Bug 609682  - Broker crash on exit with assertion in Thread::join

Ensure broker is deleted in main thread,  not by global destructors.

Finish the fix of r959661 by making it exception safe.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@959746 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit e570224156a2ee843026bea97a5128389a962d8b)
---
 qpid/cpp/src/posix/QpiddBroker.cpp |   17 +++++++++++++----
 1 files changed, 13 insertions(+), 4 deletions(-)

diff --git a/qpid/cpp/src/posix/QpiddBroker.cpp b/qpid/cpp/src/posix/QpiddBroker.cpp
index b340e3e..bc45b27 100644
--- a/qpid/cpp/src/posix/QpiddBroker.cpp
+++ b/qpid/cpp/src/posix/QpiddBroker.cpp
@@ -107,6 +107,17 @@ void QpiddOptions::usage() const {
     cout << "Usage: qpidd [OPTIONS]" << endl << endl << *this << endl;
 }
 
+// Set the broker pointer on the signal handler, then reset at end of scope.
+// This is to ensure that the signal handler doesn't keep a broker
+// reference after main() has returned.
+// 
+struct ScopedSetBroker {
+    ScopedSetBroker(const boost::intrusive_ptr<Broker>& broker) {
+        qpid::broker::SignalHandler::setBroker(broker);
+    }
+    ~ScopedSetBroker() { qpid::broker::SignalHandler::setBroker(0); }
+};
+    
 struct QpiddDaemon : public Daemon {
     QpiddPosixOptions *options;
   
@@ -123,12 +134,11 @@ struct QpiddDaemon : public Daemon {
     /** Code for forked child process */
     void child() {
         boost::intrusive_ptr<Broker> brokerPtr(new Broker(options->parent->broker));
-        qpid::broker::SignalHandler::setBroker(brokerPtr);
+        ScopedSetBroker ssb(brokerPtr);
         brokerPtr->accept();
         uint16_t port=brokerPtr->getPort(options->daemon.transport);
         ready(port);            // Notify parent.
         brokerPtr->run();
-        broker::SignalHandler::setBroker(0); // Delete broker in this thread.
     }
 };
 
@@ -170,12 +180,11 @@ int QpiddBroker::execute (QpiddOptions *options) {
     }
     else {                  // Non-daemon broker.
         boost::intrusive_ptr<Broker> brokerPtr(new Broker(options->broker));
-        broker::SignalHandler::setBroker(brokerPtr);
+        ScopedSetBroker ssb(brokerPtr);
         brokerPtr->accept();
         if (options->broker.port == 0 || myOptions->daemon.transport != TCP)
             cout << uint16_t(brokerPtr->getPort(myOptions->daemon.transport)) << endl;
         brokerPtr->run();
-        broker::SignalHandler::setBroker(0); // Delete broker in this thread.
     }
     return 0;
 }
-- 
1.7.1.1

From ce1aa1c708aeb84ae572c746d3e93f84fb51614c Mon Sep 17 00:00:00 2001
From: Kenneth Anthony Giusti <kgiusti@apache.org>
Date: Fri, 2 Jul 2010 14:46:30 +0000
Subject: [PATCH 105/129] Bug 610772  - QMF: c++ agent does not set agent name attribute in new object id's

QPID-2716: QMF bugfix - set agent name in object id

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@960012 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 809ec3077dbe82d0b77f46c9a7c6ec90ce0cb555)
---
 qpid/cpp/include/qpid/agent/ManagementAgent.h   |    1 +
 qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp |    7 +++++++
 2 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/include/qpid/agent/ManagementAgent.h b/qpid/cpp/include/qpid/agent/ManagementAgent.h
index d534416..aa0a974 100644
--- a/qpid/cpp/include/qpid/agent/ManagementAgent.h
+++ b/qpid/cpp/include/qpid/agent/ManagementAgent.h
@@ -69,6 +69,7 @@ class ManagementAgent
     //   product  - Product name (i.e. "qpid")
     //   instance - A unique identifier for this instance of the agent.
     //              If empty, the agent will create a GUID for the instance.
+    //   Note: the ":" character is reserved - do no use it in the vendor or product name.
     //
     virtual void setName(const std::string& vendor,
                          const std::string& product,
diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
index e2a595c..bc841ca 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
@@ -125,6 +125,12 @@ ManagementAgentImpl::~ManagementAgentImpl()
 
 void ManagementAgentImpl::setName(const string& vendor, const string& product, const string& instance)
 {
+    if (vendor.find(':') != vendor.npos) {
+        throw Exception("vendor string cannot contain a ':' character.");
+    }
+    if (product.find(':') != product.npos) {
+        throw Exception("product string cannot contain a ':' character.");
+    }
     attrMap["_vendor"] = vendor;
     attrMap["_product"] = product;
     string inst;
@@ -249,6 +255,7 @@ ObjectId ManagementAgentImpl::addObject(ManagementObject* object,
         objectId.setV2Key(*object);  // let object generate the key
     else
         objectId.setV2Key(key);
+    objectId.setAgentName(name_address);
 
     object->setObjectId(objectId);
     newManagementObjects[objectId] = object;
-- 
1.7.1.1

From 4c4daa6bc46e6fe6bf18ecb3abbb68a1ca619e67 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Mon, 5 Jul 2010 13:07:38 +0000
Subject: [PATCH 106/129] No Bugzilla: fix missing headers needed to build store.

Added types/ImportExport.h to installed headers.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@960588 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 64327d0769dae12795a31d46868478a3bca26707)
---
 qpid/cpp/src/Makefile.am |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/Makefile.am b/qpid/cpp/src/Makefile.am
index c8d0402..52bdf98 100644
--- a/qpid/cpp/src/Makefile.am
+++ b/qpid/cpp/src/Makefile.am
@@ -852,7 +852,8 @@ nobase_include_HEADERS +=			\
   ../include/qpid/messaging/FailoverUpdates.h	\
   ../include/qpid/types/Exception.h	 	\
   ../include/qpid/types/Uuid.h	 		\
-  ../include/qpid/types/Variant.h
+  ../include/qpid/types/Variant.h		\
+  ../include/qpid/types/ImportExport.h
 
 # Force build of qpidd during dist phase so help2man will work.
 dist-hook: $(BUILT_SOURCES)
-- 
1.7.1.1

From ba83c5fd4c4cccae42240c70473d8d37fd8d3fcb Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Mon, 5 Jul 2010 20:12:08 +0000
Subject: [PATCH 107/129] Bug 611543  - Assertion when raising a link established event on clustered broker

Defer delivery of messages in cluster-unsafe context.

Messages enqueued in a cluster-safe context are synchronized across
the cluster.  However some messages are delivered in a cluster-unsafe
context, for example raising a link established event occurs the
connection thread of the establishing connection.

This fix deferrs such messages by multicasting them so they can be
re-delived in a cluster safe context.

See https://bugzilla.redhat.com/show_bug.cgi?id=611543

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@960681 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/src/qpid/broker/Broker.cpp   |    7 +++++-
 qpid/cpp/src/qpid/broker/Broker.h     |   13 ++++++++++++
 qpid/cpp/src/qpid/broker/Queue.cpp    |    3 ++
 qpid/cpp/src/qpid/cluster/Cluster.cpp |   35 +++++++++++++++++++++++++++++++-
 qpid/cpp/src/qpid/cluster/Cluster.h   |   10 ++++++++-
 qpid/cpp/src/tests/cluster_tests.py   |   17 +++++++++++++++-
 qpid/cpp/xml/cluster.xml              |    6 +++++
 qpid/python/qpid/brokertest.py        |   16 ++++++--------
 8 files changed, 93 insertions(+), 14 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Broker.cpp b/qpid/cpp/src/qpid/broker/Broker.cpp
index 399ed58..02f403a 100644
--- a/qpid/cpp/src/qpid/broker/Broker.cpp
+++ b/qpid/cpp/src/qpid/broker/Broker.cpp
@@ -161,7 +161,8 @@ Broker::Broker(const Broker::Options& conf) :
     clusterUpdatee(false),
     expiryPolicy(new ExpiryPolicy),
     connectionCounter(conf.maxConnections),
-    getKnownBrokers(boost::bind(&Broker::getKnownBrokersImpl, this))
+    getKnownBrokers(boost::bind(&Broker::getKnownBrokersImpl, this)),
+    deferDelivery(boost::bind(&Broker::deferDeliveryImpl, this, _1, _2))
 {
     if (conf.enableMgmt) {
         QPID_LOG(info, "Management enabled");
@@ -491,6 +492,10 @@ Broker::getKnownBrokersImpl()
     return knownBrokers;
 }
 
+bool Broker::deferDeliveryImpl(const std::string& ,
+                               const boost::intrusive_ptr<Message>& )
+{ return false; }
+
 void Broker::setClusterTimer(std::auto_ptr<sys::Timer> t) {
     clusterTimer = t;
 }
diff --git a/qpid/cpp/src/qpid/broker/Broker.h b/qpid/cpp/src/qpid/broker/Broker.h
index f55f94b..05d1c79 100644
--- a/qpid/cpp/src/qpid/broker/Broker.h
+++ b/qpid/cpp/src/qpid/broker/Broker.h
@@ -69,6 +69,7 @@ struct Url;
 namespace broker {
 
 class ExpiryPolicy;
+class Message;
 
 static const  uint16_t DEFAULT_PORT=5672;
 
@@ -167,6 +168,8 @@ public:
     QueueEvents queueEvents;
     std::vector<Url> knownBrokers;
     std::vector<Url> getKnownBrokersImpl();
+    bool deferDeliveryImpl(const std::string& queue,
+                           const boost::intrusive_ptr<Message>& msg);
     std::string federationTag;
     bool recovery;
     bool clusterUpdatee;
@@ -272,6 +275,16 @@ public:
     management::ManagementAgent* getManagementAgent() { return managementAgent.get(); }
     
     ConnectionCounter& getConnectionCounter() {return connectionCounter;}
+
+    /**
+     * Never true in a stand-alone broker. In a cluster, return true
+     * to defer delivery of messages deliveredg in a cluster-unsafe
+     * context.
+     *@return true if delivery of a message should be deferred.
+     */
+    boost::function<bool (const std::string& queue,
+                          const boost::intrusive_ptr<Message>& msg)> deferDelivery;
+
 };
 
 }}
diff --git a/qpid/cpp/src/qpid/broker/Queue.cpp b/qpid/cpp/src/qpid/broker/Queue.cpp
index dd077aa..40ef605 100644
--- a/qpid/cpp/src/qpid/broker/Queue.cpp
+++ b/qpid/cpp/src/qpid/broker/Queue.cpp
@@ -142,6 +142,9 @@ bool Queue::isExcluded(boost::intrusive_ptr<Message>& msg)
 }
 
 void Queue::deliver(boost::intrusive_ptr<Message> msg){
+    // Check for deferred delivery in a cluster.
+    if (broker && broker->deferDelivery(name, msg))
+        return;
     if (msg->isImmediate() && getConsumerCount() == 0) {
         if (alternateExchange) {
             DeliverableMessage deliverable(msg);
diff --git a/qpid/cpp/src/qpid/cluster/Cluster.cpp b/qpid/cpp/src/qpid/cluster/Cluster.cpp
index 233cc89..d01e801 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.cpp
+++ b/qpid/cpp/src/qpid/cluster/Cluster.cpp
@@ -137,6 +137,8 @@
 #include "qpid/broker/Connection.h"
 #include "qpid/broker/NullMessageStore.h"
 #include "qpid/broker/QueueRegistry.h"
+#include "qpid/broker/Queue.h"
+#include "qpid/broker/Message.h"
 #include "qpid/broker/SessionState.h"
 #include "qpid/broker/SignalHandler.h"
 #include "qpid/framing/AMQFrame.h"
@@ -154,6 +156,7 @@
 #include "qpid/framing/ClusterConnectionAnnounceBody.h"
 #include "qpid/framing/ClusterErrorCheckBody.h"
 #include "qpid/framing/ClusterTimerWakeupBody.h"
+#include "qpid/framing/ClusterDeliverToQueueBody.h"
 #include "qpid/framing/MessageTransferBody.h"
 #include "qpid/log/Helpers.h"
 #include "qpid/log/Statement.h"
@@ -232,9 +235,10 @@ struct ClusterDispatcher : public framing::AMQP_AllOperations::ClusterHandler {
     }
     void timerWakeup(const std::string& name) { cluster.timerWakeup(member, name, l); }
     void timerDrop(const std::string& name) { cluster.timerWakeup(member, name, l); }
-
     void shutdown(const Uuid& id) { cluster.shutdown(member, id, l); }
-
+    void deliverToQueue(const std::string& queue, const std::string& message) {
+        cluster.deliverToQueue(queue, message, l);
+    }
     bool invoke(AMQBody& body) { return framing::invoke(*this, body).wasHandled(); }
 };
 
@@ -310,6 +314,7 @@ void Cluster::initialize() {
     else
         myUrl = settings.url;
     broker.getKnownBrokers = boost::bind(&Cluster::getUrls, this);
+    broker.deferDelivery = boost::bind(&Cluster::deferDeliveryImpl, this, _1, _2);
     broker.setExpiryPolicy(expiryPolicy);
     dispatcher.start();
     deliverEventQueue.bypassOff();
@@ -1097,4 +1102,30 @@ bool Cluster::isElder() const {
     return elder;
 }
 
+void Cluster::deliverToQueue(const std::string& queue, const std::string& message, Lock& l)
+{
+    broker::Queue::shared_ptr q = broker.getQueues().find(queue);
+    if (!q) {
+        QPID_LOG(critical, *this << " cluster delivery to non-existent queue: " << queue);
+        leave(l);
+    }
+    framing::Buffer buf(const_cast<char*>(message.data()), message.size());
+    boost::intrusive_ptr<broker::Message> msg(new broker::Message);
+    msg->decodeHeader(buf);
+    msg->decodeContent(buf);
+    q->deliver(msg);
+}
+
+bool Cluster::deferDeliveryImpl(const std::string& queue,
+                                const boost::intrusive_ptr<broker::Message>& msg)
+{
+    if (isClusterSafe()) return false;
+    std::string message;
+    message.resize(msg->encodedSize());
+    framing::Buffer buf(const_cast<char*>(message.data()), message.size());
+    msg->encode(buf);
+    mcast.mcastControl(ClusterDeliverToQueueBody(ProtocolVersion(), queue, message), self);
+    return true;
+}
+
 }} // namespace qpid::cluster
diff --git a/qpid/cpp/src/qpid/cluster/Cluster.h b/qpid/cpp/src/qpid/cluster/Cluster.h
index 84dee27..5668d04 100644
--- a/qpid/cpp/src/qpid/cluster/Cluster.h
+++ b/qpid/cpp/src/qpid/cluster/Cluster.h
@@ -54,6 +54,10 @@
 
 namespace qpid {
 
+namespace broker {
+class Message;
+}
+
 namespace framing {
 class AMQBody;
 class Uuid;
@@ -124,6 +128,10 @@ class Cluster : private Cpg::Handler, public management::Manageable {
     // Generates a log message for debugging purposes.
     std::string debugSnapshot();
 
+    // Defer messages delivered in an unsafe context by multicasting.
+    bool deferDeliveryImpl(const std::string& queue,
+                           const boost::intrusive_ptr<broker::Message>& msg);
+
   private:
     typedef sys::Monitor::ScopedLock Lock;
 
@@ -173,8 +181,8 @@ class Cluster : private Cpg::Handler, public management::Manageable {
     void errorCheck(const MemberId&, uint8_t type, SequenceNumber frameSeq, Lock&);
     void timerWakeup(const MemberId&, const std::string& name, Lock&);
     void timerDrop(const MemberId&, const std::string& name, Lock&);
-
     void shutdown(const MemberId&, const framing::Uuid& shutdownId, Lock&);
+    void deliverToQueue(const std::string& queue, const std::string& message, Lock&);
 
     // Helper functions
     ConnectionPtr getConnection(const EventFrame&, Lock&);
diff --git a/qpid/cpp/src/tests/cluster_tests.py b/qpid/cpp/src/tests/cluster_tests.py
index ebb07a1..e6d3900 100755
--- a/qpid/cpp/src/tests/cluster_tests.py
+++ b/qpid/cpp/src/tests/cluster_tests.py
@@ -101,7 +101,22 @@ class ShortTests(BrokerTest):
         assert readfile("direct.dump") == readfile("updatee.dump")
         os.remove("direct.dump")
         os.remove("updatee.dump")
-        
+
+    def test_link_events(self):
+        """Regression test for https://bugzilla.redhat.com/show_bug.cgi?id=611543"""
+        args = ["--mgmt-pub-interval", 1] # Publish management information every second.
+        broker1 = self.cluster(1, args)[0]
+        broker2 = self.cluster(1, args)[0]
+        qp = self.popen(["qpid-printevents", broker1.host_port()], EXPECT_RUNNING)
+        qr = self.popen(["qpid-route", "route", "add",
+                         broker1.host_port(), broker2.host_port(),
+                         "amq.fanout", "key"
+                         ], EXPECT_EXIT_OK)
+        # Look for link event in printevents output.
+        retry(lambda: find_in_file("brokerLinkUp", qp.outfile("out")))
+        broker1.ready()
+        broker2.ready()
+
 class LongTests(BrokerTest):
     """Tests that can run for a long time if -DDURATION=<minutes> is set"""
     def duration(self):
diff --git a/qpid/cpp/xml/cluster.xml b/qpid/cpp/xml/cluster.xml
index 30cd159..ecd4515 100644
--- a/qpid/cpp/xml/cluster.xml
+++ b/qpid/cpp/xml/cluster.xml
@@ -110,6 +110,12 @@
       <field name="shutdown-id" type="uuid"/>
     </control>
 
+    <!-- Deliver a message to a queue -->
+    <control name="deliver-to-queue" code="0x21">
+      <field name="queue" type="str16"/>
+      <field name="message" type="vbin32"/>
+    </control>
+
   </class>
 
   <!-- Controls associated with a specific connection. -->
diff --git a/qpid/python/qpid/brokertest.py b/qpid/python/qpid/brokertest.py
index 2242dcb..fddeefa 100644
--- a/qpid/python/qpid/brokertest.py
+++ b/qpid/python/qpid/brokertest.py
@@ -250,6 +250,12 @@ def checkenv(name):
     if not value: raise Exception("Environment variable %s is not set" % name)
     return value
 
+def find_in_file(str, filename):
+    if not os.path.exists(filename): return False
+    f = open(filename)
+    try: return str in f.read()
+    finally: f.close()
+
 class Broker(Popen):
     "A broker process. Takes care of start, stop and logging."
     _broker_count = 0
@@ -366,15 +372,7 @@ class Broker(Popen):
     def log_ready(self):
         """Return true if the log file exists and contains a broker ready message"""
         if self._log_ready: return True
-        if not os.path.exists(self.log): return False
-        f = open(self.log)
-        try:
-            for l in f:
-                if "notice Broker running" in l:
-                    self._log_ready = True
-                    return True
-            return False
-        finally: f.close()
+        self._log_ready = find_in_file("notice Broker running", self.log)
 
     def ready(self):
         """Wait till broker is ready to serve clients"""
-- 
1.7.1.1

From 22397fbf439ed2d7f61fa50a85439e3998771fdd Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Tue, 6 Jul 2010 17:27:58 +0000
Subject: [PATCH 108/129] Bug 611847 - Fixed - Thread safety issue - Session::createSender hangs when another thread calls nextReceiver

QPID-664: Don't hold lock while waiting for incoming message in nextReceiver() call.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@960951 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 58f025104a61c13113cd6e0c61ee73553cb597bf)
---
 qpid/cpp/src/qpid/client/amqp0_10/SessionImpl.cpp |    2 +-
 qpid/cpp/src/tests/MessagingThreadTests.cpp       |   37 +++++++++++++++++++++
 2 files changed, 38 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/qpid/client/amqp0_10/SessionImpl.cpp b/qpid/cpp/src/qpid/client/amqp0_10/SessionImpl.cpp
index a606709..800c326 100644
--- a/qpid/cpp/src/qpid/client/amqp0_10/SessionImpl.cpp
+++ b/qpid/cpp/src/qpid/client/amqp0_10/SessionImpl.cpp
@@ -323,11 +323,11 @@ bool SessionImpl::get(ReceiverImpl& receiver, qpid::messaging::Message& message,
 
 bool SessionImpl::nextReceiver(qpid::messaging::Receiver& receiver, qpid::messaging::Duration timeout)
 {
-    qpid::sys::Mutex::ScopedLock l(lock);
     while (true) {
         try {
             std::string destination;
             if (incoming.getNextDestination(destination, adjust(timeout))) {
+                qpid::sys::Mutex::ScopedLock l(lock);
                 Receivers::const_iterator i = receivers.find(destination);
                 if (i == receivers.end()) {
                     throw qpid::messaging::ReceiverError(QPID_MSG("Received message for unknown destination " << destination));
diff --git a/qpid/cpp/src/tests/MessagingThreadTests.cpp b/qpid/cpp/src/tests/MessagingThreadTests.cpp
index a355ba7..4826473 100644
--- a/qpid/cpp/src/tests/MessagingThreadTests.cpp
+++ b/qpid/cpp/src/tests/MessagingThreadTests.cpp
@@ -54,6 +54,25 @@ struct ReceiveThread : public sys::Runnable {
     }
 };
 
+struct NextReceiverThread : public sys::Runnable {
+    Session session;
+    vector<string> received;
+    string error;
+
+    NextReceiverThread(Session s) : session(s) {}
+    void run() {
+        try {
+            while(true) {
+                Message m = session.nextReceiver(Duration::SECOND*5).fetch();
+                if (m.getContent() == "END") break;
+                received.push_back(m.getContent());
+            }
+        } catch (const std::exception& e) {
+            error = e.what();
+        }
+    }
+};
+
 
 QPID_AUTO_TEST_CASE(testConcurrentSendReceive) {
     MessagingFixture fix;
@@ -103,5 +122,23 @@ QPID_AUTO_TEST_CASE(testCloseSessionBusyReceiver) {
     BOOST_CHECK_THROW(r.fetch(Duration(0)), NoMessageAvailable);
 }
 
+QPID_AUTO_TEST_CASE(testConcurrentSendNextReceiver) {
+    MessagingFixture fix;
+    Receiver r = fix.session.createReceiver("concurrent;{create:always,link:{reliability:unreliable}}");
+    const size_t COUNT=100;
+    r.setCapacity(COUNT);
+    NextReceiverThread rt(fix.session);
+    sys::Thread thread(rt);
+    sys::usleep(1000);          // Give the receive thread time to block.
+    Sender s = fix.session.createSender("concurrent;{create:always}");
+    for (size_t i = 0; i < COUNT; ++i) {
+        s.send(Message());
+    }
+    s.send(Message("END"));
+    thread.join();
+    BOOST_CHECK_EQUAL(rt.error, string());
+    BOOST_CHECK_EQUAL(COUNT, rt.received.size());
+}
+
 QPID_AUTO_TEST_SUITE_END()
 }} // namespace qpid::tests
-- 
1.7.1.1

From 9ea6c8b4d425e07529bea1e16c2582b96bb79ea5 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Wed, 7 Jul 2010 15:20:01 +0000
Subject: [PATCH 109/129] Bug 609682  - Broker crash on exit with assertion in Thread::join

Ensure broker is deleted in main thread,  not by global destructors.

This fixes a race condition that was not handled by r959746.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@961404 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 592f0eb256d53307384e5379120cc202004c66d7)
---
 qpid/cpp/src/posix/QpiddBroker.cpp         |    2 +-
 qpid/cpp/src/qpid/broker/SignalHandler.cpp |   20 ++++++++++++--------
 qpid/cpp/src/qpid/broker/SignalHandler.h   |   10 +++++-----
 3 files changed, 18 insertions(+), 14 deletions(-)

diff --git a/qpid/cpp/src/posix/QpiddBroker.cpp b/qpid/cpp/src/posix/QpiddBroker.cpp
index bc45b27..8799354 100644
--- a/qpid/cpp/src/posix/QpiddBroker.cpp
+++ b/qpid/cpp/src/posix/QpiddBroker.cpp
@@ -113,7 +113,7 @@ void QpiddOptions::usage() const {
 // 
 struct ScopedSetBroker {
     ScopedSetBroker(const boost::intrusive_ptr<Broker>& broker) {
-        qpid::broker::SignalHandler::setBroker(broker);
+        qpid::broker::SignalHandler::setBroker(broker.get());
     }
     ~ScopedSetBroker() { qpid::broker::SignalHandler::setBroker(0); }
 };
diff --git a/qpid/cpp/src/qpid/broker/SignalHandler.cpp b/qpid/cpp/src/qpid/broker/SignalHandler.cpp
index b565cfd..16c141f 100644
--- a/qpid/cpp/src/qpid/broker/SignalHandler.cpp
+++ b/qpid/cpp/src/qpid/broker/SignalHandler.cpp
@@ -20,30 +20,34 @@
  */
 #include "qpid/broker/SignalHandler.h"
 #include "qpid/broker/Broker.h"
+#include "qpid/sys/Mutex.h"
 #include <signal.h>
 
 namespace qpid {
 namespace broker {
 
-boost::intrusive_ptr<Broker> SignalHandler::broker;
+// Lock is to ensure that broker is not concurrently set to 0 and
+// deleted while we are in a call to broker->shutdown()
 
-void SignalHandler::setBroker(const boost::intrusive_ptr<Broker>& b) {
-    broker = b;
+sys::Mutex brokerLock;
+Broker* SignalHandler::broker;
 
+void SignalHandler::setBroker(Broker* b) {
+    sys::Mutex::ScopedLock l(brokerLock);
+    broker = b;
     signal(SIGINT,shutdownHandler); 
     signal(SIGTERM, shutdownHandler);
-
-    signal(SIGHUP,SIG_IGN); // TODO aconway 2007-07-18: reload config.
-
+    signal(SIGHUP,SIG_IGN);
     signal(SIGCHLD,SIG_IGN); 
 }
 
 void SignalHandler::shutdown() { shutdownHandler(0); }
 
 void SignalHandler::shutdownHandler(int) {
-    if (broker.get()) {
+    sys::Mutex::ScopedLock l(brokerLock);
+    if (broker) {
         broker->shutdown();
-        broker = 0;             // Release the broker reference.
+        broker = 0;
     }
 }
 
diff --git a/qpid/cpp/src/qpid/broker/SignalHandler.h b/qpid/cpp/src/qpid/broker/SignalHandler.h
index bbe831b..7bfa9ea 100644
--- a/qpid/cpp/src/qpid/broker/SignalHandler.h
+++ b/qpid/cpp/src/qpid/broker/SignalHandler.h
@@ -22,8 +22,6 @@
  *
  */
 
-#include <boost/intrusive_ptr.hpp>
-
 namespace qpid {
 namespace broker {
 
@@ -35,15 +33,17 @@ class Broker;
 class SignalHandler
 {
   public:
-    /** Set the broker to be shutdown on signals */
-    static void setBroker(const boost::intrusive_ptr<Broker>& broker);
+    /** Set the broker to be shutdown on signals.
+     * Must be reset by calling setBroker(0) before the broker is deleted.
+     */
+    static void setBroker(Broker* broker);
 
     /** Initiate shut-down of broker */
     static void shutdown();
 
   private:
     static void shutdownHandler(int);
-    static boost::intrusive_ptr<Broker> broker;
+    static Broker* broker;
 };
 }} // namespace qpid::broker
 
-- 
1.7.1.1

From 860119742313b551d3ee9bf116d398bc04129675 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Thu, 8 Jul 2010 15:40:01 +0000
Subject: [PATCH 110/129] Bug 610493  - qpidd broker aborts in qpid::sys::Thread::join() / qpid::sys::assertClusterSafe() during 'furious' shutdown

Fix cluster-safe assertion in ~Connection.

Don't trigger cluster-safe asserts in broker::~Connection as it can be
called from an IO threads during broker shutdown.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@961814 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 33e2bc4b0925e86417c41e5a4569393cdaae2a03)
---
 qpid/cpp/src/qpid/cluster/Connection.cpp |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/cluster/Connection.cpp b/qpid/cpp/src/qpid/cluster/Connection.cpp
index 04aced5..aad3d8a 100644
--- a/qpid/cpp/src/qpid/cluster/Connection.cpp
+++ b/qpid/cpp/src/qpid/cluster/Connection.cpp
@@ -41,6 +41,7 @@
 #include "qpid/framing/ConnectionCloseBody.h"
 #include "qpid/framing/ConnectionCloseOkBody.h"
 #include "qpid/log/Statement.h"
+#include "qpid/sys/ClusterSafe.h"
 #include "qpid/management/ManagementAgent.h"
 #include <boost/current_function.hpp>
 
@@ -169,6 +170,11 @@ void Connection::announce(
 
 Connection::~Connection() {
     if (connection.get()) connection->setErrorListener(0);
+    // Don't trigger cluster-safe asserts in broker:: ~Connection as
+    // it may be called in an IO thread context during broker
+    // shutdown.
+    sys::ClusterSafeScope css;
+    connection.reset();
 }
 
 bool Connection::doOutput() {
-- 
1.7.1.1

From a0e4c21893973aea53b773381ee6ca2c7e6dbcb2 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Thu, 8 Jul 2010 15:53:49 +0000
Subject: [PATCH 111/129] BZ-612615 convert ttl from seconds to milliseconds

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@961824 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py  |    8 ++++++--
 qpid/python/qpid/messaging/message.py |    8 ++++++++
 2 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 2175715..a3c565f 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -980,6 +980,7 @@ class Engine:
         break
 
     for snd in ssn.senders:
+      # XXX: should included snd.acked in this
       if snd.synced >= snd.queued and sst.need_sync:
         sst.write_cmd(ExecutionSync(), sync_noop)
 
@@ -1182,9 +1183,11 @@ class Engine:
     if msg.priority is not None:
       dp.priority = msg.priority
     if msg.ttl is not None:
-      dp.ttl = msg.ttl
+      dp.ttl = long(msg.ttl*1000)
     enc, dec = get_codec(msg.content_type)
     body = enc(msg.content)
+
+    # XXX: this is not safe for out of order, can this be triggered by pre_ack?
     def msg_acked():
       # XXX: should we log the ack somehow too?
       snd.acked += 1
@@ -1243,7 +1246,8 @@ class Engine:
     if dp.delivery_mode is not None:
       msg.durable = dp.delivery_mode == delivery_mode.persistent
     msg.priority = dp.priority
-    msg.ttl = dp.ttl
+    if dp.ttl is not None:
+      msg.ttl = dp.ttl/1000.0
     msg.redelivered = dp.redelivered
     msg.properties = mp.application_headers or {}
     if mp.app_id is not None:
diff --git a/qpid/python/qpid/messaging/message.py b/qpid/python/qpid/messaging/message.py
index a96a6da..e2406f1 100644
--- a/qpid/python/qpid/messaging/message.py
+++ b/qpid/python/qpid/messaging/message.py
@@ -74,12 +74,20 @@ class Message:
 
   @type id: str
   @ivar id: the message id
+  @type subject: str
+  @ivar subject: message subject
   @type user_id: str
   @ivar user_id: the user-id of the message producer
   @type reply_to: str
   @ivar reply_to: the address to send replies
   @type correlation_id: str
   @ivar correlation_id: a correlation-id for the message
+  @type durable: bool
+  @ivar durable: message durability
+  @type priority: int
+  @ivar priority: message priority
+  @type ttl: float
+  @ivar ttl: time-to-live measured in seconds
   @type properties: dict
   @ivar properties: application specific message properties
   @type content_type: str
-- 
1.7.1.1

From 9343455e23ac695b957d5d4f357acf925516f173 Mon Sep 17 00:00:00 2001
From: Kenneth Anthony Giusti <kgiusti@apache.org>
Date: Thu, 8 Jul 2010 20:29:52 +0000
Subject: [PATCH 112/129] Bug 612682  - QMF: need to be able to construct object id's from agent and object identification strings.

QMF: add api to get agent id, and new object id constructor that uses agent id.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@961919 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit f67dc9fc3989a350af068ff5d80a8d325ef78f2a)
---
 qpid/cpp/include/qpid/agent/ManagementAgent.h      |   10 ++++++++++
 .../cpp/include/qpid/management/ManagementObject.h |    4 ++++
 qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp    |   15 +++++++++++++++
 qpid/cpp/src/qpid/agent/ManagementAgentImpl.h      |    2 ++
 qpid/cpp/src/qpid/management/ManagementAgent.cpp   |   20 ++++++++++++++++++++
 qpid/cpp/src/qpid/management/ManagementAgent.h     |    3 +++
 qpid/cpp/src/tests/ManagementTest.cpp              |    7 +++++++
 7 files changed, 61 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/include/qpid/agent/ManagementAgent.h b/qpid/cpp/include/qpid/agent/ManagementAgent.h
index aa0a974..e245124 100644
--- a/qpid/cpp/include/qpid/agent/ManagementAgent.h
+++ b/qpid/cpp/include/qpid/agent/ManagementAgent.h
@@ -75,6 +75,16 @@ class ManagementAgent
                          const std::string& product,
                          const std::string& instance="") = 0;
 
+    // Retrieve the name of the agent as assigned by setName()
+    //
+    virtual void getName(std::string& vendor,
+                         std::string& product,
+                         std::string& instance) = 0;
+
+    // Obtain the fully qualified name of the agent
+    //
+    virtual const std::string& getAddress() = 0;
+
     // Connect to a management broker
     //
     //   brokerHost        - Hostname or IP address (dotted-quad) of broker.
diff --git a/qpid/cpp/include/qpid/management/ManagementObject.h b/qpid/cpp/include/qpid/management/ManagementObject.h
index 6bbd7ec..59a7f00 100644
--- a/qpid/cpp/include/qpid/management/ManagementObject.h
+++ b/qpid/cpp/include/qpid/management/ManagementObject.h
@@ -65,6 +65,10 @@ public:
     QPID_COMMON_EXTERN ObjectId(AgentAttachment* _agent, uint8_t flags, uint16_t seq);
     QPID_COMMON_EXTERN ObjectId(std::istream&);
     QPID_COMMON_EXTERN ObjectId(const std::string&);
+    QPID_COMMON_EXTERN ObjectId(const std::string& agentAddress, const std::string& key,
+                                uint64_t epoch=0) : agent(0), first(0), second(0),
+      agentEpoch(epoch), v2Key(key), agentName(agentAddress) {}
+
     // Deprecated:
     QPID_COMMON_EXTERN ObjectId(uint8_t flags, uint16_t seq, uint32_t broker, uint64_t object);
     QPID_COMMON_EXTERN bool operator==(const ObjectId &other) const;
diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
index bc841ca..351e0bf 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
@@ -144,6 +144,21 @@ void ManagementAgentImpl::setName(const string& vendor, const string& product, c
    attrMap["_name"] = name_address;
 }
 
+
+void ManagementAgentImpl::getName(string& vendor, string& product, string& instance)
+{
+    vendor = std::string(attrMap["_vendor"]);
+    product = std::string(attrMap["_product"]);
+    instance = std::string(attrMap["_instance"]);
+}
+
+
+const std::string& ManagementAgentImpl::getAddress()
+{
+    return name_address;
+}
+
+
 void ManagementAgentImpl::init(const string& brokerHost,
                                uint16_t brokerPort,
                                uint16_t intervalSeconds,
diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
index 7d4531f..4a58807 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
@@ -54,6 +54,8 @@ class ManagementAgentImpl : public ManagementAgent, public client::MessageListen
     void setName(const std::string& vendor,
                  const std::string& product,
                  const std::string& instance="");
+    void getName(std::string& vendor, std::string& product, std::string& instance);
+    const std::string& getAddress();
     void init(const std::string& brokerHost = "localhost",
               uint16_t brokerPort = 5672,
               uint16_t intervalSeconds = 10,
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.cpp b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
index 8818a4c..9e4e966 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.cpp
@@ -197,6 +197,12 @@ void ManagementAgent::pluginsInitialized() {
 
 void ManagementAgent::setName(const string& vendor, const string& product, const string& instance)
 {
+    if (vendor.find(':') != vendor.npos) {
+        throw Exception("vendor string cannot contain a ':' character.");
+    }
+    if (product.find(':') != product.npos) {
+        throw Exception("product string cannot contain a ':' character.");
+    }
     attrMap["_vendor"] = vendor;
     attrMap["_product"] = product;
     string inst;
@@ -218,6 +224,20 @@ void ManagementAgent::setName(const string& vendor, const string& product, const
 }
 
 
+void ManagementAgent::getName(string& vendor, string& product, string& instance)
+{
+    vendor = std::string(attrMap["_vendor"]);
+    product = std::string(attrMap["_product"]);
+    instance = std::string(attrMap["_instance"]);
+}
+
+
+const std::string& ManagementAgent::getAddress()
+{
+    return name_address;
+}
+
+
 void ManagementAgent::writeData ()
 {
     string   filename (dataDir + "/.mbrokerdata");
diff --git a/qpid/cpp/src/qpid/management/ManagementAgent.h b/qpid/cpp/src/qpid/management/ManagementAgent.h
index 44e3eb1..a6e906e 100644
--- a/qpid/cpp/src/qpid/management/ManagementAgent.h
+++ b/qpid/cpp/src/qpid/management/ManagementAgent.h
@@ -77,6 +77,9 @@ public:
     void setName(const std::string& vendor,
                  const std::string& product,
                  const std::string& instance="");
+    void getName(std::string& vendor, std::string& product, std::string& instance);
+    const std::string& getAddress();
+
     void setInterval(uint16_t _interval) { interval = _interval; }
     void setExchange(qpid::broker::Exchange::shared_ptr mgmtExchange,
                      qpid::broker::Exchange::shared_ptr directExchange);
diff --git a/qpid/cpp/src/tests/ManagementTest.cpp b/qpid/cpp/src/tests/ManagementTest.cpp
index e9b8ac3..8944c08 100644
--- a/qpid/cpp/src/tests/ManagementTest.cpp
+++ b/qpid/cpp/src/tests/ManagementTest.cpp
@@ -86,6 +86,13 @@ QPID_AUTO_TEST_CASE(testObjectIdAttach) {
     BOOST_CHECK_EQUAL(out2.str(), "10-20-30-MrSmith-0(GabbaGabbaHey)");
 }
 
+QPID_AUTO_TEST_CASE(testObjectIdCreate) {
+    ObjectId          oid("some-agent-name", "an-object-name");
+
+    BOOST_CHECK_EQUAL(oid.getAgentName(), "some-agent-name");
+    BOOST_CHECK_EQUAL(oid.getV2Key(), "an-object-name");
+}
+
 QPID_AUTO_TEST_CASE(testConsoleObjectId) {
     qpid::console::ObjectId oid1, oid2;
 
-- 
1.7.1.1

From 2517015aba0fe7dba908b6e5d0134a3d7b4fbabd Mon Sep 17 00:00:00 2001
From: Gordon Sim <gsim@apache.org>
Date: Fri, 9 Jul 2010 16:06:44 +0000
Subject: [PATCH 113/129] Bug 612988 - Fixed - clustered qpidd segfaults if --known-hosts-url specifies invalid url

QPID-2727: Handle exceptions in Broker constructor and call finalise to safely cleanup plugins

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@962586 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 4d7e453d2c0da611554ad263186c22c374c090c8)
---
 qpid/cpp/src/qpid/broker/Broker.cpp |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/src/qpid/broker/Broker.cpp b/qpid/cpp/src/qpid/broker/Broker.cpp
index 02f403a..0f1d051 100644
--- a/qpid/cpp/src/qpid/broker/Broker.cpp
+++ b/qpid/cpp/src/qpid/broker/Broker.cpp
@@ -164,6 +164,7 @@ Broker::Broker(const Broker::Options& conf) :
     getKnownBrokers(boost::bind(&Broker::getKnownBrokersImpl, this)),
     deferDelivery(boost::bind(&Broker::deferDeliveryImpl, this, _1, _2))
 {
+    try {
     if (conf.enableMgmt) {
         QPID_LOG(info, "Management enabled");
         managementAgent->configure(dataDir.isEnabled() ? dataDir.getPath() : string(),
@@ -288,6 +289,10 @@ Broker::Broker(const Broker::Options& conf) :
     } else if (conf.knownHosts != knownHostsNone) {
         knownBrokers.push_back(Url(conf.knownHosts));
     }
+    } catch (const std::exception& e) {
+        finalize();
+        throw;
+    }
 }
 
 void Broker::declareStandardExchange(const std::string& name, const std::string& type)
-- 
1.7.1.1

From ee2dcac6734efed72b2379cf22437799e8f39efc Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Mon, 12 Jul 2010 13:43:27 +0000
Subject: [PATCH 114/129] BZ-613216 fixed payload of None for text/plain messages

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@963280 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/message.py       |   16 ++++++++++++++--
 qpid/python/qpid/tests/messaging/message.py |    6 ++++++
 2 files changed, 20 insertions(+), 2 deletions(-)

diff --git a/qpid/python/qpid/messaging/message.py b/qpid/python/qpid/messaging/message.py
index e2406f1..b70b365 100644
--- a/qpid/python/qpid/messaging/message.py
+++ b/qpid/python/qpid/messaging/message.py
@@ -49,11 +49,23 @@ TYPE_MAPPINGS={
 
 DEFAULT_CODEC = (lambda x: x, lambda x: x)
 
+def encode_text_plain(x):
+  if x is None:
+    return None
+  else:
+    return x.encode("utf8")
+
+def decode_text_plain(x):
+  if x is None:
+    return None
+  else:
+    return x.decode("utf8")
+
 TYPE_CODEC={
   "amqp/map": codec("map"),
   "amqp/list": codec("list"),
-  "text/plain; charset=utf8": (lambda x: x.encode("utf8"), lambda x: x.decode("utf8")),
-  "text/plain": (lambda x: x.encode("utf8"), lambda x: x.decode("utf8")),
+  "text/plain; charset=utf8": (encode_text_plain, decode_text_plain),
+  "text/plain": (encode_text_plain, decode_text_plain),
   "": DEFAULT_CODEC,
   None: DEFAULT_CODEC
   }
diff --git a/qpid/python/qpid/tests/messaging/message.py b/qpid/python/qpid/tests/messaging/message.py
index 91aab5f..526a5cf 100644
--- a/qpid/python/qpid/tests/messaging/message.py
+++ b/qpid/python/qpid/tests/messaging/message.py
@@ -111,3 +111,9 @@ class MessageEchoTests(Base):
   def testContentTypeUnknown(self):
     msg = Message(content_type = "this-content-type-does-not-exist")
     self.check(msg)
+
+  def testTextPlain(self):
+    self.check(Message(content_type="text/plain", content="asdf"))
+
+  def testTextPlainEmpty(self):
+    self.check(Message(content_type="text/plain"))
-- 
1.7.1.1

From 3d0eebd14b24321d5c91662c873c1b689c360150 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Tue, 13 Jul 2010 16:33:24 +0000
Subject: [PATCH 115/129] removed old python examples

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@963786 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/cpp/examples/README.verify                    |    6 +-
 qpid/cpp/examples/direct/verify_cpp_python         |    4 -
 qpid/cpp/examples/direct/verify_cpp_python.in      |   14 -
 qpid/cpp/examples/direct/verify_python_cpp         |    5 -
 qpid/cpp/examples/direct/verify_python_cpp.in      |   15 -
 qpid/cpp/examples/fanout/verify_cpp_python         |    7 -
 qpid/cpp/examples/fanout/verify_cpp_python.in      |   27 --
 qpid/cpp/examples/fanout/verify_python_cpp         |    7 -
 qpid/cpp/examples/fanout/verify_python_cpp.in      |   29 --
 qpid/cpp/examples/pub-sub/verify_cpp_python        |    6 -
 qpid/cpp/examples/pub-sub/verify_cpp_python.in     |   55 ----
 qpid/cpp/examples/pub-sub/verify_python_cpp        |    6 -
 qpid/cpp/examples/pub-sub/verify_python_cpp.in     |   59 ----
 .../examples/request-response/verify_cpp_python    |    6 -
 .../examples/request-response/verify_cpp_python.in |   15 -
 .../examples/request-response/verify_python_cpp    |    5 -
 .../examples/request-response/verify_python_cpp.in |   18 -
 qpid/cpp/examples/verify_all                       |   12 +-
 qpid/python/examples/README                        |  335 ++------------------
 qpid/python/examples/datatypes/client.py           |  122 -------
 qpid/python/examples/datatypes/server.py           |  124 -------
 qpid/python/examples/datatypes/testdata.py         |  201 ------------
 qpid/python/examples/direct/declare_queues.py      |   76 -----
 qpid/python/examples/direct/direct_consumer.py     |   94 ------
 qpid/python/examples/direct/direct_producer.py     |   73 -----
 qpid/python/examples/direct/listener.py            |  109 -------
 qpid/python/examples/direct/verify                 |   22 --
 qpid/python/examples/direct/verify.in              |   14 -
 qpid/python/examples/fanout/fanout_consumer.py     |   99 ------
 qpid/python/examples/fanout/fanout_producer.py     |   72 -----
 qpid/python/examples/fanout/listener.py            |  117 -------
 qpid/python/examples/fanout/verify                 |   24 --
 qpid/python/examples/fanout/verify.in              |   27 --
 qpid/python/examples/headers/declare_queues.py     |   77 -----
 qpid/python/examples/headers/headers_consumer.py   |  107 -------
 qpid/python/examples/headers/headers_producer.py   |   79 -----
 qpid/python/examples/headers/verify                |   22 --
 qpid/python/examples/headers/verify.in             |   25 --
 qpid/python/examples/pubsub/topic_publisher.py     |   92 ------
 qpid/python/examples/pubsub/topic_subscriber.py    |  154 ---------
 qpid/python/examples/pubsub/verify                 |   23 --
 qpid/python/examples/pubsub/verify.in              |   55 ----
 qpid/python/examples/request-response/client.py    |  131 --------
 qpid/python/examples/request-response/server.py    |  110 -------
 qpid/python/examples/request-response/verify       |   24 --
 qpid/python/examples/request-response/verify.in    |   14 -
 .../python/examples/xml-exchange/declare_queues.py |   90 ------
 qpid/python/examples/xml-exchange/listener.py      |  105 ------
 qpid/python/examples/xml-exchange/verify           |   22 --
 qpid/python/examples/xml-exchange/verify.in        |   15 -
 qpid/python/examples/xml-exchange/xml_consumer.py  |   96 ------
 qpid/python/examples/xml-exchange/xml_producer.py  |   92 ------
 52 files changed, 33 insertions(+), 3105 deletions(-)
 delete mode 100644 qpid/cpp/examples/direct/verify_cpp_python
 delete mode 100644 qpid/cpp/examples/direct/verify_cpp_python.in
 delete mode 100644 qpid/cpp/examples/direct/verify_python_cpp
 delete mode 100644 qpid/cpp/examples/direct/verify_python_cpp.in
 delete mode 100644 qpid/cpp/examples/fanout/verify_cpp_python
 delete mode 100644 qpid/cpp/examples/fanout/verify_cpp_python.in
 delete mode 100644 qpid/cpp/examples/fanout/verify_python_cpp
 delete mode 100644 qpid/cpp/examples/fanout/verify_python_cpp.in
 delete mode 100644 qpid/cpp/examples/pub-sub/verify_cpp_python
 delete mode 100644 qpid/cpp/examples/pub-sub/verify_cpp_python.in
 delete mode 100644 qpid/cpp/examples/pub-sub/verify_python_cpp
 delete mode 100644 qpid/cpp/examples/pub-sub/verify_python_cpp.in
 delete mode 100644 qpid/cpp/examples/request-response/verify_cpp_python
 delete mode 100644 qpid/cpp/examples/request-response/verify_cpp_python.in
 delete mode 100644 qpid/cpp/examples/request-response/verify_python_cpp
 delete mode 100644 qpid/cpp/examples/request-response/verify_python_cpp.in
 delete mode 100755 qpid/python/examples/datatypes/client.py
 delete mode 100755 qpid/python/examples/datatypes/server.py
 delete mode 100644 qpid/python/examples/datatypes/testdata.py
 delete mode 100755 qpid/python/examples/direct/declare_queues.py
 delete mode 100755 qpid/python/examples/direct/direct_consumer.py
 delete mode 100755 qpid/python/examples/direct/direct_producer.py
 delete mode 100755 qpid/python/examples/direct/listener.py
 delete mode 100644 qpid/python/examples/direct/verify
 delete mode 100644 qpid/python/examples/direct/verify.in
 delete mode 100755 qpid/python/examples/fanout/fanout_consumer.py
 delete mode 100755 qpid/python/examples/fanout/fanout_producer.py
 delete mode 100755 qpid/python/examples/fanout/listener.py
 delete mode 100644 qpid/python/examples/fanout/verify
 delete mode 100644 qpid/python/examples/fanout/verify.in
 delete mode 100755 qpid/python/examples/headers/declare_queues.py
 delete mode 100755 qpid/python/examples/headers/headers_consumer.py
 delete mode 100755 qpid/python/examples/headers/headers_producer.py
 delete mode 100644 qpid/python/examples/headers/verify
 delete mode 100644 qpid/python/examples/headers/verify.in
 delete mode 100755 qpid/python/examples/pubsub/topic_publisher.py
 delete mode 100755 qpid/python/examples/pubsub/topic_subscriber.py
 delete mode 100644 qpid/python/examples/pubsub/verify
 delete mode 100644 qpid/python/examples/pubsub/verify.in
 delete mode 100755 qpid/python/examples/request-response/client.py
 delete mode 100755 qpid/python/examples/request-response/server.py
 delete mode 100644 qpid/python/examples/request-response/verify
 delete mode 100644 qpid/python/examples/request-response/verify.in
 delete mode 100755 qpid/python/examples/xml-exchange/declare_queues.py
 delete mode 100755 qpid/python/examples/xml-exchange/listener.py
 delete mode 100644 qpid/python/examples/xml-exchange/verify
 delete mode 100644 qpid/python/examples/xml-exchange/verify.in
 delete mode 100755 qpid/python/examples/xml-exchange/xml_consumer.py
 delete mode 100755 qpid/python/examples/xml-exchange/xml_producer.py

diff --git a/qpid/cpp/examples/README.verify b/qpid/cpp/examples/README.verify
index 6d9d67b..e137076 100644
--- a/qpid/cpp/examples/README.verify
+++ b/qpid/cpp/examples/README.verify
@@ -22,14 +22,12 @@ For more information read examples/README.
 
 == The Verify All Script ==
 
-The verify_all script will run C++ examples against itself and against the
-Python examples. The success of the script is determined by comparing its output
+The verify_all script will run each C++ example and compare its output
 against what is expected.
 
 === Arguments ===
 
-The verify_all script expects the path to Qpid trunk as an argument, in order to
-setup the environment for Python examples.
+The verify_all script expects the path to Qpid trunk as an argument.
 
 == The Verify Script ==
 
diff --git a/qpid/cpp/examples/direct/verify_cpp_python b/qpid/cpp/examples/direct/verify_cpp_python
deleted file mode 100644
index 4dc445b..0000000
--- a/qpid/cpp/examples/direct/verify_cpp_python
+++ /dev/null
@@ -1,4 +0,0 @@
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify
-py=$PYTHON_EXAMPLES/direct
-clients ./declare_queues ./direct_producer $py/direct_consumer.py
-outputs  ./declare_queues.out ./direct_producer.out $py/direct_consumer.py.out
diff --git a/qpid/cpp/examples/direct/verify_cpp_python.in b/qpid/cpp/examples/direct/verify_cpp_python.in
deleted file mode 100644
index 1a329be..0000000
--- a/qpid/cpp/examples/direct/verify_cpp_python.in
+++ /dev/null
@@ -1,14 +0,0 @@
-==== declare_queues.out
-==== direct_producer.out
-==== direct_consumer.py.out
-Message 0
-Message 1
-Message 2
-Message 3
-Message 4
-Message 5
-Message 6
-Message 7
-Message 8
-Message 9
-That's all, folks!
diff --git a/qpid/cpp/examples/direct/verify_python_cpp b/qpid/cpp/examples/direct/verify_python_cpp
deleted file mode 100644
index fe4893e..0000000
--- a/qpid/cpp/examples/direct/verify_python_cpp
+++ /dev/null
@@ -1,5 +0,0 @@
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-py=$PYTHON_EXAMPLES/direct
-clients $py/declare_queues.py $py/direct_producer.py  ./listener
-outputs $py/declare_queues.py.out $py/direct_producer.py.out ./listener.out
-
diff --git a/qpid/cpp/examples/direct/verify_python_cpp.in b/qpid/cpp/examples/direct/verify_python_cpp.in
deleted file mode 100644
index 6f35255..0000000
--- a/qpid/cpp/examples/direct/verify_python_cpp.in
+++ /dev/null
@@ -1,15 +0,0 @@
-==== declare_queues.py.out
-==== direct_producer.py.out
-==== listener.out
-Message: message 0
-Message: message 1
-Message: message 2
-Message: message 3
-Message: message 4
-Message: message 5
-Message: message 6
-Message: message 7
-Message: message 8
-Message: message 9
-Message: That's all, folks!
-Shutting down listener for message_queue
diff --git a/qpid/cpp/examples/fanout/verify_cpp_python b/qpid/cpp/examples/fanout/verify_cpp_python
deleted file mode 100644
index 6a1ba7a..0000000
--- a/qpid/cpp/examples/fanout/verify_cpp_python
+++ /dev/null
@@ -1,7 +0,0 @@
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-py=$PYTHON_EXAMPLES/fanout
-background "Subscribed"  $py/fanout_consumer.py
-background "Subscribed"  $py/fanout_consumer.py
-clients ./fanout_producer
-outputs ./fanout_producer.out "$py/fanout_consumer.py.out | remove_uuid" "$py/fanout_consumer.pyX.out | remove_uuid"
-
diff --git a/qpid/cpp/examples/fanout/verify_cpp_python.in b/qpid/cpp/examples/fanout/verify_cpp_python.in
deleted file mode 100644
index 21bafe0..0000000
--- a/qpid/cpp/examples/fanout/verify_cpp_python.in
+++ /dev/null
@@ -1,27 +0,0 @@
-==== fanout_producer.out
-==== fanout_consumer.py.out | remove_uuid
-Subscribed to queue 
-Message 0
-Message 1
-Message 2
-Message 3
-Message 4
-Message 5
-Message 6
-Message 7
-Message 8
-Message 9
-That's all, folks!
-==== fanout_consumer.pyX.out | remove_uuid
-Subscribed to queue 
-Message 0
-Message 1
-Message 2
-Message 3
-Message 4
-Message 5
-Message 6
-Message 7
-Message 8
-Message 9
-That's all, folks!
diff --git a/qpid/cpp/examples/fanout/verify_python_cpp b/qpid/cpp/examples/fanout/verify_python_cpp
deleted file mode 100644
index d9b3361..0000000
--- a/qpid/cpp/examples/fanout/verify_python_cpp
+++ /dev/null
@@ -1,7 +0,0 @@
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-py=$PYTHON_EXAMPLES/fanout
-background "Listening" ./listener
-background "Listening" ./listener
-clients $py/fanout_producer.py
-outputs $py/fanout_producer.py.out "./listener.out | remove_uuid" "./listenerX.out | remove_uuid"
-
diff --git a/qpid/cpp/examples/fanout/verify_python_cpp.in b/qpid/cpp/examples/fanout/verify_python_cpp.in
deleted file mode 100644
index 8f9e959..0000000
--- a/qpid/cpp/examples/fanout/verify_python_cpp.in
+++ /dev/null
@@ -1,29 +0,0 @@
-==== fanout_producer.py.out
-==== listener.out | remove_uuid
-Listening
-Message: message 0
-Message: message 1
-Message: message 2
-Message: message 3
-Message: message 4
-Message: message 5
-Message: message 6
-Message: message 7
-Message: message 8
-Message: message 9
-Message: That's all, folks!
-Shutting down listener for 
-==== listenerX.out | remove_uuid
-Listening
-Message: message 0
-Message: message 1
-Message: message 2
-Message: message 3
-Message: message 4
-Message: message 5
-Message: message 6
-Message: message 7
-Message: message 8
-Message: message 9
-Message: That's all, folks!
-Shutting down listener for 
diff --git a/qpid/cpp/examples/pub-sub/verify_cpp_python b/qpid/cpp/examples/pub-sub/verify_cpp_python
deleted file mode 100644
index f6c6850..0000000
--- a/qpid/cpp/examples/pub-sub/verify_cpp_python
+++ /dev/null
@@ -1,6 +0,0 @@
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-py=$PYTHON_EXAMPLES/pubsub
-background "Queues created" $py/topic_subscriber.py
-clients ./topic_publisher
-outputs ./topic_publisher.out "$py/topic_subscriber.py.out | remove_uuid | sort"
-
diff --git a/qpid/cpp/examples/pub-sub/verify_cpp_python.in b/qpid/cpp/examples/pub-sub/verify_cpp_python.in
deleted file mode 100644
index 951d9ad..0000000
--- a/qpid/cpp/examples/pub-sub/verify_cpp_python.in
+++ /dev/null
@@ -1,55 +0,0 @@
-==== topic_publisher.out
-==== topic_subscriber.py.out | remove_uuid | sort
-Message 0
-Message 0
-Message 0
-Message 0
-Message 0
-Message 0
-Message 0
-Message 0
-Message 1
-Message 1
-Message 1
-Message 1
-Message 1
-Message 1
-Message 1
-Message 1
-Message 2
-Message 2
-Message 2
-Message 2
-Message 2
-Message 2
-Message 2
-Message 2
-Message 3
-Message 3
-Message 3
-Message 3
-Message 3
-Message 3
-Message 3
-Message 3
-Message 4
-Message 4
-Message 4
-Message 4
-Message 4
-Message 4
-Message 4
-Message 4
-Messages on 'europe' queue:
-Messages on 'news' queue:
-Messages on 'usa' queue:
-Messages on 'weather' queue:
-Queues created - please start the topic producer
-Subscribing local queue 'local_europe' to europe-'
-Subscribing local queue 'local_news' to news-'
-Subscribing local queue 'local_usa' to usa-'
-Subscribing local queue 'local_weather' to weather-'
-That's all, folks!
-That's all, folks!
-That's all, folks!
-That's all, folks!
diff --git a/qpid/cpp/examples/pub-sub/verify_python_cpp b/qpid/cpp/examples/pub-sub/verify_python_cpp
deleted file mode 100644
index 2ddaad5..0000000
--- a/qpid/cpp/examples/pub-sub/verify_python_cpp
+++ /dev/null
@@ -1,6 +0,0 @@
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-py=$PYTHON_EXAMPLES/pubsub
-background "Listening" ./topic_listener
-clients $py/topic_publisher.py
-outputs $py/topic_publisher.py.out "topic_listener.out | remove_uuid | sort"
-
diff --git a/qpid/cpp/examples/pub-sub/verify_python_cpp.in b/qpid/cpp/examples/pub-sub/verify_python_cpp.in
deleted file mode 100644
index f2871eb..0000000
--- a/qpid/cpp/examples/pub-sub/verify_python_cpp.in
+++ /dev/null
@@ -1,59 +0,0 @@
-==== topic_publisher.py.out
-==== topic_listener.out | remove_uuid | sort
-Declaring queue: europe
-Declaring queue: news
-Declaring queue: usa
-Declaring queue: weather
-Listening for messages ...
-Message: That's all, folks! from europe
-Message: That's all, folks! from news
-Message: That's all, folks! from usa
-Message: That's all, folks! from weather
-Message: europe.news 0 from europe
-Message: europe.news 0 from news
-Message: europe.news 1 from europe
-Message: europe.news 1 from news
-Message: europe.news 2 from europe
-Message: europe.news 2 from news
-Message: europe.news 3 from europe
-Message: europe.news 3 from news
-Message: europe.news 4 from europe
-Message: europe.news 4 from news
-Message: europe.weather 0 from europe
-Message: europe.weather 0 from weather
-Message: europe.weather 1 from europe
-Message: europe.weather 1 from weather
-Message: europe.weather 2 from europe
-Message: europe.weather 2 from weather
-Message: europe.weather 3 from europe
-Message: europe.weather 3 from weather
-Message: europe.weather 4 from europe
-Message: europe.weather 4 from weather
-Message: usa.news 0 from news
-Message: usa.news 0 from usa
-Message: usa.news 1 from news
-Message: usa.news 1 from usa
-Message: usa.news 2 from news
-Message: usa.news 2 from usa
-Message: usa.news 3 from news
-Message: usa.news 3 from usa
-Message: usa.news 4 from news
-Message: usa.news 4 from usa
-Message: usa.weather 0 from usa
-Message: usa.weather 0 from weather
-Message: usa.weather 1 from usa
-Message: usa.weather 1 from weather
-Message: usa.weather 2 from usa
-Message: usa.weather 2 from weather
-Message: usa.weather 3 from usa
-Message: usa.weather 3 from weather
-Message: usa.weather 4 from usa
-Message: usa.weather 4 from weather
-Shutting down listener for europe
-Shutting down listener for news
-Shutting down listener for usa
-Shutting down listener for weather
-Subscribing to queue europe
-Subscribing to queue news
-Subscribing to queue usa
-Subscribing to queue weather
diff --git a/qpid/cpp/examples/request-response/verify_cpp_python b/qpid/cpp/examples/request-response/verify_cpp_python
deleted file mode 100644
index 867af3a..0000000
--- a/qpid/cpp/examples/request-response/verify_cpp_python
+++ /dev/null
@@ -1,6 +0,0 @@
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-background "Request server running" $PYTHON_EXAMPLES/request-response/server.py
-clients ./client
-sleep 1
-kill %% 			# Must kill the server.
-outputs "./client.out | remove_uuid" "$PYTHON_EXAMPLES/request-response/server.py.out | remove_uuid"
diff --git a/qpid/cpp/examples/request-response/verify_cpp_python.in b/qpid/cpp/examples/request-response/verify_cpp_python.in
deleted file mode 100644
index a032293..0000000
--- a/qpid/cpp/examples/request-response/verify_cpp_python.in
+++ /dev/null
@@ -1,15 +0,0 @@
-==== client.out | remove_uuid
-Activating response queue listener for: client
-Request: Twas brillig, and the slithy toves
-Request: Did gire and gymble in the wabe.
-Request: All mimsy were the borogroves,
-Request: And the mome raths outgrabe.
-Waiting for all responses to arrive ...
-Response: TWAS BRILLIG, AND THE SLITHY TOVES
-Response: DID GIRE AND GYMBLE IN THE WABE.
-Response: ALL MIMSY WERE THE BOROGROVES,
-Response: AND THE MOME RATHS OUTGRABE.
-Shutting down listener for client
-==== server.py.out | remove_uuid
-Request server running - run your client now.
-(Times out after 100 seconds ...)
diff --git a/qpid/cpp/examples/request-response/verify_python_cpp b/qpid/cpp/examples/request-response/verify_python_cpp
deleted file mode 100644
index d6f0fa7..0000000
--- a/qpid/cpp/examples/request-response/verify_python_cpp
+++ /dev/null
@@ -1,5 +0,0 @@
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-background "Waiting" ./server
-clients $PYTHON_EXAMPLES/request-response/client.py
-kill %% 			# Must kill the server.
-outputs "$PYTHON_EXAMPLES/request-response/client.py.out | remove_uuid" "server.out | remove_uuid"
diff --git a/qpid/cpp/examples/request-response/verify_python_cpp.in b/qpid/cpp/examples/request-response/verify_python_cpp.in
deleted file mode 100644
index 1500134..0000000
--- a/qpid/cpp/examples/request-response/verify_python_cpp.in
+++ /dev/null
@@ -1,18 +0,0 @@
-==== client.py.out | remove_uuid
-Request: Twas brillig, and the slithy toves
-Request: Did gyre and gimble in the wabe.
-Request: All mimsy were the borogroves,
-Request: And the mome raths outgrabe.
-Messages on queue: reply_to:
-Response: TWAS BRILLIG, AND THE SLITHY TOVES
-Response: DID GYRE AND GIMBLE IN THE WABE.
-Response: ALL MIMSY WERE THE BOROGROVES,
-Response: AND THE MOME RATHS OUTGRABE.
-No more messages!
-==== server.out | remove_uuid
-Activating request queue listener for: request
-Waiting for requests
-Request: Twas brillig, and the slithy toves  (reply_to:)
-Request: Did gyre and gimble in the wabe.  (reply_to:)
-Request: All mimsy were the borogroves,  (reply_to:)
-Request: And the mome raths outgrabe.  (reply_to:)
diff --git a/qpid/cpp/examples/verify_all b/qpid/cpp/examples/verify_all
index 9d71c74..cb4c528 100755
--- a/qpid/cpp/examples/verify_all
+++ b/qpid/cpp/examples/verify_all
@@ -19,8 +19,7 @@
 # under the License.
 #
 
-# Verify all C++/python example combinations.
-#
+# Verify all examples
 
 verify=`dirname $0`/verify
 topsrcdir=$1
@@ -28,20 +27,13 @@ topbuilddir=$2
 qpidd=$topbuilddir/src/qpidd
 broker_args=$3
 exclude_regexp=$4
-python=${QPID_PYTHON_DIR:-$topsrcdir/python}
 
 trap "$qpidd -q" exit
 QPID_PORT=`$qpidd -dp0 $broker_args` || { echo "Can't run qpidd" ; exit 1; }
-PYTHON_EXAMPLES=$python/examples
-PYTHONPATH=$python:$PYTHONPATH
-export QPID_PORT PYTHON_EXAMPLES PYTHONPATH
+export QPID_PORT
 
-test -d $PYTHON_EXAMPLES || echo "WARNING: No python examples. $PYTHON_EXAMPLES not found."
 find="find $topsrcdir/cpp/examples"
-test -d $PYTHON_EXAMPLES && find="$find $PYTHON_EXAMPLES"
 find="$find -mindepth 2 -name verify"
-test -d $PYTHON_EXAMPLES && \
-    find="$find -o -name verify_cpp_python -o -name verify_python_cpp"
 all_examples=`$find`
 
 if test -z "$exclude_regexp"; then
diff --git a/qpid/python/examples/README b/qpid/python/examples/README
index bd30b2a..4395160 100644
--- a/qpid/python/examples/README
+++ b/qpid/python/examples/README
@@ -1,319 +1,42 @@
-Running the Python Examples
-============================
+The Python Examples
+===================
 
+README.txt                 -- This file.
 
-Running the Direct Examples
-----------------------------
+api                        -- Directory containing drain, spout,
+                              sever, hello, and hello_xml examples.
 
-To run the direct examples, do the following:
+api/drain                  -- A simple messaging client that prints
+                              messages from the source specified on
+                              the command line.
 
-1. Make sure that a qpidd broker is running:
+api/spout                  -- A simple messaging client that sends
+                              messages to the target specified on the
+                              command line.
 
- $ ps -eaf | grep qpidd
+api/server                 -- An example server that process incoming
+                              messages and sends replies.
 
-  If a broker is running, you should see the qpidd process in the output of the above command. 
+api/hello                  -- An example client that sends a message
+                              and then receives it.
 
-2.Declare a message queue and bind it to an exchange by running declare_queues.py, as follows:
+api/hello_xml              -- An example client that sends a message
+                              to the xml exchange and then receives
+                              it.
 
- $ python declare_queues.py
 
- This program has no output. After this program has been run, all messages sent to the amq.direct exchange using the routing key routing_key are sent to the queue named message_queue.
+reservations               -- Directory containing an example machine
+                              reservation system.
 
-3.Publish a series of messages to the amq.direct exchange by running direct_producer.py, as follows:
+reservations/common.py     -- Utility code used by reserve,
+                              machine-agent, and inventory scripts.
 
- $ python direct_producer.py
+reservations/reserve       -- Messaging client for listing, reserving,
+                              and releasing machines.
 
-This program has no output; the messages are routed to the message queue, as instructed by the binding.
+reservations/machine-agent -- Messaging server that tracks and reports
+                              on the status of its host machine and
+                              listens for reservation requests.
 
-4. Read the messages from the message queue using direct_consumer.py or listener.py, as follows:
-
- $ python direct_consumer.py
-
- or
-
- $ python listener.py
-
-You should see the following output:
-
-message 0
-message 1
-message 2
-message 3
-message 4
-message 5
-message 6
-message 7
-message 8
-message 9
-That's all, folks!
-
-
-
-Running the Fanout Examples
-----------------------------
-
-To run the programs for the Fanout example, do the following:
-
-1. Make sure that a qpidd broker is running:
-
-  $ ps -eaf | grep qpidd
-
-If a broker is running, you should see the qpidd process in the output of the above command.  
-
-2. In separate windows, start two or more fanout consumers or fanout listeners as follows:
-
-  $ python fanout_consumer.py
-
-  or
-
-  $ python listener.py
-
-These programs each create a private queue, bind it to the amq.fanout exchange, and wait for messages to arrive on their queue.
-
-3. In a separate window, publish a series of messages to the amq.fanout exchange by running fanout_producer.py, as follows:
-
-  $ python fanout_producer.py
-
-This program has no output; the messages are routed to the message queue, as instructed by the binding.
- 
-4. Go to the windows where you are running consumers or listeners. You should see the following output for each listener or consumer:
-
-      message 0
-      message 1
-      message 2
-      message 3
-      message 4
-      message 5
-      message 6
-      message 7
-      message 8
-      message 9
-      That's all, folks!
-
-
-
-Running the Publish-Subscribe Examples
----------------------------------------
-
-To run the programs for the Publish-Subscribe example, do the following:
-
-1. Make sure that a qpidd broker is running:
-
-  $ ps -eaf | grep qpidd
-
-If a broker is running, you should see the qpidd process in the output of the above command. 
-
-2. In separate windows, start one or more topic subscribers by running topic_subscriber.py, as follows:
-
-  $ python topic_subscriber.py
-
-You will see output similar to this:
-
-  Queues created - please start the topic producer
-  Subscribing local queue 'local_news' to news-53408183-fcee-4b92-950b-90abb297e739'
-  Subscribing local queue 'local_weather' to weather-53408183-fcee-4b92-950b-90abb297e739'
-  Subscribing local queue 'local_usa' to usa-53408183-fcee-4b92-950b-90abb297e739'
-  Subscribing local queue 'local_europe' to europe-53408183-fcee-4b92-950b-90abb297e739'
-  Messages on 'news' queue:
-
-Each topic consumer creates a set of private queues, and binds each queue to the amq.topic exchange together with a binding that indicates which messages should be routed to the queue.
-
-3.In another window, start the topic publisher, which publishes messages to the amq.topic exchange, as follows:
-
-  $ python topic_publisher.py
-
-This program has no output; the messages are routed to the message queues for each topic_consumer as specified by the bindings the consumer created.
-
-4. Go back to the window for each topic consumer. You should see output like this:
-
-      Messages on 'news' queue:
-      usa.news 0
-      usa.news 1
-      usa.news 2
-      usa.news 3
-      usa.news 4
-      europe.news 0
-      europe.news 1
-      europe.news 2
-      europe.news 3
-      europe.news 4
-      That's all, folks!
-      Messages on 'weather' queue:
-      usa.weather 0
-      usa.weather 1
-      usa.weather 2
-      usa.weather 3
-      usa.weather 4
-      europe.weather 0
-      europe.weather 1
-      europe.weather 2
-      europe.weather 3
-      europe.weather 4
-      That's all, folks!
-      Messages on 'usa' queue:
-      usa.news 0
-      usa.news 1
-      usa.news 2
-      usa.news 3
-      usa.news 4
-      usa.weather 0
-      usa.weather 1
-      usa.weather 2
-      usa.weather 3
-      usa.weather 4
-      That's all, folks!
-      Messages on 'europe' queue:
-      europe.news 0
-      europe.news 1
-      europe.news 2
-      europe.news 3
-      europe.news 4
-      europe.weather 0
-      europe.weather 1
-      europe.weather 2
-      europe.weather 3
-      europe.weather 4
-      That's all, folks!
-
-
-Running the Request/Response Examples
---------------------------------------
-
-To run the programs for the Request/Response example, do the following:
-
-1. Make sure that a qpidd broker is running:
-
-  $ ps -eaf | grep qpidd
-
-If a broker is running, you should see the qpidd process in the output of the above command.
-
-2. Run the server.
-
-  $ python server.py
-
-You should see the following output:
-
-  Request server running - run your client now.
-  (Times out after 100 seconds ...)
-
-3. In a separate window, start a client:
-
-  $ python client.py
-
-You should see the following output:
-
-      Request: Twas brillig, and the slithy toves
-      Request: Did gyre and gimble in the wabe.
-      Request: All mimsy were the borogroves,
-      Request: And the mome raths outgrabe.
-      Messages on queue: reply_to:db0f862e-6b36-4e0f-a4b2-ad049eb435ce
-      Response: TWAS BRILLIG, AND THE SLITHY TOVES
-      Response: DID GYRE AND GIMBLE IN THE WABE.
-      Response: ALL MIMSY WERE THE BOROGROVES,
-      Response: AND THE MOME RATHS OUTGRABE.
-      No more messages!
-
-
-Running the XML-based Routing Examples
----------------------------------------
-
-To run the programs for the XML-based Routing example, do the following:
-
-1. Make sure that a qpidd broker is running:
-
-  $ ps -eaf | grep qpidd
-
-If a broker is running, you should see the qpidd process in the output of the above command.
-
-2. Declare an XML exchange and a message queue, then bind the queue to the exchange by running declare_queues.py, as follows:
-
-  $ python declare_queues.py
-
-This program has no output. After this program has been run, all messages sent to the xml exchange using the routing key weather are sent to the queue named message_queue if they satisfy the conditions specified in the following XQuery, which is used in the binding:
-
- let $w := ./weather
- return $w/station = 'Raleigh-Durham International Airport (KRDU)'
-    and $w/temperature_f > 50
-    and $w/temperature_f - $w/dewpoint > 5
-    and $w/wind_speed_mph > 7
-    and $w/wind_speed_mph < 20
-
-3. Publish a series of messages to the xml exchange by running xml_producer.py, as follows:
-
-  $ python xml_producer.py
-
-The messages are routed to the message queue, as prescribed by the binding. Each message represents a weather report, such as this one:
-
-  <weather>
-      <station>Raleigh-Durham International Airport (KRDU)</station>
-      <wind_speed_mph>16</wind_speed_mph>
-      <temperature_f>70</temperature_f>
-      <dewpoint>35</dewpoint>
-  </weather>
-
-4. Read the messages from the message queue using direct_consumer.py or listener.py, as follows:
-
-  $ python xml_consumer.py
-
-  or
-
-  $ python listener.py
-
-You should see the following output:
-
-<weather><station>Raleigh-Durham International Airport (KRDU)</station>
-<wind_speed_mph>16</wind_speed_mph><temperature_f>70</temperature_f>
-<dewpoint>35</dewpoint></weather>
-
-
-Running the Headers Examples
------------------------------
-
-To run the headers examples, do the following:
-
-1. Make sure that a qpidd broker is running:
-
- $ ps -eaf | grep qpidd
-
-  If a broker is running, you should see the qpidd process in the output of the above command. 
-
-2.Declare a message queues and bind them to an exchange by running declare_queues.py, as follows:
-
- $ python declare_queues.py
-
- This program has no output. After this program has been run, all messages sent to the amq.match exchange with an application-header of {'class': 'first'} will be routed to the queue named "first" and messages with an application-header of {'class': 'second'} will be routed to the queue named "second".
-
-3.Publish a series of messages to the amq.match exchange by running headers_producer.py, as follows:
-
- $ python headers_producer.py
-
-This program has no output; the messages are routed to the message queues, as instructed by the bindings.
-
-4. Read the messages from the message queues using headers_consumer.py as follows:
-
- $ python headers_consumer.py
-
-You should see the following output:
-
-message(first) 0
-message(first) 1
-message(first) 2
-message(first) 3
-message(first) 4
-message(first) 5
-message(first) 6
-message(first) 7
-message(first) 8
-message(first) 9
-That's all, folks!
-message(second) 0
-message(second) 1
-message(second) 2
-message(second) 3
-message(second) 4
-message(second) 5
-message(second) 6
-message(second) 7
-message(second) 8
-message(second) 9
-That's all, folks!
+reservations/inventory     -- Messaging server that tracks the last
+                              known status of machines.
diff --git a/qpid/python/examples/datatypes/client.py b/qpid/python/examples/datatypes/client.py
deleted file mode 100755
index 088e529..0000000
--- a/qpid/python/examples/datatypes/client.py
+++ /dev/null
@@ -1,122 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- client.py
-
- Client for testing use of Unicode and datatypes.
-
- Both client and server will be written in C++ and Python.
- Tests can run clients and servers written in different
- languages, and they can be run on 32-bit and 64-bit architectures.
-
-"""
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-import testdata
-
-#----- Initialization --------------------------------------
-
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-
-#----- Main Body -- ----------------------------------------
-
-# Create a response queue for the server to send responses to. Use the
-# same string as the name of the queue and the name of the routing
-# key.
-
-reply_to = "reply_to:" + session.name
-session.queue_declare(queue=reply_to, exclusive=True)
-session.exchange_bind(exchange="amq.direct", queue=reply_to, binding_key=reply_to)
-
-# Create a local queue and subscribe it to the response queue
-
-local_queue_name = "local_queue"
-queue = session.incoming(local_queue_name)
-
-# Call message_subscribe() to tell the broker to deliver messages from
-# the server's reply_to queue to our local client queue. The server
-# will start delivering messages as soon as message credit is
-# available.
-
-session.message_subscribe(queue=reply_to, destination=local_queue_name)
-queue.start()
-
-# Set up the properties. Perhaps a few application headers?
-
-delivery_properties = session.delivery_properties(routing_key="request")
-
-message_properties = session.message_properties()
-
-message_properties.content_encoding="text/plain; charset='utf-8'"
-
-testdata.set_application_headers(message_properties)
-message_properties.reply_to = session.reply_to("amq.direct", reply_to)
-
-# deliver the message - remember to encode the Unicode string!
-request = Message(message_properties, delivery_properties, testdata.String_Greek.encode("utf8"))
-session.message_transfer(destination="amq.direct", message=request)
-
-# Now see what messages the server sent to our reply_to queue
-
-try:
-  response = queue.get(timeout=10)
-  content = response.body
-  session.message_accept(RangedSet(response.id))
-  testdata.check_message(response)
-  print "Response: " + content
-except Empty:
-  print "No more messages!"
-  exit(1)
-except:
-  print "Unexpected exception!"
-  exit(1)
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/datatypes/server.py b/qpid/python/examples/datatypes/server.py
deleted file mode 100755
index 18e6fa4..0000000
--- a/qpid/python/examples/datatypes/server.py
+++ /dev/null
@@ -1,124 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- server.py
-
- Server for testing use of Unicode and datatypes.
-
- Both client and server will be written in C++ and Python.
- Tests can run clients and servers written in different
- languages, and they can be run on 32-bit and 64-bit architectures.
-"""
-
-import testdata
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-#----- Functions -------------------------------------------
-def respond(session, request):
-
-    # The routing key for the response is the request's reply-to
-    # property.  The body for the response is the request's body,
-    # converted to upper case.
-
-    testdata.check_message(request)
-
-    message_properties = request.get("message_properties")
-    reply_to = message_properties.reply_to
-
-    testdata.set_application_headers(message_properties)
-
-    if reply_to == None:
-       raise Exception("This message is missing the 'reply_to' property, which is required")   
-   
-    delivery_properties = session.delivery_properties(routing_key=reply_to["routing_key"]) 
-    response = Message(delivery_properties, message_properties, testdata.String_Greek.encode("utf8"))
-    print "Sending response ..."
-    session.message_transfer(destination=reply_to["exchange"], message=response)
-
-#----- Initialization --------------------------------------
-
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Main Body -- ----------------------------------------
-
-# Create a request queue and subscribe to it
-
-session.queue_declare(queue="request", exclusive=True)
-session.exchange_bind(exchange="amq.direct", queue="request", binding_key="request")
-
-local_queue_name = "local_queue"
-
-session.message_subscribe(queue="request", destination=local_queue_name)
-
-queue = session.incoming(local_queue_name)
-queue.start()
-
-# Remind the user to start the client program
-
-print "Request server running - run your client now."
-print "(Times out after 100 seconds ...)"
-sys.stdout.flush()
-
-# Respond to each request
-
-# If we get a message, send it back to the user (as indicated in the
-# ReplyTo property)
-
-while True:
-  try:
-    request = queue.get(timeout=100)
-    session.message_accept(RangedSet(request.id))
-
-    respond(session, request)
-  except Empty:
-    print "No more messages!"
-    break;
-
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/datatypes/testdata.py b/qpid/python/examples/datatypes/testdata.py
deleted file mode 100644
index 251872f..0000000
--- a/qpid/python/examples/datatypes/testdata.py
+++ /dev/null
@@ -1,201 +0,0 @@
-#
-# 
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-# 
-#
-
-# -*- encoding: utf-8 -*-
-
-from qpid.datatypes import uuid4, timestamp
-
-#----- Some variables to test boundary conditions on various data types
-
-void = None
-boolean_true = True
-boolean_false = False
-Uint8_0 = 0
-Uint8_max = 255
-Uint16_0 = 0
-Uint16_max = 65535
-Uint32_0 = 0
-Uint32_max = 4294967295
-Uint64_0 = 0
-Uint64_max = 18446744073709551615
-Int8_min = -128
-Int8_0 = 0
-Int8_max = 127
-Int16_min = -32768
-Int16_0 = 0
-Int16_max = 32767
-Int32_min = -2147483648
-Int32_0 = 0
-Int32_max = 2147483647
-Int64_min = -9223372036854775808
-Int64_0 = 0
-Int64_max = 9223372036854775807
-
-Float_pi = 3.14159265
-Float_neg = -1E4
-Float_big = 1267.43233E12
-Float_small = 12.78e-12
-Float_neg0 = -0
-Float_pos0 = 0
-Float_INF = float('inf')
-Float_Negative_INF = float('-inf')
-
-Double_pi = 3.1415926535897932384626433832795
-Double_neg = -1E4
-Double_big = 1267.43233E12
-Double_small = 12.78e-2
-Double_neg0 = -0
-Double_pos0 = 0
-Double_INF = float('inf')
-Double_Negative_INF = float('-inf')
-
-char_1byte = u'0024' # $
-char_2byte = u'00A2' # 
-char_3byte = u'20AC' # 
-char_4byte = u'10ABCD'
-
-timestamp = timestamp()
-
-UUID = uuid4()
-
-String_Greek = u"    ,    ,    ;"
-
-String_Empty = ""
-
-#----- A few functions ----------------------------------------------------------
-
-def near_enough(float1, float2, delta):
-  return abs(float1-float2) < delta
-
-def set_application_headers(message_properties):
-
-  message_properties.application_headers = {}
-  message_properties.application_headers["void"] = None
-  message_properties.application_headers["boolean_true"] =  boolean_true
-  message_properties.application_headers["boolean_false"] = boolean_false
-  message_properties.application_headers["Uint8_0"] = Uint8_0
-  message_properties.application_headers["Uint8_max"] = Uint8_max
-  message_properties.application_headers["Uint16_0"] = Uint16_0
-  message_properties.application_headers["Uint16_max"] = Uint16_max
-  message_properties.application_headers["Uint32_0"] = Uint32_0
-  message_properties.application_headers["Uint32_max"] = Uint32_max
-  message_properties.application_headers["Uint64_0"] = Uint64_0
-#  message_properties.application_headers["Uint64_max"] = Uint64_max
-  message_properties.application_headers["Int8_min"] = Int8_min
-  message_properties.application_headers["Int8_0"] = Int8_0
-  message_properties.application_headers["Int8_max"] = Int8_max
-  message_properties.application_headers["Int16_min"] = Int16_min
-  message_properties.application_headers["Int16_0"] = Int16_0
-  message_properties.application_headers["Int16_max"] = Int16_max
-  message_properties.application_headers["Int32_min"] = Int32_min
-  message_properties.application_headers["Int32_0"] = Int32_0
-  message_properties.application_headers["Int32_max"] = Int32_max
-  message_properties.application_headers["Int64_min"] = Int64_min
-  message_properties.application_headers["Int64_0"] = Int64_0
-  message_properties.application_headers["Int64_max"] = Int64_max
- 
-  message_properties.application_headers["Float_pi"] = Float_pi
-  message_properties.application_headers["Float_neg"] = Float_neg
-  message_properties.application_headers["Float_big"] = Float_big
-  message_properties.application_headers["Float_small"] = Float_small
-  message_properties.application_headers["Float_neg0"] = Float_neg0
-  message_properties.application_headers["Float_pos0"] = Float_pos0
-  message_properties.application_headers["Float_INF"] = Float_INF
-  message_properties.application_headers["Float_Negative_INF"] = Float_Negative_INF
-
-  message_properties.application_headers["Double_pi"] = Double_pi
-  message_properties.application_headers["Double_neg"] = Double_neg
-  message_properties.application_headers["Double_big"] = Double_big
-  message_properties.application_headers["Double_small"] = Double_small
-  message_properties.application_headers["Double_neg0"] = Double_neg0
-  message_properties.application_headers["Double_pos0"] = Double_pos0
-  message_properties.application_headers["Double_INF"] = Double_INF
-  message_properties.application_headers["Double_Negative_INF"] = Double_Negative_INF
-
-  message_properties.application_headers["char_1byte"] = char_1byte
-  message_properties.application_headers["char_2byte"] = char_2byte
-  message_properties.application_headers["char_3byte"] = char_3byte
-  message_properties.application_headers["char_4byte"] = char_4byte
-
-  message_properties.application_headers["timestamp"] = timestamp
-  message_properties.application_headers["UUID"] = uuid4() 
-  message_properties.application_headers["String_Greek"] = String_Greek 
-  message_properties.application_headers["String_Empty"] = String_Empty
-
-def check_message(message):
-
-#  message_properties = message.message_properties()
-  message_properties = message.get("message_properties")
-  assert message_properties.application_headers["void"] == None
-  assert message_properties.application_headers["boolean_true"] == boolean_true
-  assert message_properties.application_headers["boolean_false"] == boolean_false
-  assert message_properties.application_headers["Uint8_0"] == Uint8_0
-  assert message_properties.application_headers["Uint8_max"] == Uint8_max
-  assert message_properties.application_headers["Uint16_0"] == Uint16_0
-  assert message_properties.application_headers["Uint16_max"] == Uint16_max
-  assert message_properties.application_headers["Uint32_0"] == Uint32_0
-  assert message_properties.application_headers["Uint32_max"] == Uint32_max
-  assert message_properties.application_headers["Uint64_0"] == Uint64_0
-#  assert message_properties.application_headers["Uint64_max"] == Uint64_max
-  assert message_properties.application_headers["Int8_min"] == Int8_min
-  assert message_properties.application_headers["Int8_0"] == Int8_0
-  assert message_properties.application_headers["Int8_max"] == Int8_max
-  assert message_properties.application_headers["Int16_min"] == Int16_min
-  assert message_properties.application_headers["Int16_0"] == Int16_0
-  assert message_properties.application_headers["Int16_max"] == Int16_max
-  assert message_properties.application_headers["Int32_min"] == Int32_min
-  assert message_properties.application_headers["Int32_0"] == Int32_0
-  assert message_properties.application_headers["Int32_max"] == Int32_max
-  assert message_properties.application_headers["Int64_min"] == Int64_min
-  assert message_properties.application_headers["Int64_0"] == Int64_0
-  assert message_properties.application_headers["Int64_max"] == Int64_max
-  
-# Change floating point comparisons to allow inexactness
-
-  assert near_enough(message_properties.application_headers["Float_pi"], Float_pi, 0.00001)
-  assert near_enough(message_properties.application_headers["Float_neg"], Float_neg, 0.00001)
-  assert near_enough(message_properties.application_headers["Float_big"], Float_big, Float_big/1000000)
-  assert near_enough(message_properties.application_headers["Float_small"], Float_small, 0.00001)
-  assert message_properties.application_headers["Float_neg0"] == Float_neg0
-  assert message_properties.application_headers["Float_pos0"] == Float_pos0
-  assert message_properties.application_headers["Float_INF"] == Float_INF
-  assert message_properties.application_headers["Float_Negative_INF"] == Float_Negative_INF
-
-  assert near_enough(message_properties.application_headers["Double_pi"], Double_pi, 0.00001)
-  assert near_enough(message_properties.application_headers["Double_neg"], Double_neg, 0.00001)
-  assert near_enough(message_properties.application_headers["Double_big"], Double_big, Double_big/1000000)
-  assert near_enough(message_properties.application_headers["Double_small"], Double_small, 0.00001)
-  assert message_properties.application_headers["Double_neg0"] == Double_neg0
-  assert message_properties.application_headers["Double_pos0"] == Double_pos0
-  assert message_properties.application_headers["Double_INF"] == Double_INF
-  assert message_properties.application_headers["Double_Negative_INF"] == Double_Negative_INF
-
-  assert message_properties.application_headers["char_1byte"] == char_1byte
-  assert message_properties.application_headers["char_2byte"] == char_2byte
-  assert message_properties.application_headers["char_3byte"] == char_3byte
-  assert message_properties.application_headers["char_4byte"] == char_4byte
-
-#  assert message_properties.application_headers["timestamp"] == timestamp
-#  assert message_properties.application_headers["UUID"] == UUID
-  assert message_properties.application_headers["String_Greek"] == String_Greek
-  assert message_properties.application_headers["String_Empty"] == String_Empty
-
-
diff --git a/qpid/python/examples/direct/declare_queues.py b/qpid/python/examples/direct/declare_queues.py
deleted file mode 100755
index 13818ee..0000000
--- a/qpid/python/examples/direct/declare_queues.py
+++ /dev/null
@@ -1,76 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- declare_queues.py 
-
- Creates and binds a queue on an AMQP direct exchange.
-
- All messages using the routing key "routing_key" are
- sent to the queue named "message_queue".
-"""
-
-# Common includes
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-#----- Initialization -----------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Create a queue -------------------------------------
-
-# queue_declare() creates an AMQP queue, which is held
-# on the broker. Published messages are sent to the AMQP queue, 
-# from which messages are delivered to consumers. 
-# 
-# exchange_bind() determines which messages are routed to a queue. 
-# Route all messages with the binding key "routing_key" to
-# the AMQP queue named "message_queue".
-
-session.queue_declare(queue="message_queue")
-session.exchange_bind(exchange="amq.direct", queue="message_queue", binding_key="routing_key")
-
-#----- Cleanup ---------------------------------------------
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/direct/direct_consumer.py b/qpid/python/examples/direct/direct_consumer.py
deleted file mode 100755
index b07e53c..0000000
--- a/qpid/python/examples/direct/direct_consumer.py
+++ /dev/null
@@ -1,94 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- direct_consumer.py
-
- This AMQP client reads messages from a message
- queue named "message_queue".
-"""
-
-import qpid
-import sys
-import os
-from random import randint
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-
-#----- Initialization --------------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Read from queue --------------------------------------------
-
-# Now let's create a local client queue and tell it to read
-# incoming messages.
-
-# The consumer tag identifies the client-side queue.
-
-local_queue_name = "local_queue"
-queue = session.incoming(local_queue_name)
-
-# Call message_subscribe() to tell the broker to deliver messages
-# from the AMQP queue to this local client queue. The broker will
-# start delivering messages as soon as credit is allocated using
-# queue.start().
-
-session.message_subscribe(queue="message_queue", destination=local_queue_name)
-queue.start()
-
-#  Initialize 'final' and 'content', variables used to identify the last message.
-
-final = "That's all, folks!"   # In a message body, signals the last message
-content = ""		       # Content of the last message read
-
-message = None
-while content != final:
-	message = queue.get(timeout=10)
-	content = message.body          
-        session.message_accept(RangedSet(message.id))
-	print content
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-#
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/direct/direct_producer.py b/qpid/python/examples/direct/direct_producer.py
deleted file mode 100755
index fcbb467..0000000
--- a/qpid/python/examples/direct/direct_producer.py
+++ /dev/null
@@ -1,73 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- direct_producer.py
-
- Publishes messages to an AMQP direct exchange, using
- the routing key "routing_key"
-"""
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message
-from qpid.datatypes import uuid4
-from qpid.queue import Empty
-
-
-#----- Initialization -----------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Publish some messages ------------------------------
-
-# Create some messages and put them on the broker.
-props = session.delivery_properties(routing_key="routing_key")
-
-for i in range(10):
-     session.message_transfer(destination="amq.direct", message=Message(props,"message " + str(i)))
-
-session.message_transfer(destination="amq.direct", message=Message(props,"That's all, folks!"))
-
-#----- Cleanup --------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/direct/listener.py b/qpid/python/examples/direct/listener.py
deleted file mode 100755
index 9d06bd3..0000000
--- a/qpid/python/examples/direct/listener.py
+++ /dev/null
@@ -1,109 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- listener.py
-
- This AMQP client reads messages from a message
- queue named "message_queue". It is implemented
- as a message listener.
-"""
-
-# Common includes
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-# Includes specific to this example
-
-from time         import sleep
-
-
-#----- Message Receive Handler -----------------------------
-class Receiver:
-  def __init__ (self):
-    self.finalReceived = False
-
-  def isFinal (self):
-    return self.finalReceived
-    
-  def Handler (self, message):
-    content = message.body
-    session.message_accept(RangedSet(message.id)) 
-    print content
-    if content == "That's all, folks!":
-      self.finalReceived = True
-
-#----- Initialization --------------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Read from queue --------------------------------------------
-
-# Now let's create a local client queue and tell it to read
-# incoming messages.
-
-# The local_queue_name identifies the client-side queue.
-
-local_queue_name = "local_queue"
-queue = session.incoming(local_queue_name)
-
-# Call message_subscribe() to tell the broker to deliver messages
-# from the AMQP queue to this local client queue. The broker will
-# start delivering messages as soon as message_subscribe() is called.
-
-session.message_subscribe(queue="message_queue", destination=local_queue_name)
-queue.start()
-
-receiver = Receiver()
-queue.listen (receiver.Handler)
-
-while not receiver.isFinal() :
-  sleep (1)
-
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-#
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/direct/verify b/qpid/python/examples/direct/verify
deleted file mode 100644
index 92f87bf..0000000
--- a/qpid/python/examples/direct/verify
+++ /dev/null
@@ -1,22 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-clients ./declare_queues.py ./direct_producer.py ./direct_consumer.py
-outputs ./declare_queues.py.out ./direct_producer.py.out ./direct_consumer.py.out
diff --git a/qpid/python/examples/direct/verify.in b/qpid/python/examples/direct/verify.in
deleted file mode 100644
index 5e69161..0000000
--- a/qpid/python/examples/direct/verify.in
+++ /dev/null
@@ -1,14 +0,0 @@
-==== declare_queues.py.out
-==== direct_producer.py.out
-==== direct_consumer.py.out
-message 0
-message 1
-message 2
-message 3
-message 4
-message 5
-message 6
-message 7
-message 8
-message 9
-That's all, folks!
diff --git a/qpid/python/examples/fanout/fanout_consumer.py b/qpid/python/examples/fanout/fanout_consumer.py
deleted file mode 100755
index 0452baa..0000000
--- a/qpid/python/examples/fanout/fanout_consumer.py
+++ /dev/null
@@ -1,99 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- fanout_consumer.py
-
- This AMQP client reads messages from a message
- queue named "message_queue".
-"""
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-#----- Initialization --------------------------------------
-
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-     host=sys.argv[1]
-if len(sys.argv) > 2 :
-     port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-
-#----- Main Body -------------------------------------------
-
-# Create a server-side queue and route messages to it.
-# The server-side queue must have a unique name. Use the
-# session id for that.
-server_queue_name = session.name
-session.queue_declare(queue=server_queue_name)
-session.exchange_bind(queue=server_queue_name, exchange="amq.fanout")
-
-# Create a local queue to receive messages from the server-side
-# queue.
-local_queue_name = "local_queue"
-local_queue = session.incoming(local_queue_name)
-
-# Call message_subscribe() to tell the server to deliver messages
-# from the AMQP queue to this local client queue. 
-
-session.message_subscribe(queue=server_queue_name, destination=local_queue_name)
-local_queue.start()
-
-print "Subscribed to queue " + server_queue_name
-sys.stdout.flush()
-
-#  Initialize 'final' and 'content', variables used to identify the last message.
-final = "That's all, folks!"   # In a message body, signals the last message
-content = ""		       # Content of the last message read
-
-# Read the messages - acknowledge each one
-message = None
-while content != final:
-	message = local_queue.get(timeout=10)
-	content = message.body          
-        session.message_accept(RangedSet(message.id))
-	print content
-
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-#
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/fanout/fanout_producer.py b/qpid/python/examples/fanout/fanout_producer.py
deleted file mode 100755
index c4df252..0000000
--- a/qpid/python/examples/fanout/fanout_producer.py
+++ /dev/null
@@ -1,72 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- fanout_producer.py
-
- Publishes messages to an AMQP direct exchange, using
- the routing key "routing_key"
-"""
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, uuid4
-from qpid.queue import Empty
-
-#----- Initialization -----------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-     host=sys.argv[1]
-if len(sys.argv) > 2 :
-     port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-
-#----- Publish some messages ------------------------------
-
-# Create some messages and put them on the broker.
-
-delivery_properties = session.delivery_properties(routing_key="routing_key")
-
-for i in range(10):
-     session.message_transfer(destination="amq.fanout", message=Message(delivery_properties,"message " + str(i)))
-
-session.message_transfer(destination="amq.fanout", message=Message(delivery_properties, "That's all, folks!"))
-
-#----- Cleanup --------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/fanout/listener.py b/qpid/python/examples/fanout/listener.py
deleted file mode 100755
index 29db402..0000000
--- a/qpid/python/examples/fanout/listener.py
+++ /dev/null
@@ -1,117 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- listener.py
-
- This AMQP client reads messages from a message
- queue named "message_queue".
-"""
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-# 
-
-from time         import sleep
-
-#----- Message Receive Handler -----------------------------
-class Receiver:
-  def __init__ (self):
-    self.finalReceived = False
-
-  def isFinal (self):
-    return self.finalReceived
-    
-  def Handler (self, message):
-    content = message.body
-    session.message_accept(RangedSet(message.id))
-    print content
-    if content == "That's all, folks!":
-      self.finalReceived = True
-
-
-#----- Initialization --------------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Read from queue --------------------------------------------
-
-# Create a server-side queue and route messages to it.
-# The server-side queue must have a unique name. Use the
-# session id for that.
-
-server_queue_name = session.name
-session.queue_declare(queue=server_queue_name)
-session.exchange_bind(queue=server_queue_name, exchange="amq.fanout")
-
-# Create a local queue to receive messages from the server-side
-# queue.
-local_queue_name = "local_queue"
-local_queue = session.incoming(local_queue_name)
-
-
-# The local queue name identifies the client-side queue.
-
-local_queue_name = "local_queue"
-local_queue = session.incoming(local_queue_name)
-
-# Call message_subscribe() to tell the broker to deliver messages
-# from the AMQP queue to this local client queue. The broker will
-# start delivering messages as soon as local_queue.start() is called.
-
-session.message_subscribe(queue=server_queue_name, destination=local_queue_name)
-local_queue.start()
-
-receiver = Receiver ()
-local_queue.listen (receiver.Handler)
-
-while not receiver.isFinal ():
-  sleep (1)
-
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-#
-
-session.close()
diff --git a/qpid/python/examples/fanout/verify b/qpid/python/examples/fanout/verify
deleted file mode 100644
index 9e5c364..0000000
--- a/qpid/python/examples/fanout/verify
+++ /dev/null
@@ -1,24 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-background "Subscribed" ./fanout_consumer.py
-background "Subscribed" ./fanout_consumer.py
-clients ./fanout_producer.py
-outputs ./fanout_producer.py.out "./fanout_consumer.py.out | remove_uuid" "./fanout_consumer.pyX.out | remove_uuid"
diff --git a/qpid/python/examples/fanout/verify.in b/qpid/python/examples/fanout/verify.in
deleted file mode 100644
index d4b8670..0000000
--- a/qpid/python/examples/fanout/verify.in
+++ /dev/null
@@ -1,27 +0,0 @@
-==== fanout_producer.py.out
-==== fanout_consumer.py.out | remove_uuid
-Subscribed to queue 
-message 0
-message 1
-message 2
-message 3
-message 4
-message 5
-message 6
-message 7
-message 8
-message 9
-That's all, folks!
-==== fanout_consumer.pyX.out | remove_uuid
-Subscribed to queue 
-message 0
-message 1
-message 2
-message 3
-message 4
-message 5
-message 6
-message 7
-message 8
-message 9
-That's all, folks!
diff --git a/qpid/python/examples/headers/declare_queues.py b/qpid/python/examples/headers/declare_queues.py
deleted file mode 100755
index e976f71..0000000
--- a/qpid/python/examples/headers/declare_queues.py
+++ /dev/null
@@ -1,77 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- declare_queues.py 
-
- Creates and binds a queue on an AMQP headers exchange.
-
- All messages with an application header of {'class': 'first'} are sent to queue "first".
- All messages with an application header of {'class': 'second'} are sent to queue "second".
-"""
-
-# Common includes
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-#----- Initialization -----------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Create queues -------------------------------------
-
-# queue_declare() creates an AMQP queue, which is held
-# on the broker. Published messages are sent to the AMQP queue, 
-# from which messages are delivered to consumers. 
-# 
-# exchange_bind() determines which messages are routed to a queue. 
-
-session.queue_declare(queue="first")
-session.exchange_bind(exchange="amq.match", queue="first", binding_key="first", arguments={'x-match':'any', 'class':'first'})
-
-session.queue_declare(queue="second")
-session.exchange_bind(exchange="amq.match", queue="second", binding_key="second", arguments={'x-match':'any', 'class':'second'})
-
-#----- Cleanup ---------------------------------------------
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/headers/headers_consumer.py b/qpid/python/examples/headers/headers_consumer.py
deleted file mode 100755
index 8f5ce3c..0000000
--- a/qpid/python/examples/headers/headers_consumer.py
+++ /dev/null
@@ -1,107 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- headers_consumer.py
-
- This AMQP client reads messages from two message
- queues named "first" and "second".
-"""
-
-import qpid
-import sys
-import os
-from random import randint
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-
-#----- Initialization --------------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Read from queue --------------------------------------------
-
-# Now let's create two local client queues and tell them to read
-# incoming messages.
-
-# The consumer tag identifies the client-side queue.
-
-local_queue_name_first  = "local_queue_first"
-local_queue_name_second = "local_queue_second"
-
-queue_first  = session.incoming(local_queue_name_first)
-queue_second = session.incoming(local_queue_name_second)
-
-# Call message_subscribe() to tell the broker to deliver messages
-# from the AMQP queue to these local client queues. The broker will
-# start delivering messages as soon as credit is allocated using
-# queue.start().
-
-session.message_subscribe(queue="first",  destination=local_queue_name_first)
-session.message_subscribe(queue="second", destination=local_queue_name_second)
-
-queue_first.start()
-queue_second.start()
-
-#  Initialize 'final' and 'content', variables used to identify the last message.
-
-final = "That's all, folks!"   # In a message body, signals the last message
-content = ""		       # Content of the last message read
-
-message = None
-while content != final:
-        message = queue_first.get(timeout=10)
-        content = message.body          
-        session.message_accept(RangedSet(message.id))
-        print content
-
-content = ""
-while content != final:
-        message = queue_second.get(timeout=10)
-        content = message.body          
-        session.message_accept(RangedSet(message.id))
-        print content
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-#
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/headers/headers_producer.py b/qpid/python/examples/headers/headers_producer.py
deleted file mode 100755
index 43130d5..0000000
--- a/qpid/python/examples/headers/headers_producer.py
+++ /dev/null
@@ -1,79 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- headers_producer.py
-
- Publishes messages to an AMQP headers exchange, using
- various application header values.
-"""
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message
-from qpid.datatypes import uuid4
-from qpid.queue import Empty
-
-
-#----- Initialization -----------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Publish some messages ------------------------------
-
-# Create some messages and put them on the broker.
-props_first = session.message_properties(application_headers={'class':'first'})
-props_second = session.message_properties(application_headers={'class':'second'})
-props_third = session.message_properties(application_headers={'class':'third'})
-
-for i in range(10):
-     session.message_transfer(destination="amq.match", message=Message(props_first,"message(first) " + str(i)))
-     session.message_transfer(destination="amq.match", message=Message(props_second,"message(second) " + str(i)))
-     session.message_transfer(destination="amq.match", message=Message(props_third,"message(third) " + str(i)))
-
-session.message_transfer(destination="amq.match", message=Message(props_first,"That's all, folks!"))
-session.message_transfer(destination="amq.match", message=Message(props_second,"That's all, folks!"))
-session.message_transfer(destination="amq.match", message=Message(props_third,"That's all, folks!"))
-
-#----- Cleanup --------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/headers/verify b/qpid/python/examples/headers/verify
deleted file mode 100644
index 5fe96c5..0000000
--- a/qpid/python/examples/headers/verify
+++ /dev/null
@@ -1,22 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-clients ./declare_queues.py ./headers_producer.py ./headers_consumer.py
-outputs ./declare_queues.py.out ./headers_producer.py.out ./headers_consumer.py.out
diff --git a/qpid/python/examples/headers/verify.in b/qpid/python/examples/headers/verify.in
deleted file mode 100644
index 90ffd0a..0000000
--- a/qpid/python/examples/headers/verify.in
+++ /dev/null
@@ -1,25 +0,0 @@
-==== declare_queues.py.out
-==== headers_producer.py.out
-==== headers_consumer.py.out
-message(first) 0
-message(first) 1
-message(first) 2
-message(first) 3
-message(first) 4
-message(first) 5
-message(first) 6
-message(first) 7
-message(first) 8
-message(first) 9
-That's all, folks!
-message(second) 0
-message(second) 1
-message(second) 2
-message(second) 3
-message(second) 4
-message(second) 5
-message(second) 6
-message(second) 7
-message(second) 8
-message(second) 9
-That's all, folks!
diff --git a/qpid/python/examples/pubsub/topic_publisher.py b/qpid/python/examples/pubsub/topic_publisher.py
deleted file mode 100755
index b50d5fa..0000000
--- a/qpid/python/examples/pubsub/topic_publisher.py
+++ /dev/null
@@ -1,92 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- topic_publisher.py
-
- This is a simple AMQP publisher application that uses a 
- Topic exchange. The publisher specifies the routing key
- and the exchange for each message.
-"""
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-#----- Functions ----------------------------------------
-
-def send_msg(routing_key):
-  props = session.delivery_properties(routing_key=routing_key)
-  for i in range(5):
-     session.message_transfer(destination="amq.topic", message=Message(props,routing_key + " " + str(i)))
-
-#----- Initialization -----------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Publish some messages ------------------------------
-
-# Create some messages and put them on the broker. Use the
-# topic exchange.  The routing keys are "usa.news", "usa.weather", 
-# "europe.news", and "europe.weather".
-
-# usa.news
-send_msg("usa.news")
-
-# usa.weather
-send_msg("usa.weather")
-
-# europe.news
-send_msg("europe.news")
-
-# europe.weather
-send_msg("europe.weather")
-
-# Signal termination
-props = session.delivery_properties(routing_key="control")
-session.message_transfer(destination="amq.topic", message=Message(props,"That's all, folks!"))
-
-
-#----- Cleanup --------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/pubsub/topic_subscriber.py b/qpid/python/examples/pubsub/topic_subscriber.py
deleted file mode 100755
index 489c7cb..0000000
--- a/qpid/python/examples/pubsub/topic_subscriber.py
+++ /dev/null
@@ -1,154 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- topic_subscriber.py
-
- This subscriber creates private queues and binds them
- to the topics 'usa.#', 'europe.#', '#.news', and '#.weather'.
-"""
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-#----- Functions -------------------------------------------
-
-def dump_queue(queue):
-
-  content = ""		         # Content of the last message read
-  final = "That's all, folks!"   # In a message body, signals the last message
-  message = 0
-
-  while content != final:
-    try:
-      message = queue.get(timeout=10)
-      content = message.body
-      session.message_accept(RangedSet(message.id)) 
-      print content
-    except Empty:
-      print "No more messages!"
-      return
-
-
-
-def subscribe_queue(server_queue_name, local_queue_name):
-
-  print "Subscribing local queue '" + local_queue_name + "' to " + server_queue_name + "'"
-
-  queue = session.incoming(local_queue_name)
-
-  session.message_subscribe(queue=server_queue_name, destination=local_queue_name)
-  queue.start()
-
-  return queue
-
-#----- Initialization --------------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Main Body -- ----------------------------------------
-
-# declare queues on the server
-
-news = "news-" + session.name
-weather = "weather-" + session.name
-usa = "usa-" + session.name
-europe = "europe-" + session.name
-
-session.queue_declare(queue=news, exclusive=True)
-session.queue_declare(queue=weather, exclusive=True)
-session.queue_declare(queue=usa, exclusive=True)
-session.queue_declare(queue=europe, exclusive=True)
-
-# Routing keys may be "usa.news", "usa.weather", "europe.news", or "europe.weather".
-
-# The '#' symbol matches one component of a multipart name, e.g. "#.news" matches
-# "europe.news" or "usa.news".
-
-session.exchange_bind(exchange="amq.topic", queue=news, binding_key="#.news")
-session.exchange_bind(exchange="amq.topic", queue=weather, binding_key="#.weather")
-session.exchange_bind(exchange="amq.topic", queue=usa, binding_key="usa.#")
-session.exchange_bind(exchange="amq.topic", queue=europe, binding_key="europe.#")
-
-# Bind each queue to the control queue so we know when to stop
-
-session.exchange_bind(exchange="amq.topic", queue=news, binding_key="control")
-session.exchange_bind(exchange="amq.topic", queue=weather, binding_key="control")
-session.exchange_bind(exchange="amq.topic", queue=usa, binding_key="control")
-session.exchange_bind(exchange="amq.topic", queue=europe, binding_key="control")
-
-# Remind the user to start the topic producer
-
-print "Queues created - please start the topic producer"
-sys.stdout.flush()
-
-# Subscribe local queues to server queues
-
-local_news = "local_news"
-local_weather = "local_weather"
-local_usa = "local_usa" 
-local_europe = "local_europe"
-
-local_news_queue = subscribe_queue(news, local_news)
-local_weather_queue = subscribe_queue(weather, local_weather)
-local_usa_queue = subscribe_queue(usa, local_usa)
-local_europe_queue = subscribe_queue(europe, local_europe)
-
-# Call dump_queue to print messages from each queue
-
-print "Messages on 'news' queue:"
-dump_queue(local_news_queue)
-
-print "Messages on 'weather' queue:"
-dump_queue(local_weather_queue)
-
-print "Messages on 'usa' queue:"
-dump_queue(local_usa_queue)
-
-print "Messages on 'europe' queue:"
-dump_queue(local_europe_queue)
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/pubsub/verify b/qpid/python/examples/pubsub/verify
deleted file mode 100644
index cf1bade..0000000
--- a/qpid/python/examples/pubsub/verify
+++ /dev/null
@@ -1,23 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-background "Queues created" ./topic_subscriber.py
-clients ./topic_publisher.py
-outputs ./topic_publisher.py.out "topic_subscriber.py.out | remove_uuid | sort"
diff --git a/qpid/python/examples/pubsub/verify.in b/qpid/python/examples/pubsub/verify.in
deleted file mode 100644
index ac1506b..0000000
--- a/qpid/python/examples/pubsub/verify.in
+++ /dev/null
@@ -1,55 +0,0 @@
-==== topic_publisher.py.out
-==== topic_subscriber.py.out | remove_uuid | sort
-Messages on 'europe' queue:
-Messages on 'news' queue:
-Messages on 'usa' queue:
-Messages on 'weather' queue:
-Queues created - please start the topic producer
-Subscribing local queue 'local_europe' to europe-'
-Subscribing local queue 'local_news' to news-'
-Subscribing local queue 'local_usa' to usa-'
-Subscribing local queue 'local_weather' to weather-'
-That's all, folks!
-That's all, folks!
-That's all, folks!
-That's all, folks!
-europe.news 0
-europe.news 0
-europe.news 1
-europe.news 1
-europe.news 2
-europe.news 2
-europe.news 3
-europe.news 3
-europe.news 4
-europe.news 4
-europe.weather 0
-europe.weather 0
-europe.weather 1
-europe.weather 1
-europe.weather 2
-europe.weather 2
-europe.weather 3
-europe.weather 3
-europe.weather 4
-europe.weather 4
-usa.news 0
-usa.news 0
-usa.news 1
-usa.news 1
-usa.news 2
-usa.news 2
-usa.news 3
-usa.news 3
-usa.news 4
-usa.news 4
-usa.weather 0
-usa.weather 0
-usa.weather 1
-usa.weather 1
-usa.weather 2
-usa.weather 2
-usa.weather 3
-usa.weather 3
-usa.weather 4
-usa.weather 4
diff --git a/qpid/python/examples/request-response/client.py b/qpid/python/examples/request-response/client.py
deleted file mode 100755
index b29fcf3..0000000
--- a/qpid/python/examples/request-response/client.py
+++ /dev/null
@@ -1,131 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- client.py
-
- Client for a client/server example
-
-"""
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-#----- Functions -------------------------------------------
-
-def dump_queue(queue_name):
-
-  print "Messages on queue: " + queue_name 
-
-  message = 0
-
-  while True:
-    try:
-      message = queue.get(timeout=10)
-      content = message.body
-      session.message_accept(RangedSet(message.id))
-      print "Response: " + content
-    except Empty:
-      print "No more messages!"
-      break
-    except:
-      print "Unexpected exception!"
-      break
-
-
-#----- Initialization --------------------------------------
-
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-
-#----- Main Body -- ----------------------------------------
-
-# Create a response queue for the server to send responses to. Use the
-# same string as the name of the queue and the name of the routing
-# key.
-
-reply_to = "reply_to:" + session.name
-session.queue_declare(queue=reply_to, exclusive=True)
-session.exchange_bind(exchange="amq.direct", queue=reply_to, binding_key=reply_to)
-
-# Create a local queue and subscribe it to the response queue
-
-local_queue_name = "local_queue"
-queue = session.incoming(local_queue_name)
-
-# Call message_subscribe() to tell the broker to deliver messages from
-# the server's reply_to queue to our local client queue. The server
-# will start delivering messages as soon as message credit is
-# available.
-
-session.message_subscribe(queue=reply_to, destination=local_queue_name)
-queue.start()
-
-# Send some messages to the server's request queue
-
-lines = ["Twas brillig, and the slithy toves",
-         "Did gyre and gimble in the wabe.",
-         "All mimsy were the borogroves,",
-         "And the mome raths outgrabe."]
-
-# We will use the same reply_to and routing key
-# for each message
-
-message_properties = session.message_properties()
-message_properties.reply_to = session.reply_to("amq.direct", reply_to)
-delivery_properties = session.delivery_properties(routing_key="request")
-
-for line in lines:
-  print "Request: " + line
-  session.message_transfer(destination="amq.direct", message=Message(message_properties, delivery_properties, line))
-
-# Now see what messages the server sent to our reply_to queue
-
-dump_queue(reply_to)
-
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/request-response/server.py b/qpid/python/examples/request-response/server.py
deleted file mode 100755
index a80c454..0000000
--- a/qpid/python/examples/request-response/server.py
+++ /dev/null
@@ -1,110 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- server.py
-
- Server for a client/server example
-"""
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-#----- Functions -------------------------------------------
-def respond(session, request):
-
-    # The routing key for the response is the request's reply-to
-    # property.  The body for the response is the request's body,
-    # converted to upper case.
-
-    message_properties = request.get("message_properties")
-    reply_to = message_properties.reply_to
-    if reply_to == None:
-       raise Exception("This message is missing the 'reply_to' property, which is required")   
-   
-    props = session.delivery_properties(routing_key=reply_to["routing_key"]) 
-    session.message_transfer(destination=reply_to["exchange"], message=Message(props,request.body.upper()))
-
-#----- Initialization --------------------------------------
-
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Main Body -- ----------------------------------------
-
-# Create a request queue and subscribe to it
-
-session.queue_declare(queue="request", exclusive=True)
-session.exchange_bind(exchange="amq.direct", queue="request", binding_key="request")
-
-local_queue_name = "local_queue"
-
-session.message_subscribe(queue="request", destination=local_queue_name)
-
-queue = session.incoming(local_queue_name)
-queue.start()
-
-# Remind the user to start the client program
-
-print "Request server running - run your client now."
-print "(Times out after 100 seconds ...)"
-sys.stdout.flush()
-
-# Respond to each request
-
-# If we get a message, send it back to the user (as indicated in the
-# ReplyTo property)
-
-while True:
-  try:
-    request = queue.get(timeout=100)
-    respond(session, request)
-    session.message_accept(RangedSet(request.id))
-  except Empty:
-    print "No more messages!"
-    break;
-
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-
-session.close(timeout=10)
diff --git a/qpid/python/examples/request-response/verify b/qpid/python/examples/request-response/verify
deleted file mode 100644
index 3c058fe..0000000
--- a/qpid/python/examples/request-response/verify
+++ /dev/null
@@ -1,24 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-background "Request server running" ./server.py
-clients ./client.py
-kill %% 			# Must kill the server.
-outputs "./client.py.out | remove_uuid" " server.py.out | remove_uuid"
diff --git a/qpid/python/examples/request-response/verify.in b/qpid/python/examples/request-response/verify.in
deleted file mode 100644
index 4c31128..0000000
--- a/qpid/python/examples/request-response/verify.in
+++ /dev/null
@@ -1,14 +0,0 @@
-==== client.py.out | remove_uuid
-Request: Twas brillig, and the slithy toves
-Request: Did gyre and gimble in the wabe.
-Request: All mimsy were the borogroves,
-Request: And the mome raths outgrabe.
-Messages on queue: reply_to:
-Response: TWAS BRILLIG, AND THE SLITHY TOVES
-Response: DID GYRE AND GIMBLE IN THE WABE.
-Response: ALL MIMSY WERE THE BOROGROVES,
-Response: AND THE MOME RATHS OUTGRABE.
-No more messages!
-==== server.py.out | remove_uuid
-Request server running - run your client now.
-(Times out after 100 seconds ...)
diff --git a/qpid/python/examples/xml-exchange/declare_queues.py b/qpid/python/examples/xml-exchange/declare_queues.py
deleted file mode 100755
index ca40af5..0000000
--- a/qpid/python/examples/xml-exchange/declare_queues.py
+++ /dev/null
@@ -1,90 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- declare_queues.py 
-
- Creates and binds a queue on an AMQP direct exchange.
-
- All messages using the routing key "routing_key" are
- sent to the queue named "message_queue".
-"""
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-#----- Initialization -----------------------------------
-
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Create a queue -------------------------------------
-
-# queue_declare() creates an AMQP queue, which is held
-# on the broker. Published messages are sent to the AMQP queue, 
-# from which messages are delivered to consumers. 
-# 
-# queue_bind() determines which messages are routed to a queue. 
-# Route all messages with the routing key "routing_key" to
-# the AMQP queue named "message_queue".
-
-session.exchange_declare(exchange="xml", type="xml")
-session.queue_declare(queue="message_queue")
-
-binding = {}
-binding["xquery"] = """
-   let $w := ./weather
-   return $w/station = 'Raleigh-Durham International Airport (KRDU)'
-      and $w/temperature_f > 50
-      and $w/temperature_f - $w/dewpoint > 5
-      and $w/wind_speed_mph > 7
-      and $w/wind_speed_mph < 20 """
-                      
-
-session.exchange_bind(exchange="xml", queue="message_queue", binding_key="weather", arguments=binding)
-
-
-#----- Cleanup ---------------------------------------------
-
-session.close()
-
-
diff --git a/qpid/python/examples/xml-exchange/listener.py b/qpid/python/examples/xml-exchange/listener.py
deleted file mode 100755
index a56f5d6..0000000
--- a/qpid/python/examples/xml-exchange/listener.py
+++ /dev/null
@@ -1,105 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- listener.py
-
- This AMQP client reads messages from a message
- queue named "message_queue". It is implemented
- as a message listener.
-"""
-
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-# 
-
-from time         import sleep
-
-
-#----- Message Receive Handler -----------------------------
-class Receiver:
-  def __init__ (self):
-    self.finalReceived = False
-
-  def isFinal (self):
-    return self.finalReceived
-    
-  def Handler (self, message):
-    content = message.body
-    session.message_accept(RangedSet(message.id))
-    print content
-
-#----- Initialization --------------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Read from queue --------------------------------------------
-
-# Now let's create a local client queue and tell it to read
-# incoming messages.
-
-# The consumer tag identifies the client-side queue.
-
-local_queue_name = "local_queue"
-local_queue = session.incoming(local_queue_name)
-
-# Call message_subscribe() to tell the broker to deliver messages
-# from the AMQP queue to this local client queue. The broker will
-# start delivering messages as soon as local_queue.start() is called.
-
-session.message_subscribe(queue="message_queue", destination=local_queue_name)
-local_queue.start()
-
-receiver = Receiver ()
-local_queue.listen (receiver.Handler)
-
-sleep (10)
-
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-#
-
-session.close()
diff --git a/qpid/python/examples/xml-exchange/verify b/qpid/python/examples/xml-exchange/verify
deleted file mode 100644
index a93a32d..0000000
--- a/qpid/python/examples/xml-exchange/verify
+++ /dev/null
@@ -1,22 +0,0 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-# See https://svn.apache.org/repos/asf/incubator/qpid/trunk/qpid/bin/verify 
-clients ./declare_queues.py ./xml_producer.py ./xml_consumer.py
-outputs ./declare_queues.py.out ./xml_producer.py.out ./xml_consumer.py.out
diff --git a/qpid/python/examples/xml-exchange/verify.in b/qpid/python/examples/xml-exchange/verify.in
deleted file mode 100644
index e5b9909..0000000
--- a/qpid/python/examples/xml-exchange/verify.in
+++ /dev/null
@@ -1,15 +0,0 @@
-==== declare_queues.py.out
-==== xml_producer.py.out
-<weather><station>Raleigh-Durham International Airport (KRDU)</station><wind_speed_mph>0</wind_speed_mph><temperature_f>30</temperature_f><dewpoint>35</dewpoint></weather>
-<weather><station>New Bern, Craven County Regional Airport (KEWN)</station><wind_speed_mph>2</wind_speed_mph><temperature_f>40</temperature_f><dewpoint>40</dewpoint></weather>
-<weather><station>Boone, Watauga County Hospital Heliport (KTNB)</station><wind_speed_mph>5</wind_speed_mph><temperature_f>50</temperature_f><dewpoint>45</dewpoint></weather>
-<weather><station>Hatteras, Mitchell Field (KHSE)</station><wind_speed_mph>10</wind_speed_mph><temperature_f>60</temperature_f><dewpoint>50</dewpoint></weather>
-<weather><station>Raleigh-Durham International Airport (KRDU)</station><wind_speed_mph>16</wind_speed_mph><temperature_f>70</temperature_f><dewpoint>35</dewpoint></weather>
-<weather><station>New Bern, Craven County Regional Airport (KEWN)</station><wind_speed_mph>22</wind_speed_mph><temperature_f>80</temperature_f><dewpoint>40</dewpoint></weather>
-<weather><station>Boone, Watauga County Hospital Heliport (KTNB)</station><wind_speed_mph>28</wind_speed_mph><temperature_f>90</temperature_f><dewpoint>45</dewpoint></weather>
-<weather><station>Hatteras, Mitchell Field (KHSE)</station><wind_speed_mph>35</wind_speed_mph><temperature_f>100</temperature_f><dewpoint>50</dewpoint></weather>
-<weather><station>Raleigh-Durham International Airport (KRDU)</station><wind_speed_mph>42</wind_speed_mph><temperature_f>30</temperature_f><dewpoint>35</dewpoint></weather>
-<weather><station>New Bern, Craven County Regional Airport (KEWN)</station><wind_speed_mph>51</wind_speed_mph><temperature_f>40</temperature_f><dewpoint>40</dewpoint></weather>
-==== xml_consumer.py.out
-<weather><station>Raleigh-Durham International Airport (KRDU)</station><wind_speed_mph>16</wind_speed_mph><temperature_f>70</temperature_f><dewpoint>35</dewpoint></weather>
-No more messages!
diff --git a/qpid/python/examples/xml-exchange/xml_consumer.py b/qpid/python/examples/xml-exchange/xml_consumer.py
deleted file mode 100755
index cd89110..0000000
--- a/qpid/python/examples/xml-exchange/xml_consumer.py
+++ /dev/null
@@ -1,96 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- direct_consumer.py
-
- This AMQP client reads messages from a message
- queue named "message_queue".
-"""
-
-import qpid
-import sys
-import os
-from random import randint
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-
-#----- Initialization --------------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-
-#----- Read from queue --------------------------------------------
-
-# Now let's create a local client queue and tell it to read
-# incoming messages.
-
-# The consumer tag identifies the client-side queue.
-
-local_queue_name = "local_queue"
-local_queue = session.incoming(local_queue_name)
-
-# Call message_consume() to tell the broker to deliver messages
-# from the AMQP queue to this local client queue. The broker will
-# start delivering messages as soon as local_queue.start() is called.
-
-session.message_subscribe(queue="message_queue", destination=local_queue_name)
-local_queue.start()
-
-#  Initialize 'final' and 'content', variables used to identify the last message.
-
-message = None
-while True:
-   try:
-	message = local_queue.get(timeout=10)
-        session.message_accept(RangedSet(message.id))
-	content = message.body
-	print content
-   except Empty:
-        print "No more messages!"
-        break
-
-
-#----- Cleanup ------------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-#
-
-session.close()
diff --git a/qpid/python/examples/xml-exchange/xml_producer.py b/qpid/python/examples/xml-exchange/xml_producer.py
deleted file mode 100755
index fa97cab..0000000
--- a/qpid/python/examples/xml-exchange/xml_producer.py
+++ /dev/null
@@ -1,92 +0,0 @@
-#!/usr/bin/env python
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-# 
-#   http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-"""
- xml_producer.py
-
- Publishes messages to an XML exchange, using
- the routing key "weather"
-"""
-
-
-import qpid
-import sys
-import os
-from qpid.util import connect
-from qpid.connection import Connection
-from qpid.datatypes import Message, RangedSet, uuid4
-from qpid.queue import Empty
-
-#----- Functions ----------------------------------------
-
-# Data for weather reports
-
-station = ("Raleigh-Durham International Airport (KRDU)", 
-           "New Bern, Craven County Regional Airport (KEWN)", 
-           "Boone, Watauga County Hospital Heliport (KTNB)",
-           "Hatteras, Mitchell Field (KHSE)")
-wind_speed_mph = ( 0, 2, 5, 10, 16, 22, 28, 35, 42, 51, 61, 70, 80 )
-temperature_f = ( 30, 40, 50, 60, 70, 80, 90, 100 )
-dewpoint = ( 35, 40, 45, 50 )
-
-def pick_one(list, i):
-  return str( list [ i % len(list)] )
-
-def report(i):
-  return "<weather>" + "<station>" + pick_one(station,i)+ "</station>"  + "<wind_speed_mph>" + pick_one(wind_speed_mph,i) + "</wind_speed_mph>"  + "<temperature_f>" + pick_one(temperature_f,i) + "</temperature_f>" + "<dewpoint>" + pick_one(dewpoint,i) + "</dewpoint>" + "</weather>"
-
-
-#----- Initialization -----------------------------------
-
-#  Set parameters for login
-
-host="127.0.0.1"
-port=5672
-user="guest"
-password="guest"
-
-# If an alternate host or port has been specified, use that instead
-# (this is used in our unit tests)
-if len(sys.argv) > 1 :
-  host=sys.argv[1]
-if len(sys.argv) > 2 :
-  port=int(sys.argv[2])
-
-#  Create a connection.
-socket = connect(host, port)
-connection = Connection (sock=socket, username=user, password=password)
-connection.start()
-session = connection.session(str(uuid4()))
-
-#----- Publish some messages ------------------------------
-
-# Create some messages and put them on the broker.
-
-props = session.delivery_properties(routing_key="weather")
-
-for i in range(10):
-  print report(i)
-  session.message_transfer(destination="xml", message=Message(props, report(i)))
-
-
-#----- Cleanup --------------------------------------------
-
-# Clean up before exiting so there are no open threads.
-
-session.close()
-- 
1.7.1.1

From dee1c0cebff68b694ed6e80be79b8943ebb40574 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Tue, 13 Jul 2010 17:58:44 +0000
Subject: [PATCH 116/129] BZ-613912 fixed missign import and added test case for reconnect_urls

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@963803 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py          |    1 +
 qpid/python/qpid/tests/messaging/endpoints.py |    7 +++++++
 qpid/python/qpid/util.py                      |   21 ++++++++++++++-------
 3 files changed, 22 insertions(+), 7 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index a3c565f..15eaf1f 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -31,6 +31,7 @@ from qpid.messaging.exceptions import *
 from qpid.messaging.message import get_codec, Disposition, Message
 from qpid.ops import *
 from qpid.selector import Selector
+from qpid.util import URL
 from qpid.validator import And, Context, List, Map, Types, Values
 from threading import Condition, Thread
 
diff --git a/qpid/python/qpid/tests/messaging/endpoints.py b/qpid/python/qpid/tests/messaging/endpoints.py
index 52ca9f3..bc17068 100644
--- a/qpid/python/qpid/tests/messaging/endpoints.py
+++ b/qpid/python/qpid/tests/messaging/endpoints.py
@@ -39,6 +39,13 @@ class SetupTests(Base):
     self.conn.open()
     self.ping(self.conn.session())
 
+  def testOpenReconnectURLs(self):
+    options = self.connection_options()
+    options["reconnect_urls"] = [self.broker, self.broker]
+    self.conn = Connection(self.broker, **options)
+    self.conn.open()
+    self.ping(self.conn.session())
+
   def testConnectError(self):
     try:
       # Specifying port 0 yields a bad address on Windows; port 4 is unassigned
diff --git a/qpid/python/qpid/util.py b/qpid/python/qpid/util.py
index 3409d77..e62bebd 100644
--- a/qpid/python/qpid/util.py
+++ b/qpid/python/qpid/util.py
@@ -109,14 +109,21 @@ class URL:
   AMQP = "amqp"
 
   def __init__(self, s):
-    match = URL.RE.match(s)
-    if match is None:
-      raise ValueError(s)
-    self.scheme, self.user, self.password, self.host, port = match.groups()
-    if port is None:
-      self.port = None
+    if isinstance(s, URL):
+      self.scheme = s.scheme
+      self.user = s.user
+      self.password = s.password
+      self.host = s.host
+      self.port = s.port
     else:
-      self.port = int(port)
+      match = URL.RE.match(s)
+      if match is None:
+        raise ValueError(s)
+      self.scheme, self.user, self.password, self.host, port = match.groups()
+      if port is None:
+        self.port = None
+      else:
+        self.port = int(port)
 
   def __repr__(self):
     return "URL(%r)" % str(self)
-- 
1.7.1.1

From 69472698c9455b198d70e7b61ae2f1f06a8ff783 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Tue, 13 Jul 2010 19:07:22 +0000
Subject: [PATCH 117/129] BZ-614054 eliminate spurious error logging and reconnect attempts

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@963825 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py |    2 +-
 qpid/python/qpid/messaging/util.py   |    6 +++++-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index 15eaf1f..ff988c2 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -463,7 +463,7 @@ class Driver:
   def dispatch(self):
     try:
       if self._transport is None:
-        if self.connection._connected:
+        if self.connection._connected and not self.connection.error:
           self.connect()
       else:
         self.engine.dispatch()
diff --git a/qpid/python/qpid/messaging/util.py b/qpid/python/qpid/messaging/util.py
index 42bc280..44833f7 100644
--- a/qpid/python/qpid/messaging/util.py
+++ b/qpid/python/qpid/messaging/util.py
@@ -21,6 +21,7 @@
 Add-on utilities for the L{qpid.messaging} API.
 """
 
+from qpid.messaging import *
 from logging import getLogger
 from threading import Thread
 
@@ -33,7 +34,10 @@ def auto_fetch_reconnect_urls(conn):
 
   def main():
     while True:
-      msg = rcv.fetch()
+      try:
+        msg = rcv.fetch()
+      except LinkClosed:
+        return
       set_reconnect_urls(conn, msg)
       ssn.acknowledge(msg, sync=False)
 
-- 
1.7.1.1

From 0463df7545b76b30af86b6fdfefd1232e2014cd8 Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@apache.org>
Date: Tue, 13 Jul 2010 22:24:47 +0000
Subject: [PATCH 118/129] No BZ - fix to test framework: Remove deleted files from Makefile.am, part of removing the old python examples.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@963887 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit dfaf24a663db5e55f14d591e3575af8aa29b5f6c)
---
 qpid/cpp/examples/direct/Makefile.am           |    4 ----
 qpid/cpp/examples/fanout/Makefile.am           |    4 ----
 qpid/cpp/examples/pub-sub/Makefile.am          |    4 ----
 qpid/cpp/examples/request-response/Makefile.am |    4 ----
 4 files changed, 0 insertions(+), 16 deletions(-)

diff --git a/qpid/cpp/examples/direct/Makefile.am b/qpid/cpp/examples/direct/Makefile.am
index 4675333..b07db2c 100644
--- a/qpid/cpp/examples/direct/Makefile.am
+++ b/qpid/cpp/examples/direct/Makefile.am
@@ -42,10 +42,6 @@ EXTRA_DIST=	             \
 	CMakeLists.txt	     \
 	verify               \
 	verify.in            \
-	verify_cpp_python    \
-	verify_cpp_python.in \
-	verify_python_cpp    \
-	verify_python_cpp.in \
 	direct_declare_queues.vcproj \
 	direct_direct_producer.vcproj \
 	direct_listener.vcproj
diff --git a/qpid/cpp/examples/fanout/Makefile.am b/qpid/cpp/examples/fanout/Makefile.am
index bfa5404..6e2e821 100644
--- a/qpid/cpp/examples/fanout/Makefile.am
+++ b/qpid/cpp/examples/fanout/Makefile.am
@@ -38,9 +38,5 @@ EXTRA_DIST=                  \
 	CMakeLists.txt       \
 	verify               \
 	verify.in            \
-	verify_cpp_python    \
-	verify_cpp_python.in \
-	verify_python_cpp    \
-	verify_python_cpp.in \
 	fanout_fanout_producer.vcproj \
 	fanout_listener.vcproj
diff --git a/qpid/cpp/examples/pub-sub/Makefile.am b/qpid/cpp/examples/pub-sub/Makefile.am
index 8673174..62658eb 100644
--- a/qpid/cpp/examples/pub-sub/Makefile.am
+++ b/qpid/cpp/examples/pub-sub/Makefile.am
@@ -39,9 +39,5 @@ EXTRA_DIST=                  \
 	CMakeLists.txt       \
 	verify               \
 	verify.in            \
-	verify_cpp_python    \
-	verify_cpp_python.in \
-	verify_python_cpp    \
-	verify_python_cpp.in \
 	pub-sub_topic_listener.vcproj \
 	pub-sub_topic_publisher.vcproj
diff --git a/qpid/cpp/examples/request-response/Makefile.am b/qpid/cpp/examples/request-response/Makefile.am
index de59f3b..48b3d98 100644
--- a/qpid/cpp/examples/request-response/Makefile.am
+++ b/qpid/cpp/examples/request-response/Makefile.am
@@ -39,9 +39,5 @@ EXTRA_DIST=                  \
 	CMakeLists.txt       \
 	verify               \
 	verify.in            \
-	verify_cpp_python    \
-	verify_cpp_python.in \
-	verify_python_cpp    \
-	verify_python_cpp.in \
 	request-response_client.vcproj \
 	request-response_server.vcproj
-- 
1.7.1.1

From 5387d39d66787509b3d687be7247dcf8a2d4b207 Mon Sep 17 00:00:00 2001
From: Rafael H. Schloming <rhs@apache.org>
Date: Wed, 14 Jul 2010 13:36:03 +0000
Subject: [PATCH 119/129] BZ-614054 fixed parsing of failover URLs; fixed driver to notice when reconnect_urls is dynamically changed

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@964044 13f79535-47bb-0310-9956-ffa450edef68
---
 qpid/python/qpid/messaging/driver.py |   25 +++++++++++++++++--------
 qpid/python/qpid/messaging/util.py   |    9 +++++----
 2 files changed, 22 insertions(+), 12 deletions(-)

diff --git a/qpid/python/qpid/messaging/driver.py b/qpid/python/qpid/messaging/driver.py
index ff988c2..1e1055a 100644
--- a/qpid/python/qpid/messaging/driver.py
+++ b/qpid/python/qpid/messaging/driver.py
@@ -336,9 +336,6 @@ class Driver:
     self._selector = Selector.default()
     self._attempts = 0
     self._delay = self.connection.reconnect_interval_min
-    urls = [URL(u) for u in self.connection.reconnect_urls]
-    self._hosts = [(self.connection.host, self.connection.port)] + \
-        [(u.host, u.port) for u in urls]
     self._reconnect_log = self.connection.reconnect_log
     self._host = 0
     self._retrying = False
@@ -348,6 +345,21 @@ class Driver:
 
     self.engine = None
 
+  def _next_host(self):
+    urls = [URL(u) for u in self.connection.reconnect_urls]
+    hosts = [(self.connection.host, self.connection.port)] + \
+        [(u.host, u.port) for u in urls]
+    if self._host >= len(hosts):
+      self._host = 0
+    result = hosts[self._host]
+    if self._host == 0:
+      self._attempts += 1
+    self._host = self._host + 1
+    return result
+
+  def _num_hosts(self):
+    return len(self.connection.reconnect_urls) + 1
+
   @synchronized
   def wakeup(self):
     self.dispatch()
@@ -409,7 +421,7 @@ class Driver:
         (self.connection.reconnect_limit is None or
          self.connection.reconnect_limit <= 0 or
          self._attempts <= self.connection.reconnect_limit)):
-      if self._host > 0:
+      if self._host < self._num_hosts():
         delay = 0
       else:
         delay = self._delay
@@ -475,9 +487,7 @@ class Driver:
   def connect(self):
     try:
       # XXX: should make this non blocking
-      if self._host == 0:
-        self._attempts += 1
-      host, port = self._hosts[self._host]
+      host, port = self._next_host()
       if self._retrying and self._reconnect_log:
         log.warn("trying: %s:%s", host, port)
       self.engine = Engine(self.connection)
@@ -496,7 +506,6 @@ class Driver:
       self._delay = self.connection.reconnect_interval_min
       self._retrying = False
     except socket.error, e:
-      self._host = (self._host + 1) % len(self._hosts)
       self.close_engine(ConnectError(text=str(e)))
 
 DEFAULT_DISPOSITION = Disposition(None)
diff --git a/qpid/python/qpid/messaging/util.py b/qpid/python/qpid/messaging/util.py
index 44833f7..265cf7d 100644
--- a/qpid/python/qpid/messaging/util.py
+++ b/qpid/python/qpid/messaging/util.py
@@ -50,10 +50,11 @@ def set_reconnect_urls(conn, msg):
   reconnect_urls = []
   urls = msg.properties["amq.failover"]
   for u in urls:
-    if u.startswith("amqp:tcp:"):
-      parts = u.split(":")
-      host, port = parts[2:4]
-      reconnect_urls.append("%s:%s" % (host, port))
+    if u.startswith("amqp:"):
+      for p in u[5:].split(","):
+        parts = p.split(":")
+        host, port = parts[1:3]
+        reconnect_urls.append("%s:%s" % (host, port))
   conn.reconnect_urls = reconnect_urls
   log.warn("set reconnect_urls for conn %s: %s", conn, reconnect_urls)
 
-- 
1.7.1.1

From 3bc85ad80caebb44a9cc308ba562cb790d1eecb0 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Thu, 1 Jul 2010 13:53:36 +0000
Subject: [PATCH 120/129] Windows .NET support

QPID-2708 - Patch from Chuck Rolke
Added dependency for new qpidtypes library.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@959664 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 2b74ca3397532015562f882c948eabcad812427c)
---
 .../dotnet/src/org.apache.qpid.messaging.vcproj    |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
index 9700b59..9511e4b 100644
--- a/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
+++ b/qpid/cpp/bindings/qpid/dotnet/src/org.apache.qpid.messaging.vcproj
@@ -63,7 +63,7 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalOptions=" /STACK:10000000 /machine:I386"
-				AdditionalDependencies="$(ProjectDir)..\..\..\..\src\Debug\qpidclientd.lib $(ProjectDir)..\..\..\..\src\Debug\qpidcommond.lib $(ProjectDir)..\..\..\..\src\Debug\qpidmessagingd.lib"
+				AdditionalDependencies="$(ProjectDir)..\..\..\..\src\Debug\qpidclientd.lib $(ProjectDir)..\..\..\..\src\Debug\qpidcommond.lib $(ProjectDir)..\..\..\..\src\Debug\qpidmessagingd.lib $(ProjectDir)..\..\..\..\src\Debug\qpidtypesd.lib"
 				OutputFile="$(ProjectDir)..\..\..\..\src\$(ConfigurationName)\org.apache.qpid.messagingd.dll"
 				LinkIncremental="1"
 				GenerateDebugInformation="true"
@@ -141,7 +141,7 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalOptions=" /STACK:10000000 /machine:I386"
-				AdditionalDependencies="$(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidclient.lib $(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidcommon.lib $(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidmessaging.lib"
+				AdditionalDependencies="$(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidclient.lib $(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidcommon.lib $(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidmessaging.lib $(ProjectDir)..\..\..\..\src\$(ConfigurationName)\qpidtypes.lib"
 				OutputFile="$(ProjectDir)..\..\..\..\src\$(ConfigurationName)\org.apache.qpid.messaging.dll"
 				LinkIncremental="1"
 				GenerateDebugInformation="true"
-- 
1.7.1.1

From e89bdbf12e31a7c3a7a4adc3f0e3d5b54abdd92c Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Wed, 7 Jul 2010 12:21:03 +0000
Subject: [PATCH 121/129] Windows .NET Support

QPID-2710 Patch from Chuck Rolke
C++ Messaging Client .NET binding is not compiled in SDK

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@961355 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit a0d9764eac4a0e6508d80951e2d4ce733c003f63)
---
 qpid/cpp/bld-winsdk.ps1 |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/qpid/cpp/bld-winsdk.ps1 b/qpid/cpp/bld-winsdk.ps1
index 7aa6df8..ef9c263 100644
--- a/qpid/cpp/bld-winsdk.ps1
+++ b/qpid/cpp/bld-winsdk.ps1
@@ -60,6 +60,10 @@ devenv qpid-cpp.sln /build "Release|Win32" /project docs-user-api
 devenv qpid-cpp.sln /build "Debug|Win32" /project INSTALL
 devenv qpid-cpp.sln /build "RelWithDebInfo|Win32" /project INSTALL
 
+# Build the .NET binding
+devenv .\bindings\qpid\dotnet\org.apache.qpid.messaging.sln /build "Debug|x86" /project org.apache.qpid.messaging
+devenv .\bindings\qpid\dotnet\org.apache.qpid.messaging.sln /build "Debug|x86" /project org.apache.qpid.messaging.sessionreceiver
+
 # This would be kludgy if we have only one entry as the array declaration syntax
 # can't cope with just one nested array
 # Target must be a directory
@@ -126,6 +130,10 @@ foreach ($pattern in $preserve) {
 }
 Remove-Item -recurse $preserve_dir
 
+# Install the .NET binding
+Copy-Item -force -path "./src/Debug/org.apache.qpid.messaging*.dll" -destination "$install_dir/bin"
+Copy-Item -force -path "./src/Debug/org.apache.qpid.messaging*.pdb" -destination "$install_dir/bin/DebugPDB"
+
 # Zip the /bin PDB files into two zip files.
 # we previously arranged that the Debug pdbs go in the DebugPDB subdirectory
 # and the Release pdbs go in the ReleasePDB subdirectory
-- 
1.7.1.1

From 47aa17d06871472f180df5b35b4bc06e09c1df15 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Thu, 8 Jul 2010 22:14:54 +0000
Subject: [PATCH 122/129] Windows .NET Support

QPID-2711 - Patch from Chuck Rolke
Add version and icon resources to Windows C++ exe/dll files

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@961962 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 18005c4ebb833597f52de911d2baddde3ddf9d03)
---
 qpid/cpp/CMakeLists.txt                            |   14 +-
 qpid/cpp/src/CMakeLists.txt                        |  141 +++++++++++++++++--
 qpid/cpp/src/CMakeWinVersions.cmake                |   57 ++++++++
 qpid/cpp/src/windows/resources/qpid-icon.ico       |  Bin 0 -> 52972 bytes
 .../cpp/src/windows/resources/template-resource.rc |  122 +++++++++++++++++
 qpid/cpp/src/windows/resources/version-resource.h  |   35 +++++
 6 files changed, 347 insertions(+), 22 deletions(-)
 create mode 100644 qpid/cpp/src/CMakeWinVersions.cmake
 create mode 100644 qpid/cpp/src/windows/resources/qpid-icon.ico
 create mode 100644 qpid/cpp/src/windows/resources/template-resource.rc
 create mode 100644 qpid/cpp/src/windows/resources/version-resource.h

diff --git a/qpid/cpp/CMakeLists.txt b/qpid/cpp/CMakeLists.txt
index dbed67e..3efc0a8 100644
--- a/qpid/cpp/CMakeLists.txt
+++ b/qpid/cpp/CMakeLists.txt
@@ -59,13 +59,6 @@ endif (WIN32)
 
 # set(CMAKE_INCLUDE_CURRENT_DIR ON)
 
-add_subdirectory(managementgen)
-add_subdirectory(etc)
-add_subdirectory(src)
-add_subdirectory(docs/api)
-# add_subdirectory(docs/man)
-add_subdirectory(examples)
-
 set(CPACK_PACKAGE_NAME "qpid-cpp")
 set(CPACK_PACKAGE_VENDOR "Apache Software Foundation")
 set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Apache Qpid C++")
@@ -75,4 +68,11 @@ set(CPACK_PACKAGE_VERSION_MINOR "${QPID_VERSION_MINOR}")
 set(CPACK_PACKAGE_VERSION_PATCH "0")
 set(CPACK_PACKAGE_INSTALL_DIRECTORY "qpidc-${qpidc_version}")
 
+add_subdirectory(managementgen)
+add_subdirectory(etc)
+add_subdirectory(src)
+add_subdirectory(docs/api)
+# add_subdirectory(docs/man)
+add_subdirectory(examples)
+
 include (CPack)
diff --git a/qpid/cpp/src/CMakeLists.txt b/qpid/cpp/src/CMakeLists.txt
index 5ac5373..4a6dfbc 100644
--- a/qpid/cpp/src/CMakeLists.txt
+++ b/qpid/cpp/src/CMakeLists.txt
@@ -65,6 +65,103 @@ MACRO (install_pdb theLibrary theComponent)
     endif (MSVC)
 ENDMACRO (install_pdb)
 
+#
+# inherit_value - if the symbol is undefined then set it to the given value.
+# Set flag to indicate this symbol was defined here.
+#
+MACRO (inherit_value theSymbol theValue)
+    if (NOT DEFINED ${theSymbol})
+        set (${theSymbol} ${theValue})
+        # message ("Set symbol '${theSymbol}' to value '${theValue}'")
+        set (${theSymbol}_inherited = "true")
+    endif (NOT DEFINED ${theSymbol})
+ENDMACRO (inherit_value)
+
+#
+# If compiler is Visual Studio then create a "version resource" for the project.
+# Use this call to override CPACK and file global settings but not file per-project settings.
+# Two groups of four version numbers specify "file" and "product" versions separately.
+#
+# Sample: add_msvc_version_full (qmfengine library dll 1 0 0 1 1 0 0 1)
+#
+MACRO (add_msvc_version_full verProject verProjectType verProjectFileExt verFN1 verFN2 verFN3 verFN4 verPN1 verPN2 verPN3 verPN4)
+    if (MSVC)
+        # Create project-specific version strings
+        inherit_value ("winver_${verProject}_FileVersionBinary"    "${verFN1},${verFN2},${verFN3},${verFN4}")
+        inherit_value ("winver_${verProject}_ProductVersionBinary" "${verPN1},${verPN2},${verPN3},${verPN4}")
+        inherit_value ("winver_${verProject}_FileVersionString"    "${verFN1}, ${verFN2}, ${verFN3}, ${verFN4}")
+        inherit_value ("winver_${verProject}_ProductVersionString" "${verPN1}, ${verPN2}, ${verPN3}, ${verPN4}")
+        inherit_value ("winver_${verProject}_FileDescription"      "${winver_PACKAGE_NAME}-${verProject} ${verProjectType}")
+        inherit_value ("winver_${verProject}_LegalCopyright"       "${winver_LEGAL_COPYRIGHT}")
+        inherit_value ("winver_${verProject}_InternalName"         "${verProject}")
+        inherit_value ("winver_${verProject}_OriginalFilename"     "${verProject}.${verProjectFileExt}")
+        inherit_value ("winver_${verProject}_ProductName"          "${winver_DESCRIPTION_SUMMARY}")
+        
+        # Create strings to be substituted into the template file
+        set ("winverFileVersionBinary"     "${winver_${verProject}_FileVersionBinary}")
+        set ("winverProductVersionBinary"  "${winver_${verProject}_ProductVersionBinary}")
+        set ("winverFileVersionString"     "${winver_${verProject}_FileVersionString}")
+        set ("winverProductVersionString"  "${winver_${verProject}_ProductVersionString}")
+        set ("winverFileDescription"       "${winver_${verProject}_FileDescription}")
+        set ("winverLegalCopyright"        "${winver_${verProject}_LegalCopyright}")
+        set ("winverInternalName"          "${winver_${verProject}_InternalName}")
+        set ("winverOriginalFilename"      "${winver_${verProject}_OriginalFilename}")
+        set ("winverProductName"           "${winver_${verProject}_ProductName}")
+
+        configure_file(windows/resources/template-resource.rc
+                         windows/resources/${verProject}-resource.rc)
+        set (${verProject}_SOURCES
+            ${${verProject}_SOURCES}
+            windows/resources/${verProject}-resource.rc
+        )
+    endif (MSVC)
+ENDMACRO (add_msvc_version_full)
+
+#
+# If compiler is Visual Studio then create a "version resource" for the project.
+# Use this call to accept file override version settings or
+#  inherited CPACK_PACKAGE_VERSION version settings.
+#
+# Sample: add_msvc_version (qpidcommon library dll)
+#
+MACRO (add_msvc_version verProject verProjectType verProjectFileExt)
+    if (MSVC)
+        add_msvc_version_full (${verProject} 
+                               ${verProjectType}
+                               ${verProjectFileExt}
+                               ${winver_FILE_VERSION_N1}
+                               ${winver_FILE_VERSION_N2}
+                               ${winver_FILE_VERSION_N3}
+                               ${winver_FILE_VERSION_N4}
+                               ${winver_PRODUCT_VERSION_N1}
+                               ${winver_PRODUCT_VERSION_N2}
+                               ${winver_PRODUCT_VERSION_N3}
+                               ${winver_PRODUCT_VERSION_N4})
+    endif (MSVC)
+ENDMACRO (add_msvc_version)
+
+
+#
+# Install optional windows version settings. Override variables are specified in a file.
+#
+include (./CMakeWinVersions.cmake OPTIONAL)
+
+#
+# Inherit global windows version settings from CPACK settings.
+#
+inherit_value ("winver_PACKAGE_NAME"         "${CPACK_PACKAGE_NAME}")
+inherit_value ("winver_DESCRIPTION_SUMMARY"  "${CPACK_PACKAGE_DESCRIPTION_SUMMARY}")
+inherit_value ("winver_FILE_VERSION_N1"      "${CPACK_PACKAGE_VERSION_MAJOR}")
+inherit_value ("winver_FILE_VERSION_N2"      "${CPACK_PACKAGE_VERSION_MINOR}")
+inherit_value ("winver_FILE_VERSION_N3"      "${CPACK_PACKAGE_VERSION_PATCH}")
+inherit_value ("winver_FILE_VERSION_N4"      "1")
+inherit_value ("winver_PRODUCT_VERSION_N1"   "${winver_FILE_VERSION_N1}")
+inherit_value ("winver_PRODUCT_VERSION_N2"   "${winver_FILE_VERSION_N2}")
+inherit_value ("winver_PRODUCT_VERSION_N3"   "${winver_FILE_VERSION_N3}")
+inherit_value ("winver_PRODUCT_VERSION_N4"   "${winver_FILE_VERSION_N4}")
+inherit_value ("winver_LEGAL_COPYRIGHT"      "")
+
+
 # check if we generate source as part of the build
 #   - rubygen generates the amqp spec and clustering
 #   - managementgen generates the broker management code
@@ -676,6 +773,7 @@ set (qpidcommon_SOURCES
      qpid/sys/Timer.cpp
      qpid/amqp_0_10/Codecs.cpp
 )
+add_msvc_version (qpidcommon library dll)
 
 add_library (qpidcommon SHARED ${qpidcommon_SOURCES})
 if (CLOCK_GETTIME_IN_RT)
@@ -697,6 +795,7 @@ set(qpidtypes_SOURCES
   qpid/types/Variant.cpp
   ${qpidtypes_platform_SOURCES}
 )
+add_msvc_version (qpidtypes library dll)
 add_library(qpidtypes SHARED ${qpidtypes_SOURCES})
 target_link_libraries(qpidtypes ${qpidtypes_platform_LIBS})
 set_target_properties (qpidtypes PROPERTIES VERSION ${qpidc_version})
@@ -741,7 +840,7 @@ set (qpidclient_SOURCES
      qpid/client/SubscriptionManagerImpl.cpp
      qpid/client/TCPConnector.cpp
 )
-
+add_msvc_version (qpidclient library dll)
 
 add_library (qpidclient SHARED ${qpidclient_SOURCES})
 target_link_libraries (qpidclient qpidcommon ${qpidclient_platform_LIBS})
@@ -795,6 +894,7 @@ set (qpidmessaging_SOURCES
      qpid/client/amqp0_10/SimpleUrlParser.h
      qpid/client/amqp0_10/SimpleUrlParser.cpp
 )
+add_msvc_version (qpidmessaging library dll)
 
 add_library (qpidmessaging SHARED ${qpidmessaging_SOURCES})
 target_link_libraries (qpidmessaging qpidclient)
@@ -815,16 +915,18 @@ endif (NOT QPID_GENERATED_HEADERS_IN_SOURCE)
 
 
 if (WIN32)
+    # Install the DtcPlugin project and call it qpidxarm.
     set(AMQP_WCF_DIR ${qpid-cpp_SOURCE_DIR}/../wcf)
-    set(DTC_PLUGIN_SOURCE ${AMQP_WCF_DIR}/src/Apache/Qpid/DtcPlugin/DtcPlugin.cpp)
-    if (EXISTS ${DTC_PLUGIN_SOURCE})
-        add_library (qpidxarm SHARED ${DTC_PLUGIN_SOURCE})
+    set(qpidxarm_SOURCES ${AMQP_WCF_DIR}/src/Apache/Qpid/DtcPlugin/DtcPlugin.cpp)
+    if (EXISTS ${qpidxarm_SOURCES})
+        add_msvc_version (qpidxarm library dll)
+        add_library (qpidxarm SHARED ${qpidxarm_SOURCES})
         target_link_libraries (qpidxarm qpidclient qpidcommon)
         install (TARGETS qpidxarm
                  DESTINATION ${QPID_INSTALL_LIBDIR}
                  COMPONENT ${QPID_COMPONENT_CLIENT})
         install_pdb (qpidxarm ${QPID_COMPONENT_CLIENT})
-    endif (EXISTS ${DTC_PLUGIN_SOURCE})
+    endif (EXISTS ${qpidxarm_SOURCES})
 endif (WIN32)
 
 set (qpidbroker_SOURCES
@@ -895,6 +997,7 @@ set (qpidbroker_SOURCES
      qpid/management/ManagementTopicExchange.cpp
      qpid/sys/TCPIOPlugin.cpp
 )
+add_msvc_version (qpidbroker library dll)
 add_library (qpidbroker SHARED ${qpidbroker_SOURCES})
 target_link_libraries (qpidbroker qpidcommon ${qpidbroker_platform_LIBS})
 set_target_properties (qpidbroker PROPERTIES VERSION ${qpidc_version})
@@ -912,6 +1015,7 @@ set (qpidd_SOURCES
      qpidd.cpp
      qpidd.h
 )
+add_msvc_version (qpidd application exe)
 add_executable (qpidd ${qpidd_SOURCES})
 target_link_libraries (qpidd qpidbroker qpidcommon ${Boost_PROGRAM_OPTIONS_LIBRARY}
                           ${Boost_FILESYSTEM_LIBRARY})
@@ -937,6 +1041,7 @@ set (qmf_SOURCES
     qpid/agent/ManagementAgentImpl.cpp
     qpid/agent/ManagementAgentImpl.h
     )
+add_msvc_version (qmf library dll)
 add_library (qmf SHARED ${qmf_SOURCES})
 target_link_libraries (qmf qpidclient)
 set_target_properties (qmf PROPERTIES
@@ -976,6 +1081,7 @@ set (qmfengine_SOURCES
 if (NOT WIN32)
 	list(APPEND qmfengine_SOURCES qmf/engine/ResilientConnection.cpp)
 endif (NOT WIN32)
+add_msvc_version_full (qmfengine library dll 1 0 0 1 1 0 0 1)
 
 add_library (qmfengine SHARED ${qmfengine_SOURCES})
 target_link_libraries (qmfengine qpidclient)
@@ -1027,6 +1133,7 @@ set (qmfconsole_SOURCES
      qpid/console/SessionManager.cpp
      qpid/console/Value.cpp
     )
+add_msvc_version (qmfconsole library dll)
 add_library (qmfconsole SHARED ${qmfconsole_SOURCES})
 target_link_libraries (qmfconsole qpidclient)
 set_target_properties (qmfconsole PROPERTIES
@@ -1038,11 +1145,13 @@ install_pdb (qmfconsole ${QPID_COMPONENT_QMF})
 
 # A queue event listener plugin that creates messages on a replication
 # queue corresponding to enqueue and dequeue events:
-add_library (replicating_listener MODULE
-             qpid/replication/constants.h
-             qpid/replication/ReplicatingEventListener.cpp
-             qpid/replication/ReplicatingEventListener.h
-            )
+set (replicating_listener_SOURCES
+     qpid/replication/constants.h
+     qpid/replication/ReplicatingEventListener.cpp
+     qpid/replication/ReplicatingEventListener.h
+    )
+add_msvc_version (replicating_listener library dll)
+add_library (replicating_listener MODULE ${replicating_listener_SOURCES})
 target_link_libraries (replicating_listener qpidbroker ${Boost_PROGRAM_OPTIONS_LIBRARY})
 set_target_properties (replicating_listener PROPERTIES PREFIX "")
 if (CMAKE_COMPILER_IS_GNUCXX)
@@ -1057,11 +1166,13 @@ install (TARGETS replicating_listener
 # can process the messages from a replication queue (populated on the
 # source system by the replicating listener plugin above) and take the
 # corresponding action on the local queues
-add_library (replication_exchange MODULE
-             qpid/replication/constants.h
-             qpid/replication/ReplicationExchange.cpp
-             qpid/replication/ReplicationExchange.h
-            )
+set (replication_exchange_SOURCES
+     qpid/replication/constants.h
+     qpid/replication/ReplicationExchange.cpp
+     qpid/replication/ReplicationExchange.h
+    )
+add_msvc_version (replication_exchange library dll)
+add_library (replication_exchange MODULE ${replication_exchange_SOURCES})
 target_link_libraries (replication_exchange qpidbroker)
 set_target_properties (replication_exchange PROPERTIES PREFIX "")
 if (CMAKE_COMPILER_IS_GNUCXX)
diff --git a/qpid/cpp/src/CMakeWinVersions.cmake b/qpid/cpp/src/CMakeWinVersions.cmake
new file mode 100644
index 0000000..93890a9
--- /dev/null
+++ b/qpid/cpp/src/CMakeWinVersions.cmake
@@ -0,0 +1,57 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+#
+# Versions settings overrides for Windows dll/exe file version resource.
+# These values are compiled into the dll and exe files.
+#
+# The settings override precedence from lowest to highest:
+# 1. CPACK settings from cpp/CMakeLists.txt
+# 2. Global settings from this file
+# 3. Command line version number (only) from add_msvc_version_full call
+# 4. Per-project settings from this file
+#
+
+#
+# Specification of global settings for all projects.
+#
+# set ("winver_PACKAGE_NAME"         "qpid-cpp")
+# set ("winver_DESCRIPTION_SUMMARY"  "Apache Qpid C++")
+# set ("winver_FILE_VERSION_N1"      "0")
+# set ("winver_FILE_VERSION_N2"      "7")
+# set ("winver_FILE_VERSION_N3"      "0")
+# set ("winver_FILE_VERSION_N4"      "1")
+# set ("winver_PRODUCT_VERSION_N1"   "0")
+# set ("winver_PRODUCT_VERSION_N2"   "7")
+# set ("winver_PRODUCT_VERSION_N3"   "0")
+# set ("winver_PRODUCT_VERSION_N4"   "1")
+# set ("winver_LEGAL_COPYRIGHT"      "")
+
+#
+# Specification of per-project settings:
+#
+# set ("winver_${projectName}_FileVersionBinary"    "0,7,0,1")
+# set ("winver_${projectName}_ProductVersionBinary" "0,7,0,1")
+# set ("winver_${projectName}_FileVersionString"    "0, 7, 0, 1")
+# set ("winver_${projectName}_ProductVersionString" "0, 7, 0, 1")
+# set ("winver_${projectName}_FileDescription"      "qpid-cpp-qpidcommon Library")
+# set ("winver_${projectName}_LegalCopyright"       "")
+# set ("winver_${projectName}_InternalName"         "qpidcommon")
+# set ("winver_${projectName}_OriginalFilename"     "qpidcommon.dll")
+# set ("winver_${projectName}_ProductName"          "Apache Qpid C++")
diff --git a/qpid/cpp/src/windows/resources/qpid-icon.ico b/qpid/cpp/src/windows/resources/qpid-icon.ico
new file mode 100644
index 0000000000000000000000000000000000000000..112f5d8f1f1c7be67e0ca422d2fde0a36facfce8
GIT binary patch
literal 52972
zcmeFZbzD`?*C;&a&<&D;(yeq#cPJf-)B!<4knRR)l@1Xk6eW}r1Qa9`1eFvN5EMid
zP(+YANSt@hLH+uB>b>`KKR5n(hO_s~teQ2mXV0v)W-9;)Kn~d1sbP)}7LWiu0{}2F
z{i-7XsKx_;n);y559>Ju0EmhLNKXvPDFJ9B1d#t%ofrTodMy7zy%*vrS+V>Fbr;C{
zh8s2j69TXU4?6&q1b@q82jx5f+)Mr~57r@{S?zCm>>!Z@fZdMY^4Nh3J^-;V0N{u6
z*x{uDFKj>l>l6h5{DG*bgACqb5nfTCqoV^NFt{JUV6Y{4!9OerTmLUp;=f`OBY)Ks
zeEfr8F*g-gM|;`hb5qNtCNLhLy%?y85ZpjJ7lo@Q01%j%7>JNE$C0DGh_Jkv1pgB_
z^okcTE>AM|QpOg%ybj2+8L73gbwGr@W8(aSqU|7NizpIXMVp_+YyntY0XXt4|5OZ`
zhzf&=GQpxTiC8FBvd;lK4(Jcdzgol9qxdiw?}OHH^=K^K1y?-4YePJQ{Z78H?9KDL
z25EI*`*#1-MWL*9MC5P47QQl6l>1Ku2{=`$rGDe>aiU_`e=)47;3&5cD!3k@)zuFW
zJ|;vEfcB#Pr3o6)A?&?4?6ISPO9?zM0e~CT0|0!;2ZQ{J0+X2dyYz2zNcn#?Vdpt~
zwE%qm{x8h)gHb^z1j5O44LdShcq)J}G8#LwXbv^TKx#&FEI3Lf65<$hv0&_^gVPT?
zOILAE#Gi@U6N3rFKD;gS$W=ZJ#tuue6$Ixh21AXN1uwJ_28|DkxP(kai~cUFq@w@4
zg$OvOu=Lmjfw-n%5i2K}9|y&(z%us2Ca*{+R~0r6NpN$^3;S}Q39+hR&<LKuKn7|E
zfC;{X|4fjrz`%o!<4^}TEdGCI!airX^x@XD|3m8;TmrV>U<ObFra<f%CZfGjxba2%
z%V5xOj5dP2Q@5z#;H0icZn0s<VMF9cBsSk<!@?m`<dy|CUx~!vhTIEIg-8g7%v&HZ
z0XzPf1g~Fj9vW7#%j^GA!j2R6U9f`}c0c;h5*H^A;O625Jlwp1mxmwl^9ce0{$oH;
z;5aybOc)3q7XiXTqCiwc9PVx6KwL}`NJ>ZpX(?GCD{}(KolpP@@`^x@M;Rz9Yr<Rw
zoZ`^}r?^i7U2X$d*9R)fYCwzY4A9{+1*dsUfX6WlaGJ*v7z;ZAb;WQHEaVDdAs|FJ
z1gNQM0BtQDpsRBd=<68(6Js-AW_lW!o1F$0XU>AN7FNK@(i+&>pn#5+4{$-91C9>o
z!TIyfz{SZGxVl^bZWr8vyW2(JanTb5d%FTp4=>>D?F0P$0zhz32nY=c1L0v2AWFmw
z7_eUfR=iQbh9?GC@+1K@Iczx{*m4yD6n6nQC0PjUd7^>;u>{~Nm<TTL76Lc^YamEC
z2L#Hb0SmS^V9s+7SaY@kXWm=Df$I)%;<*DHx$go8?kaFWwgTAkJO++3_kodC0WddD
z1I9juATlxvSfOqMQ`R0}cJvuA<md(FTu*^DM+dOr=>nz#-M~h;2b_`a0cS;D07LE}
zpwIpqn8^$S8>!d8RBi|u%e@2kLY=@#67uOz0w?PMa9(u;<`clxbr3j24g${$W5C^c
z0)#q`fvCu6kQOlmEVHVBT}cxNj-3J?kH$f0>uV4beF?<H#)E`}M39(}1d<Yy!R6#D
z;Of;Bkd~Sb($g|PW=0ms%FG5?S=k^r=Nh<{n+L94%LDn>3qawGLU21T36zxF1h-3X
zgYvR+P*Gk9?pEFd_wL>U)zvkisiqXv*4Bag`UddeK_htds0FmNw1UTv+d$gY36PyR
z1@7J$1a-wdptA8js4D&d8X9Ln%JVVscyt=tAf4dp(=N~jukNmH(A)bQ^u6o@{rv-=
zzv~Sc92^2e@Ot&?6&M{E1+QPf0n?Lj!1%-jct14(CMT!ByLa!w%O_tT-vSt%S_Y$U
zzk+d?PmZjB_Y-SiW^xsb&n$u03rpa`hY#T6$2sun(<d-LzW^5CHTU%!SX@{HOG{tD
zw{PFT>i11Bzp@4vSJ%Nec&)Ckg3ZlM@Z$#>Y@*R%dwUz~?d^eeV+`2z#(=GK4A`#2
zfSqBS&4ha`S%3%-0!Ba?cmWfT1{^>w2mpg15v+hb8VtB2h5-%681Td!0|wJEV5$xS
zz7GGxPYn4fAwNCjXMy}2ke?UwABX%(G#FqZh5_Ej7;wcK%1Xz8_BsrBJAA-DJ@LOQ
zjaQCLOicfe%AbA~9ntqcuF7<KRCom>$I73^r9ZsW)8o(UYHAu@jzjna{KMWmeQW}|
ze<|~?^mPe><j}SU2qeYv<i=kNWgaTV<v7NFkv~0}&J7TMCBT#Q8d8*6s;K$mn!{>=
zlaDQoXHoq{`>RNkJATVTm(`^WOZJccki19W-%~>f5@oM-#PQ}IslVlykpCj55KGD}
zD!z7Ek`f6acpB$UGMfdA;Cg-_AA6t9Bfyd4i{E{X69sSM)h7t?*qu!2wcQ_M_5GD_
zY8B$+$b}kz6CdOct(?r6G~Gl>{-MR{Gf_{3B`3@{Q0{;hmfwUp=&`6@utt(J{g#d!
zpV7kzs4Hpp-{g?#sh^2HgQ}elY@6pbjsc3s(kMY{Bw_7=+&}lOi>FV~sksKxV%v^|
zlm}^gq6rU@Bd`A<JSaSIKBIhy^L+5gU3@4GzZFY;AYTfrjojblaP)?}^*HFb&iW5e
zPhW!K5c0npnC`)j4Qc=1^wZO$_YIFS8hAy%g5XhVD37TBxBSaU$R7W%<kQWWqHIQ<
zcd)Z&dO8EEK>Du+rum?FyyyRhzEMK<c38(R;3zTF=-4m$1NgABg8xeXIwO4`|It4%
zDJY+C6x-v8iM!b0O8(cOe-8EdGcO=pHnzvL2ji20r7ywFihl(Dn^Gf`kH|TY4@V1u
zXu-<=*EarU8N?1r;(>fcNRAx9y?OsB!)p>q6N8mMJ*|j`MB)wpE$!czUz0$EAU#$I
zTO=MHX!-Xve?tc0j6uX7$WMdf5qJN_{`>Mn>@tvbAiofShlfo4_cZ@NCZ?}Jawrq0
ze-8pGB>WHdKPt&Va=d=r08UIC#)Ij<?C@(cNY4u=Elwj_Boc|Z@*j!)4a>!<183yH
zc-KLNkd&jpk^d%#G~?Wm9QhE^AM}_XJ^@7NzoGk6otVCg6)yw<2lA(j5qPl6|M8GQ
zr5kXIM>UonCx3cE2sVHu|4*LTa~iC8F|2HOL6(V$7C1c+2<oOkI$#S}S@7z?Dvu!V
zJpkdzC#G|;&l^cz_%94Nb?@QUY-9lr^IQJJ1a=94osj$It%r(FPY>E+1tAa#ung0I
zblhD5&Tu#{h-{k<P*`MZ9QHZEq;$~F1O0#TCE($~_ZSa};8Du0ZfdH&7Q=TS8-WL3
zl)vQT)P&M*kVE;{frV2YK94_%yzn>qANe@tre8?Id4z2Ow)7|A$-KbodqDB0a8RAD
z6UWDqL(L8t@FnZ9)PLx)y8og*$a+(bL6!sg_{Y+E52z35ar5(6@gEt}V-E^alao^m
z8V{EI-yFF7?-Bi{p?@LyU#lGWMbI0^rT@<VPmcrEPi2Rf3cUWu{8YX_ekwn|AkI(4
z`KTh2Kt}omkd>7?@JSVvfULAOP*PL@;-aT;KBzUnIdBoQ0JePR0E#aF7;y#z8{S}G
z!5ab2@w)&gfncDjq6XB}G=PS>7SQ_34>iy?0!D@=IDZuDi=H;Ofc~f@usmxGY^-eo
z%GM58nuh~Bls#~=aRBG+v6mxobaVnP&d@J)b;J3kSYOn~+ZXuy`s4i3fPf$n6c`Lb
zLl1mXQ?58*%8>yqIEsL$P(1J!P6GzwCBRVW4nT3%0c)XpaE7-TnDDg&ljCi`lD{1o
ziZuggo>Jhga0f(2M1jEIJaG0{A3&WP0v8OQ0~ezK;A8m$*l7&|m+~jT_x3Q(-@6nO
z3*zDua6VpYN*c(>$OM_0(8q)R-EY6H>P{gjDZUAA-6{ol?v#P@@(OSl`g2&H?%usB
z&|G^P)YR01T6q2T>zbOH!NZ4-KwDcoh>xBI`B77#r0_i`h?@oV<@2Dieh#E}jDY6R
zcQ~I8>(4#weuneous+=I@GyAu<_(ybcnkftcVK#Y2Kr`mU~2k1c=LJ%yd7NyBNMA&
z^4%(!fw({Z8T8A(eOm_KzW#tY8hrh+4!*8$;(W5zwGFVowhlHnHo(uHKf&(q4%pq<
z1^fH^V8s>2u!Cs;CRq$%ZWsehjW@t_rUT5YI)M2!jE$<n*$IFMjQ1Pi1K<T?_h~TR
zUP}tVAUOalFxHP@KLjvJVgO@p3@{<y0F#>zFpYHpGdlbaKh8^IgkBm4^wN$&FHIVH
zX)4f5(*+nBOMnsc0vO|XfblK>nDqMqQ`ZYH!_$B9vqLXW8uIHw{&SE&2=b>u{!++a
z5Bb|5e-Gq`ZKh8_{!fs9<q!XH=qH|n5?rB#1SsJ)l+Xnwe1H;GXfWW180P<3KQ$+(
z2>xMzf70*r@BBZbNb&Q>^89D~S4>T=;$#;6qDVX^!^6tTE9;n?Q&d!R$w1i`*8(hK
zg#-&@Z4<bQ!Xy$}6st>b^h+x&f2!mG_7?&2lpd{GG?o#v!W6*_5eRk*_ux=>OHL$`
zN`pzk>$m<8O#*jLzECVBHiZdj(#fmD|LS#7Q7Q`_65kFd2#e0~(PEI(CO(>h(;nVr
z;Lh%j#o$tow<;5(F$Espi39zLLSfT3zp+I*o;rsP>&KmgR!SI7y&N$-B<DZEqm*bA
z4P$b0_>o8n96lL(O#y${vuuy4d!#|~U<4jvI+nl{i6r~Op5^A^bQxF6If_KOWAUev
zNU1;U>Df71zlhC{$TL{HC=$>55B{%$JrXI7#q%MN4u66F6y1<`LRh>Y5{dc){Hx%M
zL<(c^(n#d#zrcTrR!HOtEZ!Q4<oW~rs~`mBV)3DHq!Rvu|0*UEA`#(Od=51dY4-2&
z7D(h#96HAai6jX7w*>J-zr^R{WRN3~N0R@QAe{|~WX}9GLoUL}!<O_nK{6Kv1^$|U
zIXM>44kU5=hu|VP^kgi5%^$21=Fn9^aGb-*NIuUE&2q$P?97CygEmlvaAG47r0ncu
zIAfI14#E%SFD@$z7liPG1nG|BdJY@J3O{H!C-ek4z!D%RPlo=6W6^)5#Gnfof|C9M
z{Qnnm3-JHN8`e(w=X~iukEdf}>D>QCEL}uc3>Qlm7nArCOP7_A1M+f;I9tV8zzw)U
zJLK;;_(@$oU}#_rjEziysfjr_bJ_yN!7X7N+y+=%*#H|D3rE@7<7^K*yL0~%{|@!@
z1in6gAn=!+fsKD-W8c<%QNWBV30Uzb0d>h3pdk|nw4{=OId=xI;!eZGz^!<5fb;QK
zU?+7Gn5o<Yp;q-E^6Vf8w(kH*kuBh|=Qv0Tdkeg)yI|Zn2_z?923N170IV&MmX;2(
zvvY7U;=H`;pdkMSC@8priw~E=_;5u<CC+}RtGf@H8k=zTLTl?|P?p#WD)UA`dwU0X
zP&E(g?=ON5SZ?Y5jEntZ?S$T*Uhw?+LF~7$uMZdN9UXoBE57><bWJZoo8bqTo&5+t
z&wcn~A1p4yxb4?3xVY`t9~(Hk0Ba9yuJ3@&ja{$>W3}7RHrW1U7g%}$;FktKN-Y2t
zg8)2P0bm$I1I968;626|e8hNzMNB&Qj;RBin7{UUUT7z%LOa0<+6jKpPDp`vLIt!F
zo<cj}6%D|Qivi3#V}P0S2AD7D0JBmDFq^}F_GuA1$j=G+MIpZu<kyG%P}YCjDgW==
zDL(&Ey5Ri}G!hmgu{R$ddqq!Njs>{stMKuw8n{D%sq|?q7)#^CPlSY#X(W<Jz{&Xd
z2`m^3*Mre5JO)lqMi}`M7Lz*n3$B9%WE!rKFu7?7Nr=kfz&?>CNF?KVEHpCGLtgxt
z2;Lc-Y<Ef|og0L~#xKg!2r4iksobILNNpt27DpWEZA2}p;B7~M)WJ4OkKn=)`$W2M
z%a}nfek22g!|l}o2aj~Oa&(8_$TI-x>f>`3fM1Os2#bt#1xRZjA47n|b`lCakmeKV
zjgK(*@v(s4#~cg`#Nd8zNMPyXa~>cJf72gGvH%EY2ss3JaB!?7+)n^Wiv_3wd=xhS
zB|p-E5TTB(yOJRo{<It!>3JAI?uLc?oI(I*sPF;38yga#hXecgz*mn#7qUb~x}T&(
z0_9&|A0G|q2oSOG^B;v_Cp=9^@Ec>pih%nB496hYZ6WLr+{edGo9D<89&Nkdl>b@&
zzk7?r?qk&OVu#m%<!>LH2_N{{2WP=TxU*pF{v{?V0i+~laA&~M!l&V0rH=ELb#+dG
z13wwNSDC`I&NDba+48K_A0OG)#s!|&I^oW1ot<28=e5|gT0iIy2LuEj>{CI(AS^T-
z=nJNSGw`w$$^@>GNx)Az59i<dY1e{C%Q_Hw?h%N+6o)&fymI9#ZqLD<QRcxjN$h@8
zSXcz|67GTg{8H${mVh#NCW$?l#O*iD4?%ofKj>;-0$rUQpyyc+?mTf|U;yWT!l)8>
z56=ppjC=;u@0Y>5sSPmv@eABjX2IvrpK*TX=b0^d&i4cE9h+cdZ3m#yaR2zVcfjEV
zND%<=jQ}9@0)RLT0Mc3j$lyLgxdO)@a|kHHeZ&gxBf)SVxd!)<2XG%5{c9hggZ!LE
z@EqR@0L3%_^lAZs+b?il!G4251Ck+s0pzcS{2h@07381$i=P+rs~7?B-}~5q``iDs
z=fZ}+5(=9eXdcw`6{MvV^$qn-sNtX@@DvJxAd%n~z*bMu19}-PEm;N*PIWBT5u~Ic
z3Wd_;<055+RV9QVtf5ZvaLXM-DjOQI<Lkhxp}e>T>LdZLp&=y=7HxpS^3YKm8j>+#
z>j#O2+|ck4#qSylMMZ09cpRbf8=#65GBnh}qcu1H7|`Qu!v;kGBen&U4l@vgRYOA|
zB;ip>Nj4&+upzEjhDuB@PK|$9$?#X*&`@7hRUb!dh<$(mS5lIZfi?vxGmH?yJw!*t
z1iRYeR$Lf60@gm|PVmzlDP0X!v!J(2Hbg<@-EVA~n$~TJV~5nfYtm(<NV+0p=x(2(
z-<aTMs68fFzFtX8tV3kHsIPK6S4HiVnp%iY=$<o`ZN!{nw$EU{z7GScEiJ%l;6(k{
z(qm`Fq|1oN*+xt<HOEalHO}<i4Yzclk;pGkO`;N;C{B*6JpG@ms1nZ%TuxqL)p)ge
zlrHzk)JtY+lH#nH@9(pRzN>K;L~42W#^`|CN7ikZHxJK$n*aFY_Niu{ZE<l4@ideX
zas6}rgr}X=A6xIb>6DuA&-u7C$l((aaq#jIuF@alR8nGPzWTX(-kO2qP!w^eo%r=)
znS~F2a_O0wmo5=e&h(~p>9pjK=JykZg!1w({k+M!un{7RKD`;<@~+dinl^AJVDaK1
zlHS84{Mjd69$2Eccb*OoQVC{f>{%lpSYAyg$zJigoM7A@5x(Fj*Xt;bPe`a%Vzm1y
z<os3gRv{`*M3%`^Z(moQg!47_{PgSBlZzTXd!A?V*-PhdOYm_P2L|kfW}YlfdofN#
zYxnc$R?l8X_(kTPJ?|Y0KbtMtSon>sr27=p#kUO~uB)r4uzz`T_vP~sn{GJ)iTLcZ
zZL2Q_+h;o3!iQKWWc_EkQ;y0L-s%M1Me=ngZ~vH>*T+|#bChI$_?+g*kt@9V*Evg|
z)piLvTpb=N=`u9azF#ew5hF95t^;`JesU_3>kS1ijYq$}+op}EpRPf*r|31VjkK^w
z^X2CUOk@yqBJj9GI0?kb&b`c5cX8oAck`B*-ONb&nHnV+xoSS~LCci`4^DzzLyM}@
zN5<RPTwPr)9tDvM6e&lZy1|!Loc7J;t%}=AkES&$<Te>`KWhl_yHG#v?H`}EF`k&c
z4D1ZrC5YVJmw!`(O1;b|Jeyk-5fev)sOSxp>wCehBhTK?C(Dih?d=2YI5g=3W*tP#
zddZ(;=76JtJS*d2w{}P0;(-tSnQt|=4_`d~Qo5NuxP(z1jFG$)riG9H<8YTo&rDv4
z`sxZ7m2Z9L)eJR!_=q^BA`A>M(~sR419pFqwOQ>SJ+r+S+Axy4@owM4zRsdqS7R{C
zfPqk9Pm(o!Y50&cXV58O4de>vvI3#+C5ENe6TY>9-<5Xz%)$hO-gk7&7J4KRDSmIA
zvSv*fY73WFcw0$d_+=W?9?`?daY#kr$&JBh;e&K(^+Cg&?$+%HMq%q2#0kgA+&Jf1
zp(zhemj`lY)h34xDHc-SKMv*M=TF3>h-5^;*8oKFp>^joYr}U^(O+KH1kD`{FB(`l
z^(Ea#7jaa`Qs^{mH4{C3T)KnSEt|>4#AB#J%+y$72g`jp{S&-oNTg3pOk9%)m3~uw
z_VOtK0b(*L5veWID;3AI{`cD7<ot*3o)IBGs&pmcSjz`8NA^QesUN48C&E4B;^M4V
z#=_c}88b3w*r+=$`Gwi1XP+P1DY4_qf1MorB3smb+-rStZ0j_-PNbC$^<s#QWQKJ)
zd--xJnnlLFqlYab)@`hMmHoyf*O&&Ha3S184-sB%R&l7X2#tK?_bueuOu1~53U}1G
zXM0M;H`<pv`tneAgUgCj6B<21ZMC-&(azK~7USA2lt)*ld})JX4n?;=JQozniJ+rh
z-iVmmO3%$r5Xj`U-$|WJ&(Gh<RiUG4qY8A9y1^V97gwS^$QoondzqM`Wt;V}{wyaV
zh=wYJYFgMT{&3NNN=S%Y)2e`v;nc<{;oexTtHmd?1%tM;F<$jiGyQ>rhoY#a(Cz&<
zek`}6mm~_awY?V|zg~_($<1tjGK#ftS~j$s?Mf=|BaWV_3OrtVCF=xoW%Sgo;E@M8
z!nRka-ebVT*|WqnulG#I<fM=D^Q&x=ep(%9a1ClT<=YSUOoNZswr#j2Z!P=SnU&>+
z#qkDjt}`0~Y1$f#M0xmhI_v0<H$*S~^sCt>jLpb2(FJOc$+xVZcWxEsqSTzUc(+zA
ze~FktKKArE^u}`tnBFl^T}xnV+Xyd#kC4c7E@EC+>=Rq-7Au3WMQ<STg*0tkyL-$V
z_^y8PAP@e0xOMkSWKicwh8B{i5VW4ZWNfhCJnY~#(}A${IJLfVxj6e&_t`62c!S~v
z;{JkxNV2NvkV8BvAo(M4{7Dzg{O#QItgKjS1j@_1)24ImQ|sCNoi}4m=9`bVeK(_(
zkCC(#bruaSYzjVEzR=!uhOuoeFl-UMrK-B6CdPI(U-DV$bJL-v5~rrZyJbDAk|*&I
zbO{{~=cPQCt^3eu+Brr#uh40m$ePk8HmKB;M)%V!j^Y9%PG&}KqfL@56gzrSKLrv6
z6cmooq|+#P3uL9U<tfq~t2x)+!+nG@K<K@pisy`~(TNii&E6jg?|V3M96Ls~y%egc
zsTrp5Q?c^rDeVgZ`8PaE<`i!8>jsWr)Qy|uCZ?cx8p_t1TK!IeO~U97aR=jU4d3H^
z!uqZGdd<quV!J&4^L(#3OKz2NCmRz}kg0d0gSxuAR}VRSntj1l7sAOb?cRH9+9Q&%
zFv==ZHh7lXpg=ZdZqCv6$8ixEs^<a%I)<m5@lCp(NA=$3KBLSzO|AHm5fyRxR?n3-
ze@vlD1usC+2shP#?`GsZw=FaMUhcDiu9wVgalM;mT0{L<xiQ|w$)=C;A$sn|zl>Hq
z?a!Niwm4E2TsP9%YJFtqBh%*h$sQ6_&OHn>Ns|n<07<d4p`-l%Ly{neSKRxGD4ytZ
zd;o=f$4(G>g+-nrU)p_6lk4P*@bucu5Pf#38?h|`H{QY}b|f(+<(zz|?3TrjoJoz1
z1Mel)_T3*6jTa}98`dSAwC2`MpBKCnx9#JbIjNdYoDN=d7yNva&nhp>K%&Av)IU5R
z;nBymG*O>0+0J8Ml77*qSLgDV_pd8Vb1Qzl9;!IS*x){K-^`5ZMQ?A%m+xoRUM-Bi
zJ-$6l;E}Oizq9da>*E{liotUUDMwd3d)PR|Ie$cd(tsb#smN$mF8F@z`M8u<uN2v4
zD99@${C4$uO61MZK-R2RcP{3e*m%yYFPh4R%<)J3^p@Wg&j_fUSJ^s6se$6f^ND#y
z(pe_q#9m^;v;UarEUIvGaO!*W?HI6dCqh1i?qko@kLMr7#KeSe+D;t}O)9SB;hlXr
zU!<O0X?}tvi)Y9c`9KsC@p?;vE}yyNRd8#|%i5agH>RqpN@GJ#gEyY)s&E4~@NTHi
zA=0j|cQ{PdxI!3(*PpI{_8YLyCXttF397^ZNsqVqZ7uV`RA#R(zb!T1`uH?~%D2DQ
z=G$1=%*}^ijLST1!j#;21<zD3(Q+F(kwkfX?pmc~lJenxWn%iUY-(&d`bemw`m?Ss
zyP>qsg`pC>`qjIPTMc2fORuY}w(z7qr(&<_9b+GfI>#LLoJ!3tr4JF3u=aUSy*oDc
z5WO1e0&$eb+|-0Glae35Nk(QcEhQ>Xx&Nw}b<4Z>#6%r(7BQqvOTa_(N0wd6PwfL|
z&`BTBGmp1ccRbs@DWWU)ev;C7`LZjs^<S6ixmVMs_Ryzp>%pc5ve|G*->CHM48rhZ
zszXoMNgM8YR?U%geZzD|I=w?Pmz;EU5&mbdOZoCrvi+ndy+eUc&e8T|@2@t$d-|H9
zr!Zgnj*#kn(!;6m*WgOCK)BFJby)IR(*)&u`i-K`DmKwNpZHSudyTn_>rYqB7M`x?
z41AgEusK$r?zenIS$Kn9o1>d#eQ}bJE%Jxh+?IvpY3``d*w7z?l!s#|zRIj5%A&4G
zXnvW<TN$fDvDLJ%%CSbwrOy_cRA@Lk@qQl2yF@=-HM33Pcg|?aDSG6ChKH^2Gs9~g
zm*R-u^G1uSg5@N`uziB#md$AsZ)lXfJ@mdrXgG3fU1g0Mc6dg&6LXxb_{xB8&Epgs
z`9RhAvSaU$P&MKU2vnBW5|2zrGCqx`VkGGp@iP4R&UGZH+ZM$?($CeEoIG^fN@if+
z|Lbd^Wr1vg@w|!$F?j@Y{G~&lKPc#A_^+>hJX~}W6NRwl!76e0bamHdk=BlurwsE0
zhJ%U8+Oe^*KJt-s3&TndsX3Yj@}Uf#kGB~DzQ663LcEaRulCogW0l;0b^g?F>Dl_0
z!UP?F5&uwHO1ALs7Exd`o%6NhC(!(;0%VZWKta;U>|=~uA8A(k7Q&7CiC)|-K5}W+
z@@0dTK(t$TWi~NoTgwv(PQ>n0$NKvF!)0eg3eM}X(OHLav~lnHH7a|pu($sBa#zWJ
zoqv`$V0k=RrcCdX5>hTih*CeDk^cEh?fGgO(Z~<TeZ>;pVzWb0^0Z$koC~`f`}2dP
z@@FgO)O%8*-BrWU&-oUnZu@#GGsENLWUAmBH0z)B^F8T#S2rK=YKxkigrwx%%jBK5
z5kjPc{T_|^{=CaFWd@HAPowmBx_|ii1~cZRDs3}SNqO2%rD}HBbjDR=maV)PT=p1v
zZ#yaDpjKef>PN!rwsB1dY$31D4d2opt}#T(=6%s$o#{s0-&*|icxQh{M@NT$xrcL>
zwJzubr(Wp%(P~|Wgzt$yg#6oITe6SQ(C-b#xx$%$F=njBxj1l;Rp;R~>*E3KEr<Gw
zJ1?!ik@xg9H_>?B)utG_`owpTgG*xM>-XV{q<&vUNyu`Ke=gHhOH--f09$jt>1!Kj
zP{EJGWUd+xD9H_mf4H5y^5Sj{-Pbkh4~MOry%3j*SQAg>3a<`%dtS=OD^Kgq4Btt_
zU-8VmMLliIrA2q@N_z|7dyrn(5kNt6n<&>r_(PuRB`>iPd3?)3v~+AL(I=0=_eMLm
zkT=>y6-d?<OdauC9w!+a87UcdX_aeh319!}*&1E<v4?)rmzv{<_%+uPvFRNZre&=L
zNN7ebyscu9As~+Ab32~{j!??K5BlccS0q!!w;e>AHDoV&c;(sLbA>{b#-iqh3xb7*
z74XXp3fC)7%y?-1Ty&NQ%C=7j%h!h9zY85|GGwb^j3^#QW)3Hg@ji|gbLa`#+t&<Y
zJ5yubITL-U*|Q`6I*h;hG1vJHvO;Sv<O=>t1w>kAsnvY7j;`+Jmpq~1oyGF_f^b??
z$n&pT!Z*=rg*owMKQ|rRgg><<2TzIcm*3M)WxcljI+qjC%qRIV({S|z5nIr`)hF*_
zlKl*V_D|@Yt87oaPxQrUv@Fn*RdJze7ePvWvvTNEj*#ZpH&vMVYv<!ZkPybSY`7hz
z9I<SWXZD^scd72Zp;A&FYT(Bg#mg%~M)etOhMOM@>^up`hTn!Rlq86Hc80OeMwCru
zlOVke=e9{`YyF;^*v>q)Dvn9fpCCg!ZTsBWPf}GnfArXydtJvw+Ls<s_B3otNQeiy
zu0~%XT>bt|I21O$`Tbo2Umoe_ekbbDq=a6liKgk|kgLqLEhw6{t6O&rdl-wtqdVBY
z7m%l^52aS^paQ;W=(sH4xgy~D>2hc;{QGnh8zrm4!UKuOLjB%l@8MTG=iVvNL?ZIQ
z$DWk#M{I9`s}RR7YCVmo=+0_-FBpnn>-v$`c4XQrMfp&~4|L?u31_%vnc6-yq~Rem
zTde4zedqn7OSdM=r>sLlE*fpWCs*hl(#~x(OB|(8V(9lRex%GGxGIMwc=!3@*6XF3
z$Kr*F8A<9yRQ4+!(P2+l;?G{capP+GEiH$)EhGD1oo{CV7v#%ak)BA~uq3i}nV1Ov
zfvBI&;cM@Fx}H5FRf61C3D!Q_|6s|aq2_O8P{}W`uI~7Gl_kwWakZ@=nkOE(cva5G
zEi9Iu7zyE;Oubg{jQxY>+lGo_ha`SQCdG5yr)zA5f(R}Y;=u^O2QF>9pDo{ie1CV0
zB#R$8-ssOlsIZZBW_Hh2A+UCkC6ku~Hu>sOY3bU+jw5Q$X<p?P{d-;gGGyrHH%&i1
zy+v*ic(vVDF=QpBO^s;J>mrvjn?CD>c+b4&91I)O-Zd8WPC~X}%O}c5FLaV!G3lJx
zH>Bza{oalWA+eio3t!lBWUGm_c~wVw^<mJ2NrTI<+EATFmMwYs=GooehSMcu$6uEe
zqqDABNpp#d|9E3@I~n}k_;wj@XEU^W&9E)L<Z1l5w?zTj#57x%;JB5zl?hL!A9uWX
zGDA`P%yYBwh*`4Rmx0TWL*#C!{7;j<_90EB=cCYC?f!hxiiUxicfo@5q;ea2mrO5o
z=OQaRcd3Aiw;%<Jbl0w?OepHT5J?s>@|w7-xYK>2!-wew#_{|vF-sVo_?&Wsl`-r%
z&26@<C-O5D`?5ah+G2#74B4!0Pvz^o!)@w2ui&CGll?MxxP98RmHBd-ef#q9_5`*F
zrs;^Sqh=SrJ2EEo?~OM{;5|!a>A5kcb^$@hs&{*VQP{RGlzEDR1g(H@pQ@$7BO+Jv
z^J^%MAT-(g7C^)xbT;;Ml@*zEO5*(_ggfnIdu02J>r*<;)~$|+tYc@Y9cclDmW=wB
z5l`(@(uj5K{kW7=<&=kO^WK|u98WT#El3=)vG9DXE{*1%AE&5GFLmqQz+|95_reH%
zT24+p+*rH^+tXSwRf+ANrf<5|JH=e(y6Nt)-fL{Jws#>mHlA3TFb`o~dAi%MeRr2J
zS|}Y~)c=Rs@w2TuUJsIx0=?eio}Eb59vb6DZ|FdgAC@Jibn+0ym+R*=&C#V&`Z>q7
zzA&+d>IX&KU`yqjWmD(&+B|{cPFXN5;@)I4f`VC++WiO(r%M$Dn;f~7v?s&5MwB4o
zRaSY1?`@d(Ro<tLAa;MO4KgVQ97%ma`-*q)<xBP4Y8x@<_twLkj2yCXua7GkRCu`u
z)V7g&TC|4*&pgREf6AyWEG|PAc<P7K7WH52RA-4p@)!>-8>X}y+>nO@N=(yqD|C#{
zYqrZ<_0n5$35mLpZ<Y<Nlb_k3s$3wDbD*4tt1fiQL)Dz;!rZpkWo;%?;WbNd8X8Wx
zw|7pCk>$NIa0~52uR;fd#rn>^0ojT!QnofyIV9kFXB>)OD(SPEbpFa0w;JzI-B@DJ
zXym}7z_0NybA`!1&)mrrdbGK(PUOkMmCb}iN4!3H2XW<)<oBZ1+jK>HBLhc?1>+kB
zIbTRSg^SUemg&*>UCqR}Pi}rIx2*ayeI22s2_(VB+gme54m~L(7r4^DP2UX^v0X5Q
z4Sj5yPWgc^6P|8c%PvD&8d@0{8NqCHjyUQSGs|nY4u{n^^8J#m>2J!I*th;)h^6C+
zX)yS56yvR~v^5?=`276kTK(7c$k3~vw~*l}fO1K>!vRw<l5AA`t|*zm+WG;hs%_;*
zVYRLs*JJ{P-{<cOqrR$flNeigSz8~8uxMws|6q?XC0jXxWI7RsA2HRaKeV7M#~JMW
zR`N=|sBNv7Mj~3qh!W!<WOcK)*eFeWwl!RFa_Rjw1(I7@sltcxhe~Wh3*>!I*PctB
z+r5=1Y|#u-A6($+W#ZJB5+YPoqz>I$qUobb%S(SQ^C<9+;o3!H@nzFncweeBLN>13
zZKJa`#+FJFf+Cgc#>*0CpS|g~T3M19WH&0#<WKeshYnNN_C{{ssL}qIcd;Q&M~3EQ
zQU4ca{8^;ErG;mbTvAE{jL*D=b9d<D7$e85ZF<NzW=rJ&Q(Ah?&v7Y8e@mgZvvo)O
zzrNWK5$Y%-p6P#Xy4pQo#KmcHEnwP_c38G(uplWVHIUAcoQ89mfUZe7XJUS`@gnW<
zFWG%j=5B4;Et}uM^MUQ&;IV7Ufvj5=q=<xfon#TL=#8{9Z<CX#y=5#Kyf}E3Ffn$)
zA~GIRGv}W?+FIC0^+YSFf~oz%7qihcJ*jMrebRjX<;J(Pu27sI^9hHI5m`05ca9t1
z3YM;<E<>1IYw&DuL$7>H-QMsVLxy2@)yba82!ZS;*?O-eb}&`0-|ZG^?PIJ_v57kf
z^R=V9>na6`p{LXOQ}5dfth!7ZP6nfQ_FhyL<EuDhvN(9MnCAk(^7|%6^GY)sT=y7n
zX{9`QB;|%rrg!V(cf15jZ_IVWLmlxHEUSGT(Zs3L&k#CPDlf<VpWeBen3~FXz?3<C
zEmo6^QH(<6n2s6ygG18~0;y8T*9DMXsP(<A_fO{~lxUX}vX+V&gjhRwH7|FqMbaoG
zJh(eH^ZE=5p;<xVe?)fe<ymMaU;a)5HVi@^VZeK&UU?$_k6433IRX*A0{-3&&BP$;
zIY;MP;gbOhM*76s?B@wLzl~9Sk3>g9t{b2s<R1M!_YAdiWyz+cd+vR^7Z`q0G0m)g
zy-fXqq#+DVV@rxk)R28a;xb-N^QL;IbBj1C!?%3D-RN-C903o@!poZWS-~`7nzlrx
z#~~jVhHu4;cCsVOZErn`yiGVwhR+ps<?G>~(qP}t${&`;ouDn}(0Mbi+_b5h-64^B
zwfNfZPZo<ueiiJBqMnCT{B1dU=ZR<f7DpD|KD=zl49sm@$D3(RS6h-ih@#NK_GY&>
zKu9F+`~3X;s+;M>sALlQy5LD^mpt;R)K*e0!1AW1XN|Uy_8vadgWcty8Zv!WqNp@n
zcM24J2`^ecVBqG9GC-)QtJlFDc=X=cktX7qkEu#eawVKe0+1@7+Cw&$ubxGP3t&fY
z1z(t(r{v;S=~kwcvKt@hh}4-k`6QG+DT;<A1KukvgAV{lB^Yic4^bqfWWBPb6f})}
zW1g5cXJy0)-;i5-_jW`(I*Y_j+Dg>*1@{%E6R%)%6%l)0Uegh(OKbTXn0_Xih$FTU
zpXgIjs90h{4n@VIhMP;>zIX~3DKn3x@hYr#C!q)L*8F5ZC=B0*-(3jDZe@NxA2=@N
z`omFSZK<BMy^WZr5NZDX@cR0QtoLqg&-v)NC_xXyAP)sz!*JNYV&9$~?=PbQs>D%d
zY@}7Y*Cv!~x|jfs68S5$3jXCm<-M+!?I314FBzvP*;d7GN2fWXdgT4)w4>E%K!qt8
zgRsU(!u8<YpPU*&hy0iuXIsAGFVd%V6Wgtii(Qirf0Rn2vO_8B`}qnxzKU^_WfkS!
zv1--q%5%)M#M966P4CRUJX?=Wzfq=&FY2?--@5ZY^!#P`b>D8?rye$fi&DaBv3x6w
zJw<ju8(d@7$>*3mnC>82t>Ps?Ag$4hIEIlZO|+a-<c5@O<c7HhaqZb`U5Y5;s23c@
z97ZKR6dH*ubPRn(skye-5_`+}Q&IUpJ;+&<3d-<lm(86{Ng|HO`B>b;KmKIC&Z`q?
z%OQIbAe&v0SDbh|TFx8djYlpN7gK0sANJ?L{DfS-HvTJwD`h02H}XKN_$|ax`iqoz
zE%<J&>}s)PDtsUlRm831d*l^(cID_!u2S??%pqOiN2;PqpWo=As;76Qr$z*J2<vXl
zJl#^FE<Hi%3b^+DkcYyw@u)?q6Ny!B4WEPVbh&YT`~j`l;)aZ9;J^`&#t`Nyd?pFz
zk??*Zc0Yd6iT(Qd0oBVnLW&V^aZ@13;1DFf@3e72wbEh7oqvVare!s`13skj)@jU&
z`uftu$ieh0{xbeFf%0kLyB2~9QjP3{9s{OSndy+1O~fh-es+SyKjEf)uB+VmVD6|H
z7)TSYe@*qB9|&%hepcl-lWW@*X&c<#L~Qp2y*gfN&>X{VMxCCb{QjEc^Me+2^z}7i
zv>t8nZIR3ERcwV!N2x%jSXdV^oI8d}`%Lw1*90tdYj56EQ+OQ-l=jzYRjaYXk`}hg
zDd!(nKz6t67;@NKR`W^3E_C-_Ro(TZ>3BxLvNDAxc|uRnKd3!u`*;QV5Cjjg)4QX)
zl)E8hUF`kSS0hr0iarYq3#Oci9g0J=wBeUQIkVtvHCjQF8uoT@R9-Pf^ArPaH&8(M
z#AXt*Yjj-icGn71LpHikzPRxXnht6*gksF(aGBz5v)VqYhTmJy!108(c)7!rSN{;V
zTlTJ9((Ah)dy2wp#S(|AI(7C+TsojlS>h^D2Uojkd~-a@t*2BmvQLAZ*|orASUTWW
zDe=GiMzmg+G`&vSfd1BS?<Ch2wF5!}&Hu=M`3c@^>=%mhT4RTMHcfBfA{y&!he4qC
zwx$W>NqYNwyBJXeT^*{I@UfkxB7GH8arH6v9nqtRO}3#TXXMW#2x_G;3|=34-BeYL
zoy3gX{)sQG=%;=e+~`onWX(CU;;9Tr6)GXQ(+=z1s9SD2My+au9B;PgiYGskxI#Qw
zrg}(+pwj#<Lyi#UbeaYk4JRu;*}TZi1E7nJ6TKwBobzI~ySsav0nse7`?2xj!dMd<
zCjlpTL7G)d)UwfYvD~a8gWVy^X=uk^1pHKvEL?IsEOeUc#@Uuo*(}Z0-B&Ly+Ll<*
zL_uwApwpv%?S7D%a|a*EOvipW(~4Q76NVq(IGUJ_x?wN3$hgelsA@Ipw5sC_!xRyT
zU5U*};oLg6EX6}X0lgCA_g!gYVlF90TuermvKLoPM$QrVgeQY3#{TEeJ0&g=e%w-y
zNGKXu%QM3Fkxn@xMe3=?;EP<QUym>>kd3Z)9^jCZOU^efv5&l3QG9f2Pw9IOakceh
z(kiXXD=VV=TN=Dg@}057mp7yelp|BB_BdK)imA1u;Q0Xdh_MyZNwj+wj(PLzmt(fU
z*^KJcH+khcogS1}o|AI7cZy03?RnrfR(s*~g?m=@49wZ2Rc{+rTLLZ)m+O9P-(`Jl
zxFx>_&w7ts_0MlC(K<&zT4lrH(<pnCl6U0?h7o<=j^W<<LEousVhRKniJ`YM<1|m@
z%p@%vD%9TD&#h6cKv2IgP@qSJ?LTDS7$R=fO>9>V_%?Y==lg^EAY^c7Yx!y4V0*{F
zQTgCe%Q3!3_m6&dm2}eZn)m1*BcSQTG{4!t{9JauM?eF8x5P+r=w`65bxUEiLytkR
zL(3a$_7_Nm5$DvLZYI8)wR&{G-P4h&Q2dTG;<(j)I#XW5&w|C&7mBR93l#iG;}zE6
zdWOm|GP6izJ6+ScR5L%*G##O>=O_8r-#r0()Ws)XS7KgIE^lsph?plzVSU=&aJ&m&
zFx_X7x!w?uW0*kPs*2i1uEG9GZTvp<dhYHmy6bq`!P`u-b|8gKnX>Bi*VV5ht86rj
zP18cyGs&=gP#*5RRsGKE+ZU<w(I@!$>0GseMSNmkUy2Ysj5zzWd+stc8WE?fERtB<
zw|LuCKHkwEN>KdR^R_{&>tdN)gVvP1+~ciVd;>ExNo0vsTTjnx;eY91kH!Ca%OH;5
ztiohbBvM;r2Av5MZU~$y&~dUfx~t9hi9}9q>Wr-iYsmUirvsQHjq{`hCF(5!vVotE
zNLmh_A>uSD)_l;V5mvv;qM@ltCa!fB@A1znt46!!vHCjC?-3Tqo$v_>Zbm#MTo`>w
z`)F$^X+inx)QH@}ux;^bR6Aupt!%Imn_Lq8wq}UN>1vXPw*l4Iy;!e1l+NepMSW*v
zSwkB%D=vQ3n#Yvxlbz2n!Cz`7`S`ts4*hL~6mf<1M6w7kM{5cG+vr66&wcrqg>70$
zp%MfqNZQXnB0tt{m2@|^W+m|Mn@ZyrTSa&}%NV}18J$w`(5e2gRTCx#Pdi1O(FP%2
zcJ$|yu+a-|4!wFpuCe{HBv3Ft=X!GU3cH`nG{ebH`d5b*TV1Jl^Dotv7F*>C%Z7hx
zU{CUDc(Zucl)jjTOFM@giQbsuSdaW7pxS~qvRDavmTWp5a;jGBg*YXvY+{X5_*Hm@
z@MOT<DEH;_QA3`$flG<$x3r60NAB!yF@(1;?-=sdy%V9nb2CiReVB0DRe+e1GR6d&
z@dhcUh1m8*TBgINblj@B<%vyAOq!pcGOkoZOY5Lv$RpLCMVg&kvec0pY$KRodv;{T
zu=+iTBqEh9(QLf96A(+{H)ruC{iXY$XU_5Nrc>=79xNA7HnL3IOH8eaf~%p!c(1)^
zejnQ9je>Rm8}+*;?A1R0vNn{lvDzGF=TyEMRB<?T8M{bx?!1sfi`8>-b0U*5H2ibC
zaT%rbty{}2SNPlK29!BI>wAkxU3la8byqvJH{%R()OcF!&Gw^v`n7#3%n~9ZRMS<~
z(b&+1czj~Mtk1%kzC1;$$qCK|F{IrKFtR-7vORt)=-bt?5*f?dg`EvitE0r1g%dhz
z`O(L0T&A1lF1#sEDGg6BYVeYfoELs-mh!mC=>hd*1<S6w+W5~QPKA{kRR^9pVwW3K
ztdhi`f!}G4BT~dc5v%MF*QRpkF?<z^y}d0aF?Tddp|_CmXsV>^TYMM;KIBeLBV%l2
zln8@0z6oRWjhUH`+#Xm`qr?#Eg@^Gk^+)d|U{rM6HPH!LH?1y*xQyI9oZ`7n@Mi4u
ztskGl#wWxdE<39_WzkkM4-fIgb}%rc6o;hV^tttUrRCdb@6lMl(EXU256*YODV^O4
z3ge8jYhA8-Vz!;(Hx3USX*xRbh=ML~2W!RMU*%_wlDy*2B2(=1=|#*Hj@g>#pbyA9
zde^VqkPleB6rOBcR*y+0(ObDRp2EtIurSV~7vjzBQP7g;=HSG>YOO@NYu)RUM`M@C
z8Bd~TbV9&Uik?5w{{vM5GCt(Siq3rD&;`FCevh}WmR&SZ>oh~H?+e7~>zxMZpdTv9
zA!j)ixB_x-9nysVelZRkEDTs0=eQQ4u_m>!q2Q(IM@V{kcgmfP?yymbTJXYzMA6=B
z_po}$!>>kae4T4FW@onv8g|;(ix^jf5*jTO?GC-zD?na)OPVkelWcI}+!66}9#d(S
z={;HMZkht6_6FlzyCwIS5@I@jBzmsP9uhQ<Hv7?jDK!j1cYX46-RUWE>I+*Uy@Nfm
zjJ6$aHIJXkJ7n`C*<1HMTeYer8huE|=LCXT&FlH+6B*=*LXR{INqEf7%zU^d`=f`%
zOuszpjy^Mo`0*>+ZB^)HtKEPFQB?7=S9{4vt((RV-!_Xmh?M?3;=;{f7RXQY3}1Py
zM7#1XvA7eJhCDqnMHZK+F`mA^REI4p{%y4BKE?38!L=3BJ<LF)vhGQ>bE{7@gTB2!
z6Wma0l;S~(vDteHV?`s+92|nOLBR4<wD+wZAMJRf<GQ|gj&~g{3XhMz)NNv4sPU?s
z?uddvO|TQ=5n&Q?Em|&Xyn75>r2%BLwns_DM`{BnPnX`djh=A-be>?2`S77Vx0}(e
zN-yd>x!>L(J{MDT-rh3yWt40JzWGr>{4_%6dM=c+wtX<k5<Oj7ylh$tSyZJrQI~m5
zYHX!cNfxGESB2jL$v(1H#~>8Up5<j;d$ru8N{~Us=1Oz(51vdw{LQMV8=7+XN$CNX
zVq(gbI=0-#h~*5<s;Ne>zVVzUsSw7ukKP}uuc;}u)pm-eIqkHiekW?eB}z<&R<Mj7
zap7=A#=wX5=O3rMdD8i*Z&yV%?pGPx%u-!CK_YHNQz>s=-b>u^MU?ZkEph!z%B!Zy
zpfTR>1F4H!d2w}lESFleb>vZT^-8YQ;fO@y_C>w6$>W+FtNr)Sw-U&17sXyzchVyK
zj#Sut9O(J3iEqXq8I&;bne4L&^>M)=iXSKX@|3A;x_ebpi)(9v>*C?Wt0`JqmVyJf
z-*;>%a0%NyL_R=?W-%*UxBJk<$5=O9cu)OK{(=2<3kKfDXz74&?<n&!8VDKH=#0xN
zDiW^$uo(5zr5T8QZ`ZF{tyttrAZ+H-OY@|GEPI4Npkmwp5S@AYO@3QS=jJ21N2R9{
z-D9K`6FB95IDLzmT_;P!TuPp1JrTwffsEVFaL5)!8MCzV6$aI=Ps@MsM>ZE0rX*aK
zjEn!)r#5jCUtHqCXnC~0RTEuHvc>hZuth;iR%Nm>vy|N_>uWqGb?7e4*&1q=7m*6F
zdL$A`-JN~AZMKApq||OI>dCvilWwnk2^q?8Pnc-bBvNuMl8)+bo}A}PN8T=fGrt#U
zcDYZcJubcIlqBSn5IGXynCWCJO#QY?6yKaQR$(gH?>y`M-C1hu55}XOqvUett2Yi|
zV+qfo#j?g6`{F|BOcAt>XUmSZ2kpMK<pYQMR1K-RY7!_(DhY<BT<>8I6b&~QxyEJB
zlQ3pv)@=>dBwk6>ia1U9YHi&Jolr-AJ=HSFeCXa;2j1p@C95{FgfZ)`Y`4=)Hkw0~
zd&Vv=Rgyoj`?!zUd0Q4|d@)irr+*+NHEhI?%;bjHy-0{(OO>ymdOQ!0_agt32Aae%
zLKRvb^@vhL+<>){-#n+bP3*lWcKkPy<o?$KH5?r!9V3P1J-bPb))zAsLqEVT8)M$w
zEM~A9BtM!g;AyadzO(3$WOskxkTgbm#pz3FnkA@khR4iLn_jllmkL{*eOjm(%5lEM
zx}NuHy5A~i<FY~&FU6OV5Va#uI61u(g(#HuQPHh8CWcN)HVcZ_wST8->7tU(B{*5Z
zy!ct7xm+1M<{~oaH8QZFzleP6)gJXGgY=dV3xNp%Qc7<nyM#Dfl(T7`V=x5I=M*L9
z{eEJH>oL_Sr1ulDdoQ1vQBxuJOL{ln;t_EfpID8N^=y5J)U(v1d^*$Zld3EeZR$kS
zEVNc~#4}%B-@O6~pJcy0gYW-p7+GwIkWk8xM&J>VN*kO-eAB2@e$aU3>zMcKoPffc
z`vh4_p>*+&=lcnUYT$nhCJ1zs!+J}ZWlKAo2Vzlo5~JAaF&8Nng%<*6l2-$@ka1oe
zaiW^!%wMjvYcYT-y{r71qBpt4WiM(rFONPwKgQKru3a#Jta^u^@QyV91&J;Ny_vpL
z?K533Th^;HZ^MV1RZaOZeJ5yN$*8nMCNzEvVs0=xT1zrF<S|(-^jXBZLytUoksUl4
zeQvta?OenqezN%*KoU5?^R06`gUTeIO9d_$-;>Nf`TXvlTpl&s*-gA3Wf!C0R&;v4
z3X|pW!GH18`}z4;4OT)Tt|*0EiieG6E{<~J1x^KH-?ef!#E%HekLsDalwVBFK?s$^
z(oejRWGaqQXGk$hAW467*XUaP2j?dCUXM!yOR*+A(XH`^k_nj?9M1QW3lnLYg=ZPM
zB)`a}_2@Sz&Wt)4@fh<yv{gJcjr}{O@`2k>wT--L!>4mxQJH)OUMLk+)#zgKlfE26
zGudZQ-D|WcYWITs<d<JYKdl*z!DKwuar)uaZ?9#pDVbp(pGVS?LZVzhmF_+Wu6?U9
zHIK2rqna*6(X%!tVc$;5vQw7hVr*kdw)%zH=$KkD=UVg^(sADse}<CA{+J8W5;u=K
zq3Z?(^N;!{GnP`A87cJjK29NgNaMr(iGYjy4ojtZRis-=AvdBDt^WLC7L7nD;VHhe
z`q!npTM5=^SQ%^|5l5*=AveWZOcv@x#0eG*U}Qcew~gV$+3^XvhqZoO_up?5I`?gt
zS0=~m-&DEZ^<s2~-{M*=--*Spjubmh1=76Y{Jct(%V5Iubb?#Ah#4so(t3zHpI7I0
z=oGu!X_s>|GhN%O$=Xrp+fXlf8ucTGJT~usNh6)wY;8xMnYT8u^30w~Gc!^>qfg|l
z$(ON|UOwe6d7)?8IG&u!gR&L9t8x77{cB^N7)d41oV-<}aGsP`0aIYtcK;kt6g)MZ
zeQx{sAu~^@M4F2G+s2DlefI8^G_r&x$JL55FSAV-QS1bU4n<Xb>v81eAE#XABYPrs
z=T(_ns!lMz>7u{rNpl_N&mBCW3{T9>i?fM7-v7WZys*VNSV$ru!S;l{uKf1J_>+(1
z(o~)~5Et|ntkm0HDmsBDmq3A7;<F^0nfFq2Yf^U&Tp33^Y^NC8J>Glq^%4IbDy`Ro
zg{R0TTb!wsx6V|W#mF%|@4A_`-EY;j@{<9c=<;`z7=C|`-fNmBpd#lKin=ZkCjQZM
z-T6yC@!-e4?>+X57*?|h-h!=M_S4MBW3-#~{ElB9lkVTAW^yE@(=C;K77$U!8J`zf
z*GJb(DJZ@ib#y*CfPKU#+7)>yw)g4KP&>t})NA9ehS)GC(uMKwSqXG?OY@xpWXPq{
zF7CYLH%>e8%9c1fvP)TUjIrct*{k@h;b#?z(Ij2<3`hx~?qS!I42Wo@%@DDk!Dr|0
z4U}?$AFfD*KPt|5sH2IR<el9A7_k0*%+SdHg(Bar&Zyc%uX|@(7~luyq;j@rH3Dp<
ztFLSmf38aSFuKiQLZ3{YM0>{C$t;cV$+OXjOtW|iJ(k|{PSHj8k=0_8?-w1B_xOqO
z6k;<w7h{B)Jrt=fzeFnQiXQUc$UAGqBDd*FKSCHYv32Rl|JUAIKy}r0`{Se%f*?ps
zcS(sLAR(o6Np~n1GziiS(kh`KAc%l;2`CbxfPl1gNh2X3C2@Xdc<+~s`S`r=^S^i9
zwf?i#teJCWX7A7R%$_~xpv!M6U>I3=g}XP*I#e5*JPaWX7bCxid1({<qAi^e)$AI1
zN;_|Aq}Jq=P?ez?EH0hhw40KziP#-Hd3S@Nx3$DeRRJmO!Es6fyrb(>qo+LlUuk!s
z^gGXZ`QIVNgvU$tzNL7USlg**OL)aAnsxcRUyBFp(6oJ43dQ1{VCh9`Mb^sFNN7{W
zH}f^v&*HO2_=tZzTB(kMeOsoyl&yg;sos3tnu~iyS*|N1_lDnB<QvH`TQ!SqbPbl0
zXaugOI*%oU9y5z^Lwj%x<GCQdmN;@t>Yg$`hSxJ6tUjKjoWylBjIY>Q2_44`D12Wy
zFV*t;CK;ok41bnnZgVRvD&%t7x%F~uUHADE%fv0ut^S9MUfbx|dIcz_72KkTg+5D@
zFeT=ws=k5MYtX5lvC}TBoHX0;#GX_%ACEvHA9&LpbPt_c?qf9z%Ru+Zv3%Ye)QykA
zn6<ekLZ~f>8d74pe2i+@qXH#fdx*Ztry|BVT6S0Yo%&wLg9ld$dns$MO4<6E{RL1@
z$nZbTVN@^b$FnZEP=CI&CXL<T2w#ubumDC#05Y?QPEDg6eo&q;26q%>_<rZ6M4)9S
ztWQO(n0T(y*^>r6y7^d%bl4g>|7Qz!iS4%`iAWeufxeomPg2FL&6c8k{oQbZmPw~Y
z3mR2kb`36ZG*Nbd`;@C*Q-hd~nlIjc(QvtAT#aXfOwepP;#-d)v#~asB*!+!IVHb6
z6K8whJ%+7GoJK=p&W^Ul;l$HB9@5B|FYeGDWlIf*Oxw7_YUlW<{dNsF9-^Pj*}^Cx
z6t4-YvErsNH1QQNKz3m->PC%|Rt_%2Ol*j_5r*p?@cKs0NEp%QkE^Fg2dt~ylQ~~H
z-+_;VLKC@gtt)p+M@{kFU^U5&=QoDl4X~({P+JcQ#8a-#b-#YF_Nh({8QIA6h0Rnv
zwm^{u`H5G9@2@)whFdMj6BtR<`RydrVNb@LqiTM|FKga#CC%1A0^ehq>*B7F@ry#$
ztVt*LXk+4zmgz|ArqTNHnr5@B6m3M9{r!X58AX$H9nnV;{dWhAy+ZqFt&ZNhoRZXn
zUefYD(HGbMq^9o^8<7FhGxf(MGDZ}1_mbRDn&L;RR#rS;K2Gd-EBOfu#Q78z8L9jg
zvs&cH?s=El*<0pI24mwWgZA)EzAJ&}o0`2hKn2jAp~KPkO{bpwd{VEA1&`^tctuyR
zsXXdcW*pQw7Ne+lw#bYVtSHIqlF5<rsOTp+BB&bj6UOJNq>21^{YA$D&X79AhDC|d
zlkwV9U(&{OmEqip7sMaWrw&jJB}GQ-&u$aoh<q_0*+)V60=s+&S0M#|HdMVMphWsk
zUb<M$CWJ!iY=wHI^^tgzfznEg4~E!P<qsoq1*Xe$pYmL!HZkEt&&8^gDT2z|YZH}|
zmF-;7Z_{Ii)>_VTTQy&;sb{-GZ9h8ywS{@}DrWOjUS&hlFkUP2T%NVcO!|A6<vy98
zsxeuLM*3PQLh-(Y;)U{@;uOM)9BUBwt6<!j9BU}ht1IxqX(%-??J1!XBl3CI?<(8H
zFGffgCi?=jMv<4mLBvd+AYZpp$;eN7%#S_BR?P1hmMDXnptPPmhnH&?mje|y+KTAe
z^?@D}Shv1aQ_yqqrDn0}xf4(AOhlIkX|8G)2&v4YjZ)U{o;9=P&?%N}TN!&kZc##p
zX<fW|>#3pvX;F5K^xSTqOr-ENbTaF5F9*iRSu7#4b0|i!1w)2bQUR*I$}S`WTju%P
z-ATe5^*1!fo@Qf|)8bxsI#nrx%Bah!+HxiGreLG5ull@mBU78$HlD+TSaEtyQaqY*
zDXpKbJVuHda>=m=6=ckmE52#zqJ$c|QI_m=%k)PjK2|)o?Zj1P-ZQLZGN#y@SH3>-
zYKV<v+HzN=vP#f?`eWm(vuZs}uuvFUgtcdHWmy~MKEm#noOoXzJ$I6fEM)0&j%0~d
zHyTw@HZ89ZcHe2YBjax`<TvPNa31&3pnYR)M?jdRe3jwcOeRv0WboZwy|`ZJ!u^xV
za349RHoy_?kiMcR<=y11CZ%f&_iDx9yYU!U>Ye-&w4H<}jHDkwK|0An<j2D+X8yd^
zyr6~%{$@csYnjz2>dd*L8be|k67vF{eaP77l09~vp7SBI8VGHF%0m}ja`xq6(LMi_
zdFckr7nRM#&+rj5#9@y4O31xJ^JT7^d?ukkIy!t7b>zd&XWt$JH+X`xB2#SELc2Z`
z$hdWhu+NK*mHZux#F&wf5@WSgFs7!l$;cg3!)=;7l}T*ZuSA$gCSR81Ho>Si*Cl&T
zhD&`n9-Szbl*a-^y}e6DrYcb7Vc(w4_(=hF|9rt4FXshv=+Fn6OU_y7u<A#CZA!j#
zx!NGU?`s8DU5VQfoVl}gD-3s*``PkV&QPm+w+@I~zEM|qfR*1KOEnQ0ob>QfI^orR
zRU+c%kj>tX%c9$I%-MT!Wl~KsT7}m!i~BqJD*A~duknAJpD)j-SRpRs@iw&}{}|6d
zn#^Tv0a0C`@p<Ci);Q}Y7Pcx+9x3o8=x%*2dk^(PSlg*tJyO=!rm>8wF~Bfha1@P1
zMO~vuoL7OPLBIL4Q7zS*7{$=eck(FYJ{%TkS_?bsVvG3~Oq?Z7&`62nFxfp&f3wEw
z_<8PV65XonIf>q>3*nY2;@n5v<KJ%2PA9qO@AqTpa4AnuqY)3`z87aj@jnM#XbW?b
zMp+PYGMeiZ&b#H&#LAf@g5K1ugn#c|FgA-*9qBH$Muv@wl~j1$8$S_3i_8-}PdN4L
z%#s7>33)7$u%1kC@zLm#wk8I+esZLrb*61`3s_huQoi6L;CO})cP<n|N}!fqFsNXX
zy4L_BvAbFxg&+-=m*6J3_03EA;pUTRHjDzw_wan>PR<#9?YU#b&OWh*>xZ^Q)=(oG
zE^2N0!nu|S(@Sh#$h?Ez;!X=uc6Y}Jjp%8rp$g~MnnhP`OX0BJ$uHQrZ9H(Um)|2|
zaHvOxV~C0;k<3#z3?q7Wl&Kr;zro|oUNM+XkJ+PTuo>l=%Q8Ou>S;vvkZ|?!;Inp*
zCQP!wpE+JL#Ut@<?|u*c;}lOJzorYxXAHfoM6h)pVv@Zet&yKxH>I*lM{ej9z8-2u
zF-hML&RQEbcV_fzFV>R$quN|ry&K{>OKG<66Ge{?-TuN%G{&^aj%;&Z7?zk&E`@eo
z>v>s0{vzV&i}UR`yjNOQLU;?=Yp**~Pd?ujD6zpI%N2@13PfS*a#D|+8I8`0Y~`yW
zc(2#xMdZyRY9>b!O08#O^)ar3%8xBvID=v<NF_!lMbbC*EvkS;?@=omNhUP>5W9@U
z9>Rj=dqGYlD&7la_@PKBInvC%SK?pS`VAsy4xyJwAE|mEKOR&{_iQV5)8_TfgmW$@
zu)O(^tPDDfG*2&X(%o}G*)$w)cPza*>|=Z(&~;K^>V3I#$zxdDzd|RG(s{p$C)fN6
zjc3QP&E3yz9dSAaDvk5j@h2>KgzVx*KiF-(rnyTO9Dh{v{@!P`IxZfYu>cX&lkw?d
zuaNG_`>L(WClne;227%4bD~lx3em=Aw(+D1eN6EVutdSq<s|T++et`6)^Zs}lEOT9
zBNPM0D<7?NsVBUyeI@voW&hJ4>h8hU8*=!b4j-zl);3^$ES&;O(VA&YFRq0JXRcLP
zJ>5gH_6)K#$|)+(gtMghg$~-<G8UJ3I6ZiXHP2Fs-9fQH$=J1t!F<_#^8!jI(lI;C
zJ!JtTb2LH+EF{!z?ep)NYK^Zjit&8eOtge0H8^Px!ausTbCT%0Ht6w4X0Rq_mLglp
z7Go5C!msrcts9e|rbD{l^u8Fw4&$6rk#?M*kxXufS17Jy!Nr?n8fiWb9+Wt!>84kB
zPQP$iP|dDY`fLfS+1&A=cja}Qt=*!}6OtQzP;Hu{GX~UImQiT^#KT`9d1epzd~Wp=
zE4kyE&{^o1=I}Vgz+XN1)Rkg8Nmg2;d#tv>@kdVT*=<IdMp~k7tN2kUoRpowmw%!p
zm9oZ)OOBfw8IPfk#|dv+Dl<6ZyOJ!C1S1DRZF+HRcyL}%7S~SYi@)Ow5POOyF3r@*
zilmk_6=z!EvnIM5l#JvloWUwaFVUj0z5c1`Lr2ffZCd0(?<zWPShLgnywbY&kOf;z
zVjRldjFHi&Nv&czIwh6oJ+zTey-d`tB3+r4Gk*C1S>vRrI;ZM*1i7nOW4CN%Ag#un
zB<{fOwd$nl6A5=oY;|Uj-mf@uv)4{Jyl-tUL^h$+;O)&_N;APiv8R3->i64JdeEY}
zDtaGa3liKCT_0OY_V9B`=P08#?)ScHiEdYf!&piAf#%fbQym32b{Ww`#ALa0jIEaR
zD=idqzjjKi4%RL`>M?w^E(I62eY=l;+?TiHpPz~)nqb5w6U%bckGO5$a9Chmry#^~
zh>I;<qE_V4!L0HzD^|a1Gpa{JAAd<*8Ew3{u6o`XJ4+TNipl<CWb={OQrZT{y2Rq~
zOFj%mDWnLN%|1KIdWEW*I*ivfrEARTG!7s5rBE$Nb`qu0&SkgtH!BylUMfvzJ};)&
zkJQOJ?@AXv!Kh_88`f<(U10I%657_$!B|1D7Lj{c3^93n-T`4`U;RE4Tp~nPuIu`2
z{JOw)*VTh>CQK|$Xj<%zq%5k->|`vLRWnImxZ#J$M@fNAqPZ6)Uk})>IdGcQ-wTS`
z8jnlEn~cMudfl~Uugc4r<?vba%}3T&3<qj4%42i{>jWpTbF<#j4Lk}ck`k>ks_F|$
z%c?+m)Kw~mE=^+5gp=+R7k|;nyWi5+=NgJ)hPfEm1jb8a|BE!<d;T{!c{YxH$o)!b
z>@B`whSOF-)9pE@YYj94+@v>$?6;eGUR^?3{G^&W@v1Uu;>`u0%6UQu-=Ls5Y+U$q
zPivI`evP=eLDB_naqm|cv*fYVv3+Cx3ygKzsJ40<ep!kPJJ+#xvWg|L!u|BKq#5bF
z9<<d+F`-1$Ca9o^r(c|Cl$yplYLjx6DO3?PaWOTThbXM11)l>)jGdSKW45c`fV@0;
zzC<k_692Jd_b0h5pC~gt9Fyn1z>|KQi2Uy7-3>PU8Bgc?-nWAD=C2Ej*ic)z?U6!{
z;EO3fo^;+56NF#p+EHCXkA<-5MD*NfZ4^&sRQS9uWSz>r%`QPgNQxs+Zc4XO)$8>&
z&_3$KnB;w%Qxuu}J2&lVr3u2!V)4md;FrXI^;9sacPjVK36pG?@Gg7rWXEO4rK_6X
z<919i+%58XicdPF4!WZ>?Z6hDye8hw_kp4sB&9sYSLh?`cx0*CYqZslcAgQ*-MQ&q
zWUu5_;Lfop;5L)n;m1<=WlTnAbi3qP`Ru4%trD{>+UTpj{xjEr=8CX-Sy{hlr!bBy
zDvA#Zm-|--hfl*p&y1VQG5ObRmm5@i4YsgcG*446r^u4<Traa54!4U|rjVk{>V=C#
z)FXO|PJ_Uk#9VOV(#Zw~vlO4#!FW<6xH{1VeGYj3@&w6ys9k;&G>)e%&XL4RM;+%F
z*e!7)*K^|S&hn*2YExIE$u{R=$9FP&*F?v18ih&;LbJNRLWS*D!M5YJJ!IFFr9Uw3
zmo$18zByw0A`b#OO5?{xKQ1G`!E|o*hE+BvaBHznvJ!rByTsNoZok%MEl_BLJeOfD
zc6mZ#SdmR_XxBzHI^wI-xl_@jM@#VWA6!zF+qG$V!-ssE@?$TQ$<lZx7*#j1Pr&-T
zx5PC@dR0<Nm7X^Q4=REj`clluypo2nPIY3bPaG@mH7<xVj?^BLy+`-l8@pruhAq2>
zk2aMDa=iMAXpc~iVb+4E^%#o7Oj`|;f08mS=IA<ihQYv~p#3f6sE-|JgR4(^7vT#_
z#uE)HBrEg0Z}?+7!sSSNRPx<f?#bXvRJ0#SGzc5tle&s^vJmI;e0M`+M(Fr5%51JM
zB?<*Ij^wMlU|&0QJI9hp%gT@u?4DGw_#<TTRQ;LcA62A;2^Cq{ttM*o90gMxEAS*4
z-e!<yw&T924Ny~&Cd6?^F+4RG)+yuRtC+egr-04Mb0KH8D((z{`}W$Z_Ly_)#%aS?
zLX<N1gs9hnrY&=4cFdB?sQ3%cTcRxp71uZAz4WQ8t20SdvXqk6!RjdG2weGeAxLn#
zw&2!Lt9q+Qr#>%iMusew$B``PSPSJDi|P`b8so)XKI6@N%FkG7Vlg+k$367;PhE&g
zMbZgAQo^F6tV_^dD&eQSl3Y4FW|zM)TPQviO^wD=*MAbD@i`rvy!W^}naNyuH`f%=
zAT6>T-t>goxJY^;tUnXdT2j_CAzE_<bM$8Y^crehn~0DZ#`^qV7<|7({p8-+nfQxh
z3k`u`B;hsJZw|k|$_`&+>9#Y=84C5N4=sD=CotcR7gsnhE3_!apoziR6o+NaA;}So
z>!M2R^eip^+KJJ}ZN@U3*(=m$y*EeG_K4Fl&1wws!(+UM+LSfW3u5@{9`N9q@QaOc
zRnPO$5%W**I*L6}p`MQ>CDSJfU(fYFONtq{f=ybG;ZofTD@6e1$MZ6VT6ZA76G}*n
z%XWoD+-9TH6zA>y0<nqDUR6|Ic#@oqcg9Nnibaj=mj&qF4E+}*_`V}Id=m)VDngSA
zFjkjPkkoJR;;acE$-(OJ<fFN~6d{Mj>p(=1#f!43VO-~;&-|EhGEUp*t%fGPM7M^~
zJ@irM*EG^7FN|%7X!Y;|1H2cM)hK<jK3pHRrmoGFiEL?>M`fcRW5Tj(j3UK}i<mBy
zBJ*a`r>vDBuM+>-%|=r9VN@o`qjsb!4_h=v9nb4_GxkMdF1HzFdIkoUoT}=fLEpx!
ze)ljvU`?3MR2D>ho@M2-XdB*gEV22nYa3bup2$i)>3labeHPxT;0GPYs!zQy(SE)o
z_~pqS70&MC#JkNHD(CQY>FYP_P<?h;X(dm1@iqiT#iMyQ%X2k!m3?d*58a}VmiMfl
zGxB`R=RNg+F@w32#&2QImWa*dh7;OA4o1E}$~r1x%NZ{Ij*lNFuj|EVzMb5>w7EMY
z-W)F!m?Yn~fV&=k5jUjuwBuRkGw`l{qj{E><ctX#r{Sw(iHg$%^rNqc?Qm7-X`YaX
zF4qy<dMvX6U)c<<hEH+w7XzvC;SV90S(w>$&aK<%6~1UuB)00#2x*V#k#757FFW|D
zuEgkE?Oln)rMlDcm%HG5{ueo4UnHzmB0^yhJo1D`FOZZd6IUio#^%Epp(S-aITie&
z;x&9M!On@5UTVTCM&98S_`D}Dx-Q{=Xr`j!K($rCPKc>Xak}$V<%!*-E=T=h`hu2i
zsye>c?dx-6{H_yM=?!1b+(kb>TP)V%l*ice;A11xcCt*~BV}g4YXaJ;QPByt&sG-)
zUJzetO&E(xD*glwRdDHEm(5VYJVkJ#&0dL<epZUBq_gIIv6uaJ%hj16F`|L{O0WG$
zq?i*_Ij|U1)5MPF@DP=AVtZJmi)EcbR}^TIydR{PMHb}DlI$3_+30oG-HD4fU-w2n
z3x{%y8g*F#QTm(}$+KdyN+MMJw2qZ#@z{Dc%v+S_6_7TBjy@8(HBa(3g7gkHF(;vJ
zWr-)sf=(Kaa!S<7WK$}9U-W8s#hEPi9MwTJw#&-GZ)Vk=-ug)F7)+~?)coW{@TLPd
zhu5VrDaJa}>kj6{=VJVK(2mOAzt_;0EOW!2tAh}C*eBaZ_+H>~;`}GB!y10n1~;_4
zQx)k{o3GgVTcU6VAG_bx4fkDwD1MQ5+^f_d8l61&!;^;488pcG2X5VsuBE1XfA6l?
zo|#hdsq<(x4<1UHyWbcZ3Rb;{v?!P$>WteOMip_FNeOefdrf>XBILpeQojKIlo7RE
z<>!j}4s#vl^4)a8x2M?Gmqr3_=$5WrUM4iIzp-;$Bc*S(n5!ncPS!}Gd@iV|>WJoJ
zl$abM^;fy#75$Ca5pSD(#v-#K>p4B&n~SB<o``QI6iCPLl_Uzf>;K7iC;{!vwr8bR
zX~ttkvvtpNwb?!RR;d}{tc)LxbdX1v&?Goi8$yZ9t|d0i591Z&3E$bQV^uDrEDQBY
z{_KKstIY*&xhAz`wwsf&hPQB?Y>!~?4(QExc||7%WzTix_*OW6;+D9D)qUdG{YyMt
zB%!_e9;ZC^W|<O%ZKI#<u$H`|n;Z$f%$B7gUwyZmHB|?l+(D>Nc~6rCYv;+%EiOf}
zYD{Xik76NRKDVTih!c;@tHFv%`sB0eBQ{w!yel`(;xQkWDN25y@mAi4S(k`a>n3$q
z!ts)lAWJ(U5+mPudVLlt`9}mHdZ^JPm|gl@C&y@BMQuRN%-v|CkFcf86-drfie~HI
z$;e<%@}NQEInJCMG^JRJM?mhItN$WJ<KYJkQymF;d3jr<<yT^8&MXY*v7ClA8*G<t
zc*EYeWJ(e}(drCex(G#uiPUdiy5C-`;=<S3EVG&<pRZ#ktExqcyvf@s5q#|gdG4je
zj5>Lr*Kh?qe&$1ME)_Q~*icG8?lVSxvzL<_hlWUDhf+#Vo4NLsRM2yBJX7vv4^(7W
zEK_)GqP{#*U-8Jazr@7JhOv#UJ6HQtMPvh0M!5_J-7bkBmraiwogTd(YxowvydtNr
zeOgE0i@2ZI+>J?Ajkbc$@gQ@0F?5E9B43o@Y*0l-MR~uj+6#d%BM3Om;HfQb*rza!
z92Go&@eQ#mSCGTRo=$PDJ}KSmy&%ymwWO&h+fQ)t@tox3zCkU+DDG27HSk1QZ~a*~
zk|jxDLU|-tbVJe8@eQ9AW}AuR(!vw{mUDE?PrRB{K2K+Q#d~h{C1AwJ;_F?&zKtWO
z_$iF5bT0h;g@6^8vYyY0r-DQ<HyoGNHg`@NZqp(QH|Q-Ubn2>&)Ft#4ZH15L<X(8>
zcI5J%lj#2FgY@vH7%Zm5X(dQfG;;MYBZOBl;IB;75#`o>VnmH1wB&?8GtygfjX0c2
zC_J=TUhjn+Itxpq{0w$k+xFI$i^!2$lL8uMezMad9mf(m)5rSzglAR=G5pDhCyC<H
z?CNCsdee$)ljZ!vqr|i5Q0=tw99Cp0Om(V_cX74!`1v}!-V(g4U~XOP9?1>tHx3BJ
z_v$qEZ?p&ysm9cPj3wUP%^ZRyWAsowL#JvhXJh)}PGUkZ+UL`&IxlVT&wrhvGf?t+
z$9wxlVdT?CM;C71v%5qsk%~lUm7_S@IN78r1|K1`XV}vD1<Hu!MqYTLE}o-e|1ou>
zazJ(3Dex3y>g-ftBSz616!M~ii=z=#qBVZIB%B5>y~yLwmYq|g;yZ13vx8G9%iZ?K
z`SOgdqx4rh@+l26$&Ny5Ecu4{kM(k~rcX)BPF_NjyRVgMM=Pd=!xM~>nR}g*DcN-0
zGlqk_UOsR+aE)T=tg@~KfkKxf-U1iRyURg#&1e`;{pg<IsCp8IWHlKv=ZSguhsy2Y
z%g%Gd=N>&rMM>PM&E3uxGMuQ^Z(e8^dwpx`O{~pSbG(TX(>mJC<L7Oeo(N=gl?=UA
zIC^s7)!yFAe1=nZ0{jA~gWS`DE{Y~n(V?q0-v8p&dvnT2;^q{Jp_Y1sh7)bm;GnR<
zs89G*25od0hieC4hD$)GyKLsYTr{6&Ya3XUF-@{wWKqS|9Y`V<x-l-bh_4+x8O_`L
z`8k)G-*P8o&N168wBZopzWDkVSS;}tk<(olXl%!bn=mQ35`7ejysSKK;HPGy2d73_
zqHF~foTTp83BtI892F&YRpjIjt7Q};@5h&hC%a|@2!lP3U=FqJEID!vE|tiMAP=6G
z$?D`co)?%Ou6($VK*kKwG^C}yUXUBD8{IQP8B1m@^W2-ie2ML*lRTq$%)2zVjr8Lu
zoW9DVEMAlFc%EON>z3xBz}L;v)^6lY(}@eo&2JMOb+SB@k<J+?kv?Z=Lqx4e^mb7#
z{93s1y}SO@#ENdF=e&475c+YqB;Qna_Pb^UA8gT8tN1a?oR`SRihP2ErEnhQ-3#S{
zOx$-?m*}ruqb@Ztq_5K~`=q|H?GNAW=Tg$yRM#@w8+6fgT)R(!f?w-ZOis+}f8v=&
zO&wVQM)`w~{AXU=ufu(bNY$27qsC0KUNm`;HSaOq7$u|gWoGGw$It|uNn><6?>nVU
zK`NJ}-KA0X-eC!=3v^hDW$Q;UKYN6a+({PdpKleCe3jMzNjYwZbY<I@u}9AfQ5PLB
zh%|9qU<rr@%B{$)!4^Gd_^SxSOs|4I&CVvEN#0Xz+fE-oVV8r8O6hqlg1I^4K@6&C
z3~CjVc6&9Y_cK-O4r6J@bY$gIW5+B|+6q!Gr2DI-*D%&IWS8t9-{l~lj3-qdSW?MI
z_UnQVU^^*m6P)~n*n^CxH17?gJSo74=awq#eZfiTvFBLl?~m<DMt!2%{k`CsGbcMo
z;se6S`E49E=Z|V#5*OFJ%=Y-5rr6WKxyMK2Dy{j(XADHF%+P2REX8B$0?4AN^#XBR
zI0-&J5zlWR<dW6veH=MXsQZyP#3LX$>H@EVNU_=nzxOx2-d$Wny&lPhlK+B2`JG-U
zURuz5E;_o)M|!sD+RBuUm+^}FQTwRMAsy#=dOLpOY*Wlw<?NCjmH5RFQasy@WM_Rd
zE{RXmf!e<Pj~UduBX;hE*})1!Y6G?x<~FO=-=m((oogPiVtK&W5}Gv`H9^}LbL!;T
z^2S7qmxKfqcKi<`ZxIj?seT}rpzg!tzg_rHq|ZMRZ_b<EhzN!Mp|bC(W4U#sK4GCb
zCc32$x}_hqtG6^ijIZ2?SMiHAVITYIG5wM^M%rU(czbxaYU#z~c3k+~BR;i6LA>Hi
z^yz0i(y*5ka`5inV7*b3^YYVx*USgK8xQLz-<t54B0IXaagHCAtb>Z{X4ty%FZQI0
zb}4Od(pn5|sJ*>^|5%K9nv@uUmvJQPZFhH(s)~)+Z1~={W3is%6-!gp>7y%@P5v5o
zw!Isk4ot+FN^dW3(=O_VnY~IDYo^XdVnK3RpGBds)Af9e=j$h4FMYw!@qOk*oZLnF
z+WC#VX)jM+TvJBF0?uUV*i=U9mJ>u?A}46{Dc<hT2X9?=OC77`KFu+1Q8@qbxoV`n
zaFQQIAX(#$*V83P$DZmvRSmrIXisEg?;~+>adC$IwB0Lx0w4QW<o4ysa{&)rRyW6v
zdsfev+rQa9r8773WOhMQWpA1zgv|F#h~Z_n+4+-<l~PZiO2&FWR=ZVeVxsikt<e0Q
zacG+VNU97*b<%hXA(_3lQEs~W6?2EK`Z%q7gF!yLxse7Iw5G2J7|D7$-k&;M75?Cj
z=CPP-@c%9qkfejuMJD!klLj4$KlS81eg0h29{WAFs^#RM$jwVkilfgAw^`4Q*fl|N
zJme=@yQ9uN?^vz&rN?zvO>M=u-lPs-mS54G)vO(ijaPb#=XGouV;!5y(=I=Jmiu%B
zOW1V{-0?zn70W95UTjy#X``4;&a)KMog|F6L&FnT+16PJWb8v4l6H^FlL)O0RGmR4
z5fAuazWP>S(0RoDdf!WJeen$cwR2}9b#vA}p3f~?#NJuW88IC!E0|kSatrUWG+r*h
zJtQ~3)sm{mA-`wT;nkYQ^`uEwSJ&%y;X4u=#S52YJmI;2>1GT=^Yxyi<w6yA9;L-z
zoW*8QFr=5HzGyHQ$Od0kB&)_>sE<Bo(j3w*cs^vh<4N}BhZ|ZW&-Y~BVYQ)+@_xM4
zyn%7L>I)XMyPDM5-|yN{!^)?4Iul2|<2kI~$M1|`?>UvNJ?ETs&p|qXc%X1mW2ICi
zf^B{*PE=fjIV?ThWAXUq$6Ab0coDbg`x~*AC@tu7UdCHYWEP_xl^DQe5SA~LH`eJ#
zOZcd>e#>v(3?(pMV#Ng0&PV0CxTrn>JIUUpYr5y8T$<C(P(O^TD4$8Avvj%eM)wRy
zTCrP2^KePtm7v=7E0a?R6lGWrZf|#Qb2;|&y;@7OE`q-URTFuQiQLKnKS`!Ehw0Vi
z#<4HK&nrG}MHHjC6y|EViBcvBByqa=kqhI5c04Kg@StX|xzEAh%B3E{van4&jU_iq
z>rV3_gSdz`8;=H!S%tQ=EFa~I79CA^cw^cOlQWO0)7t1-AREebCEU=j(@AB8+ieWI
zJ}%m9e=R9hK@07QeOuJ(sdB+f;qB}Og?`u0d*Y0gjRn*!DKd5s2K%L|;8t#7ap)SP
zv69jb=Z%-Q2$Gnh-;%e~atq6zU!u3-TL~(PJiqNwP7#DU*IX^V66T_38s8|{T#NpB
zJcO-`);6I6EjWbFu~Ru!z}n~o1H0BT4h0<^#^l|(uNNJA&_)SA^|!SpOP9KQ-aFcb
zL|^FEai*<qv`A`E;GWR&N%B`^WpNtMJz^Q|#AaZc&{M4?B+R=9V>&07md5nH7mXg#
zZjBLra`#K<TT|{)j8hZV?&rx)<h!b)+sa|uCaT13mN*=FzAEuDo<fbLdzM&*`TZmw
z=LPZWUXP7}Y%iZOof61beBORD!oKcIAd6g80PpKPZ@Z*-tM=j;)i&?Wb{xyeJ2t!4
zaN&57$F3{c+*}vWIbPl~G;oIqP`WE5$o8(Oe0J(#chE(<tjj!u;hwY{3Ska6-R}8b
z!!^FfUTb<LYWBK?3*TGmv)2n^O?e_7v*BBWLr5nt`6Mxr-x3*?@V7xH>OFmeNDSk4
z_EEXC<4s<~fpiize7tY$7rt0LxXPmSHsMZ{mpoHs2z44}HHO9)2d?5_{N>B8JI)c$
zYPcuPqm~zI9eLeGLRo0~1(R1)=xppHe79klA=c*2eX0Z{h$}!OpE11j!@1!y=xkcv
zY;{_ZX;Oc^@NFN_?%*X9hP3#E;<qofyGA5SI3Ma<@Vh-;GB4{IH>>qdZ&h6{B<W>Y
z!byy1qD7{()#PU#++%h^BL4U98N9kwhC=$9>?qt3*{Qpa*nKdn4^I?^0!3FoVxP`v
z6rV^aPVoI;hwR3)LMg|6|CHfdib!t!NeYj(=D7{u>u#G4!&jv2m5v_uSf_u-`+}sB
zgfTYW#r!o=<D$edB65WSexhwx=5`_fnTLJZt1IIZw{JOMt>&DO=O!8rm1!W(l~SR-
z<UxIjem=FRIbtKrgf$O3e>a2)=Yw1kl5~FI6`vY`8y_RLuzSwG2+%a}h@YCW=pPv9
zjz=ZkRI|t5yY#Lu7CV1}?^$!cp1OLP#XzEg$T(`FLBKd$607?nW$ErFceeLXS93wp
zSUGhJU0>wQv8!pm{>W5YS{KPe`Qp9^8=ooU{=!eB@*%IEDAU(xIgZ#D4~6ZV9{wqd
zyog;jiqI<Ps1@N;!l#AuS_EE2kpu%~pJF)XXpYA5-yBSn&W<|1zD2UP-AO&YILT+Q
zH{+ID_VLnN;t0*V=?QWATk;M&DGuc#U6mCNg4;#-_VVz&Drb#~+OFF0s!^F`_ejcL
zTuCR@DP$GQE-vCP3%+EEfA--OUV~th5LbUZG)xRl@r!o|*6L+nER$L6%rJIz-guf|
zAP*x+NLirM%xwH@wzh^Nyxq)O{Jiur2C;bf&8DimH*2?;u`=TVRw9p=Wj}QrIIUF{
zdD?CH9F|_LIDzQe22<%!{97jZUEhb4kFD1@rEi=uF6_;Gz7?-bmRdX@n{DpZ^W|b~
zyt%+Jr$;zT6D6`7yb4eB?(+v<e7yK3iYv9Q5;rWYGhV3ryp)zO<Vwst-FoU}xC5!E
z0ve+N(tDbK();pv7^Vx(W<$L2mx$C9MoZWEzq)RBm3fqYap*P|czCYnsklNQ5e6R7
z`AP~@(z7=yTvAt<;e-2YY?`VDDk&8gF4Rk(Z>lDx6PH=yCj0PGa(#%LWU|LzfKI%h
z-JkWD|I8k>b(w$llQ5dj(PZ&ilO{2aPmUt;MeofrEooiGZtB%|T>63~Rdl^fj(~zf
zG`{efHPOx1-kMKtWSa0I#y;}+HC{_x>)w3t%G>K1-h$2xgN-R~eI*~OH1kBg-7Z*b
z{eVkLr6VYF`V-9s+s4n6XU?p~Df1&gecfm-7aO8z=#hR$@cIraKH1XF8NsR{$p^Q5
z&$f842r6bT;2Ye|OA37?Ja0K$O#d>J5@Ur#M%x;rpw@%M{+JZWWBoXPyk2&XOIZqL
zt@*aS8gDo6Sl3RnQe1Dkn@IFB8O=ywQuyIkKL2$U(|IZtVzSET)>PIv2h!8UBP3~k
z1&@g04XP#3ovh|{bn7Zt3b?2A0E_cM#pO8;j@BeBN><Nln{!fuc`A1wS(uxfI16NC
zWvh02;)qP!ymKgR8(*B75m7R^ZAHF|DY||w@gA{2?@l`TDkX2<)Umk}=hLO5C8ac~
zp52b{{mPeX&uMg|ymuG*dVxo@^y&0qtmVve!n~)A+o!E*o1BE(XBtDi7?Gw)sk$E_
zkMT5AE_66X@?xptnMEs983ruiW+tk85FbPLpFO2MQpXad+^NY#V0DXq)}VoiFe2tb
zhYn7v2nmgrfl#J2X3Qzw2aB_{C!=mtb@1|Zb%)zMO>|HQkqhaTm$K^&(~G2gBlh46
z)8YdP*Q)nx;i809C!T!DsdUI25I4+tRQ|?TXWb>}Wj5F4Sn-_U2)SaYtIRjHnetUV
z@{078LMs)Vx4yN}1EdyiT;aTeVqB>am6Mkl2OY^*iB40#lx7WlQ(ulsoB+?V+0(2{
zop0@0#IIe$t`B!?Yxg+zd>}{qe9Se1iP4AiT_NW%t|-6uY~mWrRO+)d51{GGJ+iy}
zyh6jlD)9CDtFd=FqEBGm2~p?Xq*t64-tF@`#?`^uKk(cXCrV@>NMtg#c|48N)XU*^
zLSrT4;N@Gc;z3MS$BRrZVm`Zk+1@NKB3#s^u^->uO%vtW`RWw(zBp^>++-~0n;nlA
z7mcB^oS6qmdev#e!&jP2vR5mMJSixxPj4IQhC#0!n+L9>4Q0{kp`WDTb#GDec_zKu
zFLruE_zUh?k4zuyL1ph)l2Z~Gw0T=Ly9~9=&+`}4EsVY{v$CG9aQHk(<s8vkhIBPy
zH-VWj)ARVQ@F{bWcUxax&W3A74%>J+du#|K-L?{Ge?_8y-y&V8bJn#-X=aWBE7!)h
z-t)$I>wxZ7yXgCgcjgRVnDKpT6ERBIdYz7PFU%)jd5=Q0w_Rn-J15Gu$TM$eg_3Mr
zK^lCvr(En3+TgB11?5+U(&x_h>_TBI=(s+CJH_{Pn6>5}_YhAli+(6r9pa>XxoX1t
zbgF#;vyFg~`kp-A^@XSP4`upl@846(B3z8y+bxZz<$7uK_yN+@t8O2H6hG*_AYUqq
zXj_^!veG{PHJsV;Ey<L&w%L?!V{u&B@_NtgajDJOEHc)2cGYq8xk{s9(lZOIor7mW
z%H{SjW3PP)ntn&IqYZzcDJ)8AXn^`_M@mj!(e(Xpc9Oi;PqcbJ;TXkztV=LYdu+m&
zC+ZnAusD2aR)EQQkO%v&whTRMkCK+HK+0bJ@v24D+_JAtOG?AXMozY&iCq}yOAdb)
z)avZCgT6afqE1RjF-J+w^TCIEKz6H+UFVbgeE(1j>a}&-g^_zJ3)TuxE6<8KUz1fZ
z2=PFw;)!{uefDnBQU@TUCxIi7B{sg^eNWnHd^W7ZTp`**DfK1K!*tivQWoUa*R98|
zR1LMP^|*&$i;eX`t}Q4#=YG5Rjnbg2pr*mvWX+x+1^&Mv(F*BZTctVj;1MH7Z-7j!
z*p(ula^XAaM^0~@!=B}*gO+DF4TvRdwnvn%H12R0-@ZW4elgUNJG@+9K4IPQZ8)jW
z{P`?QuYk9flBbU2eQ?vY=g4ui7MsU--^^@UZ{FF?sTM+tiDoM4-&p0Li@nt4yqYwk
zTOIe2y#oGr-=_O5I;?opyr++?f*Fy>$fn6M6{pwyXRo_pd-hN@G_~VLka5d6I=pxt
z>ZH}+s8hb`{e0%Q^yXCTQ=Z&vMM)Kb!QqR}F9VulMkFg7Zwa!UL2hdkK&4o6K6m5@
zZP%;H0OTb`JG;(?wx<MG%=GurPMW*S_w_aAJ#vlZCODP7^P+LaZ*BC`vR$)bU9;S)
z3m$tJ#yCgdW}0GqMDS4qy{!9!^v+_-gxM|llUZ%E;mVgs)1Gm7)e{)6Jv-XS$+P<A
z+B@00)M5%uQ%XmUJDl3#;!ux*MABt6K7iykg`q1>OCb5xZ1<?>9nKStc;%#|WkN?A
zO5=J5MlBZJzGm0as@p;54Ci<39D}cpogNB!bDgBXT?jPi1Z34y1$n0>od=u-Z;-b$
zRWz26wY>=?aggq>K)vq1LGtD<Z@g}zf_^G)kKg^~j9kjllQvmBr~cJ?dHoh|?fCo6
zIEf7D*EWwtd>jZn-zHnZwYso=Y*=vA;?pBjc0-*Y!A|e@<v!(Sh@a{DDKSI^fog!&
zv`R2ub}hM_f(oA7kcdq5hVeOW2eDy=WcqDs4qdvr$P8aqY7-cdZ6TCAIkPZ3YO}!j
zad@}R5zF-<K~LG8ICV#1*Zln&Wyw@z)kn>H8gbPONyY+~|CzQfMp}w(N@O91D*P$>
zW4z4!EQz^5j`gaqf}%%G1uY6a6c9iJBrqdEN9D*`aU$@^1>pY(AYGJFl+2Yd@?nPk
zT(C8QE%N@qU0}~o4E(oCXm@w_|D*-j|4-oG+lAIQx1h?d5omtp%RyQHU%(GAcF)X1
zw_kQcMk&vsiBAjvXYd2;t%Hlu&5B+~=UxsJ-q-`}9BS*|mp|h9d-qTJ2O`bp<|YLH
zeHLnIc@H%-G{Uw4YHMwS;E!BE@Ly*4+bbgOU%9<7cD;)Okc!<S$kekH>K&awNDnX}
z(j)L8p1*ey;XiYCc6Ro$-U$hX;J+9{@SmI@26`rlj+WuT!he3+f5*qm4{2-ZLhzsb
zpw7<D1ODIh1J60hW02apHb{XQrpu5G6_<{F6aPQK59q^xS%MxuNPytKBJSe^82^q1
z`IC{p2&E)HhTuQ`9bg0P<5^-WWOlX?Qi8GTF?d53dhem_?QiSuPw{_W=AaEcew+%y
zf2RIhcz>5S_)n2gW@Z+&0k^&TcLyOWflSC4#(kN=4ASJUhnkya4)TYntA7Xo$jAt!
zu6Fq!!+khUpv~zTK7rIvy@d?u9zmBGRUti^YA7<S?+5H44}TYb<;%+bwtblA_kLcU
zGmx37ITRTY1!ZPrK@}A*pcgM*LeH|ELGWM1Aj_*(5I?`b5BUe!CC+(4N;D0SBU>OO
zO{WQ&(xpR|maWjz>e@G0|4#WM@(BM~8)9K*`++aO&&0?AS(smes$Nw=8yg!xEh_|1
z;BIYgLGT|lA^5N3`!oUe3nK228fzVNg)tS9V~~an=@TIJv+Yn*?cBjw|9v|~U_;c!
z;pfBrN=i!iF@9gx;2Hi49Msj-^_Q3r(>v_%?dyk>r4t}E=6cA2Asv!uP=NFqqTn&7
z8<Lf_gDNXu{YUuWKfgh2tQ<d-JN)-M=uu+QPwVwCzTf#*RyLvAS9%}~y4R2;<0D9x
zP7Tsw2!@pC+aL{%$o=t_ljAhh-TmR0c|g!d)D7YpxSv0NhQvfAe!$Lkng^<@d-HFX
zIiNk<w+fkycS3r!ub^wpagZGSB}kXi3sR%3hvfJkLCj372Yh9uWuY%${(H@Xz<Rj7
zAl@Cu5C4(&fCi%NfVz11uIWF*K02@r>7VI_%;=v%_N+m0n-PZ$7=0mau6K~NRSzU8
zD)j^3z`&q=o(P->7lHTt=bjHe5Ca3#H*`Qh%gxREkFXDPeunfp>mgJ69LVdm4UAnB
zy2<7WX))A6*RS+J3!lG0HPtmg^fyo+!^6Wrw4-0)x3awU4R%oeHa2$u5%%S!b;yG6
zHFS;X5#+*Q31b(7Tsd7KBZf+Ne(i&%Kd&Cp_xB6<fxm-;(+_p<GyG#?W8bttfF1rr
zB{VxTdq5wN?oZvNr6s7P?gQj}HWDsxE$AY>B6N#01~TTTfn59sq1ojx-_QnYlXHT?
z-{b+b-I<x0Z|VTS|8V<>j=H<w_YrL#xWPdo-_S>-`%`yh-~;p|J{Y=cXacElT0mM<
zuOO9kLr_-f@GsY-iHVQC!4Ggee3<Y}9U%B0#;>TL^i4X@4<;ri|0Dceon6pX3ronw
z))Fd6u7@H$Mxn0$Prs!J>VTb%^BXK$n%ciD|GBxjANmgb$I{>OL6pJI-1YT!C<&e?
zz&dq){uA^(FAW+V{P}w3XX&q5UH=9@n0LUqez?3rI>d7|-1iT+8{m(MivG9pPfSce
zU_XPv_9yELL|ouLNqh1Gp5~_J1H6d12>g#8CH)W|%;AW5|I;pLci)#M{I}R&;{Sf!
z0(*=;c#ZNujT^ylVPWBiu_P=k{FnG|ySjaoUodCQ&;R$H6G8WX$_4F>gZ=b3nBZ@T
z{(v8W2jB;o58K6sMd;r(2)h5S`&0bhzsB$B>GchE(0&F62LE07|8cupTwH`08JNE*
zf3Oxp^w;mpB`z-h8~mW})YR1eui@|Q?fpSE@Hpl1FY$xD3c!50{lvz`{jcGFmX-ZY
z+3%MpJjR1^2X*j$`NQ82`~km#zTy8Gemgt+Z}5Y1ot^#HI_ziox3{<V_bi9YAM9_z
z81(O$@5|@!JcGHLi;L$Q{1;^}9hCde@B{iD9-iN{A5dra?%w}*;Qvs+e+NI1UjW{R
z?csIgukZu8B}j9)4*1Uq!0V3XznzD_gZFS;u;#cR@$Ehg;OXh<IVh7~;osTWg;Z74
zzrhdk<K^kSpZ4!$;xMMa<G*+B{x{_g`0MKEA7BTxeuW=|0h!bHbpZMSkn#K-^LH>K
z;<m!F>YvFx-h3xB_#J)_rmLg(O&x&x<Kf|h`uhj|I130&f9g(7PC>##B0rQpkm-Go
z_wY0De{Tl|hagT4t{-R#oIMA9`0(M6^6;m)K|HW;1+r{V?}sgr$AA1d{!QBf@&5`x
zh?51&gh9C<rU#zExCZ7r5a)LWg#U?s{kjekIQyeK8}KS9DEujnzrv5GkMGyifF{D)
z+1f)h(=)%!!e3zr>l-j$gT8gRj1c}icS64@=fm{=6hAm$ak=GsKp%k};etJ?hr8$g
z*am1GHi!8k{2<QI&@dDf7!1p^znz~DxPc4gXNWRHq&@8Z4FC7xi1c7y4hgw)Q10|}
zpbq{uM<D!wCpb@Wb909>o@PRIaGU7v?%wY!Z(w=zGgyZ01FwDM<rRNulZSDG^=5c@
z1O&<r!T&HWg#WMbBjN!UL8qvw_~3jCQT{)3599eeejaW<=y~b$1Ad1w9>#;fgm{O*
zhj{*-J2f>0UB7l?e_j4F?1$g|DRxliH*Z+OXO!Q{r~VZGVZ5OI9)A9nzon%GGKbGC
z5Pk13ZiN4@@B_K#)hm`zYisK_WsWG%zk?qU_pk7O-#<To{0POy#6g!~Innod`5AtI
zSxZv~ijR8$jgL?K5;r0bzbZcjUJ(9QaeqbQ`}gbX8&G?DJCvVau%9Pz4hC#oZ2bN>
z4$gcLG9U!c-?`t@Km7bV{QoY^!}NjwcXa-Vu*3X*mY<*TIGpCM{69<oPrd{E|D_TH
zZT|l*D1ra^asYZ-)UXwU?O*9>{Z)JUr^64o>3^E`@92H{vJOR6cS2=dLw_`v{EpV&
z4O>{)gzTTRLsv6up--@`*3Z%-=767tfp=gY&B(}vZaKT`kM%%q0IZI-9(4P*8wAet
zKYjYw`2~U&aQnNKAuFXuNRcN6DlMA$DQ`d@VZP_z(%b@>nOXeN+5pT|VD1FtJ)qOs
zw+z_|r$frLE|8thyZx~f@cEtxg8$+7;7r2a-tl04h?u|s)OB`=hqT$6Ap<58NROik
z8XQ?dWbrTg4-E~$`=$%u@CNg)lA`kdI<maH0($?x6<#B>K`&r^j_BySkeaH-L3|!A
zIY^bM3Nm4~gtTaqpp-|$KjnEizld@H>u{jQgUBb~tFLDOwYRk&;Qy5eoDu72xI?P!
zuOLGvCrFJZ8d5r+4vma_t0#4s?_vM)@-i$Vkv!lH))kLaQund{iYMYdpi`7F4e2mf
zLHdj?kQ$voq{LkYah~SeU&DV{{dv1T%-`AR)&XzOmVmCzpBO+R!T%#<NLv7x`Bg}Z
z(E~D)ZifW;We(`MyL<e$4m#R94&s6`2j^>lVgT=lUW3pThBW9Zs}^Lz;sP07YJ&!b
zmiP6204-3LU_E?T)^s@Ezz@#l5Ooe@O<<h-D+A&T_f0^yoRN?ovj$|%5dd9Peh+=<
z{(O*ELj$7&x?penJzww)&Z0qG1O5OnIP?1xv$F&LAT|9FWT9^gX)=~U0p9Rm23Oa=
zX)i$E1yKe-2DG~R-)Hg&EMO0X$UD$G`;)wb{Ug{H<>%!?W%*B_g-<Kr@I~MUJY-}p
z9?%DU7r__d2KWaagae&`KQSO5JKH<^v;Y=B>sJPxFCp?578?Eoe@j?50uc_*JN{{t
zp8oWJKG4xZ<Qw4vc|L+a*i--0=K1ro1Nx>WW<T&ZGBiF2Pl3-;{%Mm3w-H4C%;C8V
zk#B_SbZFcGZQ-9bKz57Z4`e6^z6duy{=q>w(3kzEjft_@0sWNZlppwmxdqWj!8irZ
z=>I7L<Y7R^0OTL=0Ox0jd?Q@Y-+^8kqKtq{=bthW5&zPA1GJ^3Wq;s}zyS165d4{$
zS^rob`#YSY@VpDonh|snb18!7VHfBN3k#n=h%0$P8d_ZZ?={Qs`1~wv6`pSu{!1<f
z_=}54?CV{CxQF>3_P>J90uWe%3(^DqqQ7ev;PY_}b<J;R0ofhk1<YZd-}@uNBM;gl
zzyQ`lrSLe9Nc&e<KpsR6l_O|#ckkXi;Q3elL0k0o@%sh?prNd!y1)LOfpxyVH{dKW
zJ39xK*J%Ba&L1960L{brzt8i}o|EBzis(0o>jYpC5I6@ZDk#J2QI!Lou)}eHpN*9r
zN=;2W$oF6IN95@+7I3a&1nYMJp5N2|)ia1|Vr&ZQ7z}*F`%n2Ja3EZeuA`#^0_!(W
zuRwp{d)|QOc@Z(l)5GhRcL)&lfO|NPf7cK0TmW6?lH!tm`}S@9fezl^rS-oZ9~KY%
zuNokyAb~BoQ}$PK3eboCF$>?F`n0kJZT;7}?RWKn=(`}!VgK*a)Q!wTwz+lC2CNtV
zyLgB&u<rtES+F()dmymK2jd`EtA4*;F3FjO)Wx!)7jLG1p#6Q@26BB@m)rX~i=fZ^
ztRI8<3G^)>U&xB@f^?aKAs6FnXcsOc1U`g|pbyHSu&@XMdf$k?2=)(PJOcX|aF(E=
ztafl00K}0z>ksMDM?ywt9z!D||5~df=ptMMeXs@u>kxpKhnsg_Rt)sczBgdslJGDQ
zy1?fH>x#!f8uZanu;+{4)>Bng^?@uyMOhUBWrQ#Q$6>R+wgcU<?%mh_SEmbxq|b!x
z%j3b>Bm(nc_sf?x2<%@#et~RedHLHt$zl5IU$!An?N-PV-Y@Dgc|k#L0|zn$FqQ#b
zk;AlsKOrG;pElSV10DWf8L%ID8q@$?VYvofVfTYV-233Rz5}1}4IRuWpp3t#f9az9
zK7DX*gD{6NBmDE9=AhdS*3fO;BB-cvcE7w4@j=@K`3G&`aDM?hI*7Ic+BL!;Xo6?p
z2l)p2oKq8H(E5Mfp+dw3E+~7@E<pPLdUzlWunqMM`|m**xGVSX8qlT?{RIAl$^reC
z@LeCo`=8Yf0taw`K|Fu&2XzDP-GH*FhT9?{9?*pV^nsn4nm%}s2tVw8PZJRa-h;6O
z&<1oG8ygSkfHge=KgbIr&Cgsw=U1j4p6?KJ5PDaD2B>R<u7SOs!(Y-z@CAGh`@#MQ
z;0Jd+5bqK6!5u-s8<Zc=VLTju*#A9EL>SO{*w^2N&zbMvkNF`z7-PVBE8q{>@7mgr
zeGt(4nF0DmnwPcq(}FvVKz@nf3tUh>z=CxmqJFfsbbhJ}`#pX@>+l}A06t4QO#3i>
zz#|Yo#|PyEEYK}UgLS6CeHla=1b)zt!5u##p?{58AU-&g2Q(0If98U4Ag2IhK7tRJ
zM|5F*q+7RK_H`5VVVMHBBLVUXEQtHy!NUXEhx7O|9^f6&l{Pf^muvvR2e=5D2-nES
z1itgt{SD?np^xATWUh(u*b3UMo~}M@4Pe=`1C*Hf2paycJ1&U0zjF_l8}R?i{*K1a
z!r<kR`2Uv{ti$kNOAXt<T8I4%-|yamd8d7R?wh(f93S)>Fs3|(b>M*>Jh<Ns?h}GI
zYpdH(fPV{A+xg>K2i$p$huh#8zOz5H2cTQ{@L?L{sZ#)Xn*1p51MMEjML}BvvM;dq
z0=iP*+`YW49Da8dQecgQG+{e3{NHm70=L6|ol78ODTw|A+^NwG$U!C_(&4xZ@pE3@
zU(X@Z0T-MbfOhNW>wh@ezJGlUPAeJ@S@H!#byf2axIYczBF<Aldbiu|`*Zlxcd`Kx
zR##IE#Rq0XLxcaidkpTYfPM+~MF<RF-w5uXd~bkm3?k0qFg^I}0j%W^Vc=W@=ve%z
z0c$}Z%Rr<Dd*q9<a(|i}-gm3)-|0l84-F05FO$B$zQ3d~GCZ=sP5|=;BK`RIIK&F?
zjln(9uV1%+NduIJAuN|<XXDskBO=lR7pyr!+c7h>_^BQ-klTQJy&%pb`2NY^w7?I>
z1#pK3tYN?y>Ez_Re`g%%k%RFQ=;whja6cHt2j+Vk;2Fr)!9Cr>asnV@zhZH9KMaxP
dSLqSqpbvsEa2U40k9hyRi-eR7k3;{y{eP|a0Z9M=

literal 0
HcmV?d00001

diff --git a/qpid/cpp/src/windows/resources/template-resource.rc b/qpid/cpp/src/windows/resources/template-resource.rc
new file mode 100644
index 0000000..725d1c9
--- /dev/null
+++ b/qpid/cpp/src/windows/resources/template-resource.rc
@@ -0,0 +1,122 @@
+//
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+//
+
+#include "version-resource.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.S.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE 
+BEGIN
+    "version-resource.h\0"
+END
+
+2 TEXTINCLUDE 
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION                            ${winverFileVersionBinary}
+ PRODUCTVERSION                         ${winverProductVersionBinary}
+ FILEFLAGSMASK 0x17L
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x4L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "FileDescription",  "${winverFileDescription}"
+            VALUE "FileVersion",      "${winverFileVersionString}"
+            VALUE "LegalCopyright",   "${winverLegalCopyright}"
+            VALUE "InternalName",     "${winverInternalName}"
+            VALUE "OriginalFilename", "${winverOriginalFilename}"
+            VALUE "ProductName",      "${winverProductName}"
+            VALUE "ProductVersion",   "${winverProductVersionString}"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
+
+// Icon with lowest ID value placed first to ensure application icon
+// remains consistent on all systems.
+IDI_ICON1               ICON                    "qpid-icon.ico"
+
+#endif    // English (U.S.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/qpid/cpp/src/windows/resources/version-resource.h b/qpid/cpp/src/windows/resources/version-resource.h
new file mode 100644
index 0000000..bf942ab
--- /dev/null
+++ b/qpid/cpp/src/windows/resources/version-resource.h
@@ -0,0 +1,35 @@
+//
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+//
+
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Preserved for common usage by any Qpid exe/dll.
+
+#define IDI_ICON1                       101
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        104
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1001
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
-- 
1.7.1.1

From e3a27bd87254d6533ff485e373831e07e4f872c2 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@apache.org>
Date: Tue, 13 Jul 2010 15:22:30 +0000
Subject: [PATCH 123/129] Windows .NET Support

QPID-2728 - Patch from Chuck Rolke
Fix recent changes to CMake build to properly handle separate source/build directories

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@963759 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit d68827e2b28356042e582250c840189e339e5076)
---
 qpid/cpp/src/CMakeLists.txt |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/src/CMakeLists.txt b/qpid/cpp/src/CMakeLists.txt
index 4a6dfbc..8411365 100644
--- a/qpid/cpp/src/CMakeLists.txt
+++ b/qpid/cpp/src/CMakeLists.txt
@@ -108,7 +108,7 @@ MACRO (add_msvc_version_full verProject verProjectType verProjectFileExt verFN1
         set ("winverOriginalFilename"      "${winver_${verProject}_OriginalFilename}")
         set ("winverProductName"           "${winver_${verProject}_ProductName}")
 
-        configure_file(windows/resources/template-resource.rc
+        configure_file(${CMAKE_CURRENT_SOURCE_DIR}/windows/resources/template-resource.rc
                          windows/resources/${verProject}-resource.rc)
         set (${verProject}_SOURCES
             ${${verProject}_SOURCES}
@@ -437,6 +437,7 @@ if (MSVC)
    set(Boost_FILESYSTEM_LIBRARY "")
    set(Boost_UNIT_TEST_FRAMEWORK_LIBRARY "")
    set(Boost_REGEX_LIBRARY "")
+   include_directories( ${CMAKE_CURRENT_SOURCE_DIR}/windows/resources )
 endif (MSVC)
 
 include_directories( ${Boost_INCLUDE_DIR} )
-- 
1.7.1.1

From d1cebff952de51923060c9147104e97923cd80cd Mon Sep 17 00:00:00 2001
From: Stephen D. Huston <shuston@apache.org>
Date: Wed, 14 Jul 2010 11:49:10 +0000
Subject: [PATCH 124/129] Windows .NET Support

Specify paths for the generated resource file so it gets picked up correctly when generating projects. Fixes QPID-2728.

git-svn-id: https://svn.apache.org/repos/asf/qpid/trunk@964013 13f79535-47bb-0310-9956-ffa450edef68
(cherry picked from commit 7c202b3645fc789ad03141826566d24c4af19099)
---
 qpid/cpp/src/CMakeLists.txt |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/CMakeLists.txt b/qpid/cpp/src/CMakeLists.txt
index 8411365..9000b66 100644
--- a/qpid/cpp/src/CMakeLists.txt
+++ b/qpid/cpp/src/CMakeLists.txt
@@ -109,10 +109,10 @@ MACRO (add_msvc_version_full verProject verProjectType verProjectFileExt verFN1
         set ("winverProductName"           "${winver_${verProject}_ProductName}")
 
         configure_file(${CMAKE_CURRENT_SOURCE_DIR}/windows/resources/template-resource.rc
-                         windows/resources/${verProject}-resource.rc)
+                       ${CMAKE_CURRENT_BINARY_DIR}/windows/resources/${verProject}-resource.rc)
         set (${verProject}_SOURCES
             ${${verProject}_SOURCES}
-            windows/resources/${verProject}-resource.rc
+            ${CMAKE_CURRENT_BINARY_DIR}/windows/resources/${verProject}-resource.rc
         )
     endif (MSVC)
 ENDMACRO (add_msvc_version_full)
-- 
1.7.1.1

From 82b9d0186f629f13c2ae02eefc628d80bce7a95f Mon Sep 17 00:00:00 2001
From: Alan Conway <aconway@redhat.com>
Date: Wed, 14 Jul 2010 16:53:20 -0400
Subject: [PATCH 125/129] Move libqpidtypes to the front of the libraries list.

Was causing failure of make install "can't find -lqpidtypes".
---
 qpid/cpp/src/Makefile.am |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/Makefile.am b/qpid/cpp/src/Makefile.am
index 52bdf98..2ab95f0 100644
--- a/qpid/cpp/src/Makefile.am
+++ b/qpid/cpp/src/Makefile.am
@@ -185,7 +185,7 @@ libqpidcommon_la_SOURCES += $(poller) $(systeminfo)
 posix_broker_src = \
   qpid/broker/posix/BrokerDefaults.cpp
 
-lib_LTLIBRARIES = libqpidcommon.la libqpidbroker.la libqpidclient.la libqpidmessaging.la libqpidtypes.la
+lib_LTLIBRARIES = libqpidtypes.la libqpidcommon.la libqpidbroker.la libqpidclient.la libqpidmessaging.la 
 
 # Definitions for client and daemon plugins
 PLUGINLDFLAGS=-no-undefined -module -avoid-version
@@ -711,7 +711,7 @@ libqpidclient_la_SOURCES =			\
 QPIDCLIENT_VERSION_INFO  = 2:0:0
 libqpidclient_la_LDFLAGS = -version-info $(QPIDCLIENT_VERSION_INFO)
 
-libqpidtypes_la_libadd=-luuid
+libqpidtypes_la_LIBADD=-luuid
 libqpidtypes_la_SOURCES=			\
   qpid/types/Exception.cpp			\
   qpid/types/Uuid.cpp				\
-- 
1.7.1.1

From 8df648dda96d9f997e9c5bff266876dcfda14eab Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@redhat.com>
Date: Mon, 26 Jul 2010 15:13:26 -0400
Subject: [PATCH 126/129] Fixed compare bug in the V1-specific object-id compare.

---
 .../cpp/include/qpid/management/ManagementObject.h |    3 ++-
 qpid/cpp/src/qpid/management/ManagementObject.cpp  |   11 ++++++-----
 2 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/qpid/cpp/include/qpid/management/ManagementObject.h b/qpid/cpp/include/qpid/management/ManagementObject.h
index 59a7f00..1dc93e1 100644
--- a/qpid/cpp/include/qpid/management/ManagementObject.h
+++ b/qpid/cpp/include/qpid/management/ManagementObject.h
@@ -62,7 +62,7 @@ public:
     QPID_COMMON_EXTERN ObjectId(const types::Variant& map) :
     agent(0), first(0), second(0), agentEpoch(0) { mapDecode(map.asMap()); }
     QPID_COMMON_EXTERN ObjectId(uint8_t flags, uint16_t seq, uint32_t broker);
-    QPID_COMMON_EXTERN ObjectId(AgentAttachment* _agent, uint8_t flags, uint16_t seq);
+    QPID_COMMON_EXTERN ObjectId(AgentAttachment* _agent, uint8_t flags, uint16_t seq, uint64_t obj=0);
     QPID_COMMON_EXTERN ObjectId(std::istream&);
     QPID_COMMON_EXTERN ObjectId(const std::string&);
     QPID_COMMON_EXTERN ObjectId(const std::string& agentAddress, const std::string& key,
@@ -70,6 +70,7 @@ public:
       agentEpoch(epoch), v2Key(key), agentName(agentAddress) {}
 
     // Deprecated:
+    QPID_COMMON_EXTERN ObjectId(uint64_t f, uint64_t s) : agent(0), first(f), second(s), agentEpoch(0) {}
     QPID_COMMON_EXTERN ObjectId(uint8_t flags, uint16_t seq, uint32_t broker, uint64_t object);
     QPID_COMMON_EXTERN bool operator==(const ObjectId &other) const;
     QPID_COMMON_EXTERN bool operator<(const ObjectId &other) const;
diff --git a/qpid/cpp/src/qpid/management/ManagementObject.cpp b/qpid/cpp/src/qpid/management/ManagementObject.cpp
index 5cdf9ec..50f0102 100644
--- a/qpid/cpp/src/qpid/management/ManagementObject.cpp
+++ b/qpid/cpp/src/qpid/management/ManagementObject.cpp
@@ -62,8 +62,8 @@ ObjectId::ObjectId(uint8_t flags, uint16_t seq, uint32_t broker)
         ((uint64_t) (broker & 0x000fffff)) << 28;
 }
 
-ObjectId::ObjectId(AgentAttachment* _agent, uint8_t flags, uint16_t seq)
-    : agent(_agent), second(0), agentEpoch(seq)
+ObjectId::ObjectId(AgentAttachment* _agent, uint8_t flags, uint16_t seq, uint64_t obj)
+    : agent(_agent), second(obj), agentEpoch(seq)
 {
 
     first =
@@ -142,8 +142,9 @@ bool ObjectId::operator<(const ObjectId &other) const
 
 bool ObjectId::equalV1(const ObjectId &other) const
 {
-    uint64_t otherFirst = agent == 0 ? other.first : other.first & 0xffff000000000000LL;
-    return first == otherFirst && second == other.second;
+    uint64_t otherFirst = other.agent == 0 ? other.first : other.agent->first | (other.first & 0xffff000000000000);
+    uint64_t thisFirst = agent == 0 ? first : agent->first | (first & 0xffff000000000000);
+    return thisFirst == otherFirst && second == other.second;
 }
 
 // encode as V1-format binary
@@ -253,7 +254,7 @@ ManagementObject::ManagementObject(Manageable* _core) :
 createTime(qpid::sys::Duration(sys::EPOCH, sys::now())),
         destroyTime(0), updateTime(createTime), configChanged(true),
         instChanged(true), deleted(false),
-        coreObject(_core), forcePublish(false) {}
+        coreObject(_core), flags(0), forcePublish(false) {}
 
 void ManagementObject::setUpdateTime()
 {
-- 
1.7.1.1

From 9d4472b47c7e08a4a18f07c67a2fe6ceab0a2b25 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@redhat.com>
Date: Mon, 26 Jul 2010 15:15:30 -0400
Subject: [PATCH 127/129] Turn on V1 code generation for non-broker files.

---
 qpid/cpp/managementgen/qmf-gen                    |    2 +-
 qpid/cpp/managementgen/qmfgen/templates/Class.cpp |    1 +
 2 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/qpid/cpp/managementgen/qmf-gen b/qpid/cpp/managementgen/qmf-gen
index 667aa1b..1936928 100755
--- a/qpid/cpp/managementgen/qmf-gen
+++ b/qpid/cpp/managementgen/qmf-gen
@@ -65,7 +65,7 @@ if opts.brokerplugin:
   vargs["genQmfV1"]       = True
 else:
   vargs["agentHeaderDir"] = "agent"
-  vargs["genQmfV1"]       = None
+  vargs["genQmfV1"]       = True
 
 for schemafile in args:
   package = SchemaPackage(typefile, schemafile, opts)
diff --git a/qpid/cpp/managementgen/qmfgen/templates/Class.cpp b/qpid/cpp/managementgen/qmfgen/templates/Class.cpp
index fc0b9c8..396812f 100644
--- a/qpid/cpp/managementgen/qmfgen/templates/Class.cpp
+++ b/qpid/cpp/managementgen/qmfgen/templates/Class.cpp
@@ -29,6 +29,7 @@
 /*MGEN:Class.MethodArgIncludes*/
 #include <iostream>
 #include <sstream>
+#include <string.h>
 
 using namespace qmf::/*MGEN:Class.Namespace*/;
 using           qpid::management::ManagementAgent;
-- 
1.7.1.1

From fc291ad73f1acbda6ce38ee427d801b0107c7430 Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@redhat.com>
Date: Mon, 26 Jul 2010 15:16:18 -0400
Subject: [PATCH 128/129] Revert to QMFv1 operation in the C++ agent.

---
 qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp |  761 +++++++++--------------
 qpid/cpp/src/qpid/agent/ManagementAgentImpl.h   |   59 +-
 2 files changed, 308 insertions(+), 512 deletions(-)

diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
index 351e0bf..fff352d 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
@@ -22,14 +22,14 @@
 #include "qpid/management/ManagementObject.h"
 #include "qpid/log/Statement.h"
 #include "qpid/agent/ManagementAgentImpl.h"
-#include "qpid/amqp_0_10/Codecs.h"
+#include "qpid/sys/Mutex.h"
 #include <list>
 #include <string.h>
 #include <stdlib.h>
 #include <sys/types.h>
 #include <iostream>
 #include <fstream>
-#include <boost/lexical_cast.hpp>
+
 
 using namespace qpid::client;
 using namespace qpid::framing;
@@ -41,18 +41,12 @@ using std::ofstream;
 using std::ifstream;
 using std::string;
 using std::endl;
-using qpid::types::Variant;
-using qpid::amqp_0_10::MapCodec;
-using qpid::amqp_0_10::ListCodec;
 
 namespace {
     qpid::sys::Mutex lock;
     bool disabled = false;
     ManagementAgent* agent = 0;
     int refCount = 0;
-
-    const string defaultVendorName("vendor");
-    const string defaultProductName("product");
 }
 
 ManagementAgent::Singleton::Singleton(bool disableManagement)
@@ -87,7 +81,7 @@ const string ManagementAgentImpl::storeMagicNumber("MA02");
 ManagementAgentImpl::ManagementAgentImpl() :
     interval(10), extThread(false), pipeHandle(0), notifyCallback(0), notifyContext(0),
     notifyable(0), inCallback(false),
-    initialized(false), connected(false), useMapMsg(false), lastFailure("never connected"),
+    initialized(false), connected(false), lastFailure("never connected"), label("RemoteAgent [C++]"),
     clientWasAdded(true), requestedBrokerBank(0), requestedAgentBank(0),
     assignedBrokerBank(0), assignedAgentBank(0), bootSequence(0),
     connThreadBody(*this), connThread(connThreadBody),
@@ -123,42 +117,6 @@ ManagementAgentImpl::~ManagementAgentImpl()
     }
 }
 
-void ManagementAgentImpl::setName(const string& vendor, const string& product, const string& instance)
-{
-    if (vendor.find(':') != vendor.npos) {
-        throw Exception("vendor string cannot contain a ':' character.");
-    }
-    if (product.find(':') != product.npos) {
-        throw Exception("product string cannot contain a ':' character.");
-    }
-    attrMap["_vendor"] = vendor;
-    attrMap["_product"] = product;
-    string inst;
-    if (instance.empty()) {
-        inst = qpid::types::Uuid(true).str();
-    } else
-        inst = instance;
-
-   name_address = vendor + ":" + product + ":" + inst;
-   attrMap["_instance"] = inst;
-   attrMap["_name"] = name_address;
-}
-
-
-void ManagementAgentImpl::getName(string& vendor, string& product, string& instance)
-{
-    vendor = std::string(attrMap["_vendor"]);
-    product = std::string(attrMap["_product"]);
-    instance = std::string(attrMap["_instance"]);
-}
-
-
-const std::string& ManagementAgentImpl::getAddress()
-{
-    return name_address;
-}
-
-
 void ManagementAgentImpl::init(const string& brokerHost,
                                uint16_t brokerPort,
                                uint16_t intervalSeconds,
@@ -182,7 +140,7 @@ void ManagementAgentImpl::init(const string& brokerHost,
 void ManagementAgentImpl::init(const qpid::management::ConnectionSettings& settings,
                                uint16_t intervalSeconds,
                                bool useExternalThread,
-                               const string& _storeFile)
+                               const std::string& _storeFile)
 {
     interval     = intervalSeconds;
     extThread    = useExternalThread;
@@ -218,16 +176,13 @@ void ManagementAgentImpl::init(const qpid::management::ConnectionSettings& setti
         bootSequence = 1;
     storeData(true);
 
-    if (attrMap.empty())
-        setName(defaultVendorName, defaultProductName);
-
     initialized = true;
 }
 
 void ManagementAgentImpl::registerClass(const string& packageName,
                                         const string& className,
                                         uint8_t*     md5Sum,
-                                        ManagementObject::writeSchemaCall_t schemaCall)
+                                        qpid::management::ManagementObject::writeSchemaCall_t schemaCall)
 { 
     sys::Mutex::ScopedLock lock(agentLock);
     PackageMap::iterator pIter = findOrAddPackage(packageName);
@@ -237,78 +192,73 @@ void ManagementAgentImpl::registerClass(const string& packageName,
 void ManagementAgentImpl::registerEvent(const string& packageName,
                                         const string& eventName,
                                         uint8_t*     md5Sum,
-                                        ManagementObject::writeSchemaCall_t schemaCall)
+                                        qpid::management::ManagementObject::writeSchemaCall_t schemaCall)
 { 
     sys::Mutex::ScopedLock lock(agentLock);
     PackageMap::iterator pIter = findOrAddPackage(packageName);
     addClassLocal(ManagementItem::CLASS_KIND_EVENT, pIter, eventName, md5Sum, schemaCall);
 }
 
-// old-style add object: 64bit id - deprecated
 ObjectId ManagementAgentImpl::addObject(ManagementObject* object,
                                         uint64_t          persistId)
 {
-    std::string key;
-    if (persistId) {
-        key = boost::lexical_cast<std::string>(persistId);
-    }
-    return addObject(object, key, persistId != 0);
-}
+    sys::Mutex::ScopedLock lock(addLock);
+    uint16_t sequence  = persistId ? 0 : bootSequence;
+    uint64_t objectNum = persistId ? persistId : nextObjectId++;
 
+    ObjectId objectId(&attachment, 0, sequence, objectNum);
 
-// new style add object - use this approach!
-ObjectId ManagementAgentImpl::addObject(ManagementObject* object,
-                                        const std::string& key,
-                                        bool persistent)
+    stringstream key;
+    key << objectNum;
+    objectId.setV2Key(key.str());
+
+    // TODO: fix object-id handling
+    object->setObjectId(objectId);
+    newManagementObjects[objectId] = object;
+    return objectId;
+}
+
+ObjectId ManagementAgentImpl::addObject(ManagementObject* object, const std::string&, bool persistent)
 {
     sys::Mutex::ScopedLock lock(addLock);
-
     uint16_t sequence  = persistent ? 0 : bootSequence;
+    uint64_t objectNum = nextObjectId++;
+
+    ObjectId objectId(&attachment, 0, sequence, objectNum);
 
-    ObjectId objectId(&attachment, 0, sequence);
-    if (key.empty())
-        objectId.setV2Key(*object);  // let object generate the key
-    else
-        objectId.setV2Key(key);
-    objectId.setAgentName(name_address);
+    stringstream key;
+    key << objectNum;
+    objectId.setV2Key(key.str());
 
     object->setObjectId(objectId);
     newManagementObjects[objectId] = object;
     return objectId;
 }
 
-
 void ManagementAgentImpl::raiseEvent(const ManagementEvent& event, severity_t severity)
 {
     sys::Mutex::ScopedLock lock(agentLock);
     Buffer outBuffer(eventBuffer, MA_BUFFER_SIZE);
+    uint32_t outLen;
     uint8_t sev = (severity == SEV_DEFAULT) ? event.getSeverity() : (uint8_t) severity;
     stringstream key;
 
     key << "console.event." << assignedBrokerBank << "." << assignedAgentBank << "." <<
         event.getPackageName() << "." << event.getEventName();
 
-    Variant::Map map_;
-    Variant::Map schemaId;
-    Variant::Map values;
-    Variant::Map headers;
     string content;
-
-    map_["_schema_id"] = mapEncodeSchemaId(event.getPackageName(),
-                                           event.getEventName(),
-                                           event.getMd5Sum());
-    event.mapEncode(values);
-    map_["_values"] = values;
-    map_["_timestamp"] = uint64_t(Duration(EPOCH, now()));
-    map_["_severity"] = sev;
-
-    headers["method"] = "indication";
-    headers["qmf.opcode"] = "_data_indication";
-    headers["qmf.content"] = "_event";
-    headers["qmf.agent"] = name_address;
-
-    MapCodec::encode(map_, content);
-    connThreadBody.sendBuffer(content, "", headers, "qmf.default.topic", key.str());
+    event.encode(content);
+
+    encodeHeader(outBuffer, 'e');
+    outBuffer.putShortString(event.getPackageName());
+    outBuffer.putShortString(event.getEventName());
+    outBuffer.putBin128(event.getMd5Sum());
+    outBuffer.putLongLong(uint64_t(Duration(EPOCH, now())));
+    outBuffer.putOctet(sev);
+    outBuffer.putRawData(content);
+    outLen = MA_BUFFER_SIZE - outBuffer.available();
+    outBuffer.reset();
+    connThreadBody.sendBuffer(outBuffer, outLen, "qpid.management", key.str());
 }
 
 uint32_t ManagementAgentImpl::pollCallbacks(uint32_t callLimit)
@@ -328,7 +278,8 @@ uint32_t ManagementAgentImpl::pollCallbacks(uint32_t callLimit)
         methodQueue.pop_front();
         {
             sys::Mutex::ScopedUnlock unlock(agentLock);
-            invokeMethodRequest(item->body, item->cid, item->replyTo);
+            Buffer inBuffer(const_cast<char*>(item->body.c_str()), item->body.size());
+            invokeMethodRequest(inBuffer, item->sequence, item->replyTo);
             delete item;
         }
     }
@@ -366,7 +317,20 @@ void ManagementAgentImpl::setSignalCallback(Notifyable& _notifyable)
 
 void ManagementAgentImpl::startProtocol()
 {
-    sendHeartbeat();
+    char    rawbuffer[512];
+    Buffer  buffer(rawbuffer, 512);
+
+    connected = true;
+    encodeHeader(buffer, 'A');
+    buffer.putShortString(label);
+    systemId.encode (buffer);
+    buffer.putLong(requestedBrokerBank);
+    buffer.putLong(requestedAgentBank);
+    uint32_t length = buffer.getPosition();
+    buffer.reset();
+    connThreadBody.sendBuffer(buffer, length, "qpid.management", "broker");
+    QPID_LOG(trace, "SENT AttachRequest: reqBroker=" << requestedBrokerBank <<
+             " reqAgent=" << requestedAgentBank);
 }
 
 void ManagementAgentImpl::storeData(bool requested)
@@ -402,69 +366,76 @@ void ManagementAgentImpl::retrieveData()
     }
 }
 
-void ManagementAgentImpl::sendHeartbeat()
+void ManagementAgentImpl::sendCommandComplete(string replyToKey, uint32_t sequence,
+                                              uint32_t code, string text)
 {
-    static const string addr_exchange("qmf.default.topic");
-    static const string addr_key_base("agent.ind.heartbeat");
-
-    Variant::Map map;
-    Variant::Map headers;
-    string content;
-    std::stringstream addr_key;
-
-    addr_key << addr_key_base;
-
-    // append .<vendor>.<product> to address key if present.
-    Variant::Map::const_iterator v;
-    if ((v = attrMap.find("_vendor")) != attrMap.end() &&
-        v->second.getString() != defaultVendorName) {
-        addr_key << "." << v->second.getString();
-        if ((v = attrMap.find("_product")) != attrMap.end() &&
-            v->second.getString() != defaultProductName) {
-            addr_key << "." << v->second.getString();
-        }
-    }
-
-    headers["method"] = "indication";
-    headers["qmf.opcode"] = "_agent_heartbeat_indication";
-    headers["qmf.agent"] = name_address;
+    Buffer   outBuffer(outputBuffer, MA_BUFFER_SIZE);
+    uint32_t outLen;
+
+    encodeHeader(outBuffer, 'z', sequence);
+    outBuffer.putLong(code);
+    outBuffer.putShortString(text);
+    outLen = MA_BUFFER_SIZE - outBuffer.available();
+    outBuffer.reset();
+    connThreadBody.sendBuffer(outBuffer, outLen, "amq.direct", replyToKey);
+    QPID_LOG(trace, "SENT CommandComplete: seq=" << sequence << " code=" << code << " text=" << text);
+}
 
-    map["_values"] = attrMap;
-    map["_values"].asMap()["timestamp"] = uint64_t(Duration(EPOCH, now()));
-    map["_values"].asMap()["heartbeat_interval"] = interval;
-    map["_values"].asMap()["epoch"] = bootSequence;
+void ManagementAgentImpl::handleAttachResponse(Buffer& inBuffer)
+{
+    sys::Mutex::ScopedLock lock(agentLock);
 
-    MapCodec::encode(map, content);
-    connThreadBody.sendBuffer(content, "", headers, addr_exchange, addr_key.str());
+    assignedBrokerBank = inBuffer.getLong();
+    assignedAgentBank  = inBuffer.getLong();
 
-    QPID_LOG(trace, "SENT AgentHeartbeat name=" << name_address);
-}
+    QPID_LOG(trace, "RCVD AttachResponse: broker=" << assignedBrokerBank << " agent=" << assignedAgentBank);
 
-void ManagementAgentImpl::sendException(const string& replyToKey, const string& cid,
-                                        const string& text, uint32_t code)
-{
-    static const string addr_exchange("qmf.default.direct");
+    if ((assignedBrokerBank != requestedBrokerBank) ||
+        (assignedAgentBank  != requestedAgentBank)) {
+        if (requestedAgentBank == 0) {
+            QPID_LOG(notice, "Initial object-id bank assigned: " << assignedBrokerBank << "." <<
+                     assignedAgentBank);
+        } else {
+            QPID_LOG(warning, "Collision in object-id! New bank assigned: " << assignedBrokerBank <<
+                     "." << assignedAgentBank);
+        }
+        storeData();
+        requestedBrokerBank = assignedBrokerBank;
+        requestedAgentBank = assignedAgentBank;
+    }
 
-    Variant::Map map;
-    Variant::Map headers;
-    Variant::Map values;
-    string content;
+    attachment.setBanks(assignedBrokerBank, assignedAgentBank);
 
-    headers["method"] = "indication";
-    headers["qmf.opcode"] = "_exception";
-    headers["qmf.agent"] = name_address;
+    // Bind to qpid.management to receive commands
+    connThreadBody.bindToBank(assignedBrokerBank, assignedAgentBank);
 
-    values["error_code"] = code;
-    values["error_text"] = text;
-    map["_values"] = values;
+    // Send package indications for all local packages
+    for (PackageMap::iterator pIter = packages.begin();
+         pIter != packages.end();
+         pIter++) {
+        Buffer   outBuffer(outputBuffer, MA_BUFFER_SIZE);
+        uint32_t outLen;
 
-    MapCodec::encode(map, content);
-    connThreadBody.sendBuffer(content, cid, headers, addr_exchange, replyToKey);
+        encodeHeader(outBuffer, 'p');
+        encodePackageIndication(outBuffer, pIter);
+        outLen = MA_BUFFER_SIZE - outBuffer.available();
+        outBuffer.reset();
+        connThreadBody.sendBuffer(outBuffer, outLen, "qpid.management", "broker");
 
-    QPID_LOG(trace, "SENT Exception code=" << code <<" text=" << text);
+        // Send class indications for all local classes
+        ClassMap cMap = pIter->second;
+        for (ClassMap::iterator cIter = cMap.begin(); cIter != cMap.end(); cIter++) {
+            outBuffer.reset();
+            encodeHeader(outBuffer, 'q');
+            encodeClassIndication(outBuffer, pIter, cIter);
+            outLen = MA_BUFFER_SIZE - outBuffer.available();
+            outBuffer.reset();
+            connThreadBody.sendBuffer(outBuffer, outLen, "qpid.management", "broker");
+        }
+    }
 }
 
-void ManagementAgentImpl::handleSchemaRequest(Buffer& inBuffer, uint32_t sequence, const string& replyTo)
+void ManagementAgentImpl::handleSchemaRequest(Buffer& inBuffer, uint32_t sequence)
 {
     sys::Mutex::ScopedLock lock(agentLock);
     string packageName;
@@ -484,14 +455,15 @@ void ManagementAgentImpl::handleSchemaRequest(Buffer& inBuffer, uint32_t sequenc
             SchemaClass& schema = cIter->second;
             Buffer   outBuffer(outputBuffer, MA_BUFFER_SIZE);
             uint32_t outLen;
-            string   body;
+            string content;
+
+            schema.writeSchemaCall(content);
 
             encodeHeader(outBuffer, 's', sequence);
-            schema.writeSchemaCall(body);
-            outBuffer.putRawData(body);
+            outBuffer.putRawData(content);
             outLen = MA_BUFFER_SIZE - outBuffer.available();
             outBuffer.reset();
-            connThreadBody.sendBuffer(outBuffer, outLen, "amq.direct", replyTo);
+            connThreadBody.sendBuffer(outBuffer, outLen, "qpid.management", "broker");
 
             QPID_LOG(trace, "SENT SchemaInd: package=" << packageName << " class=" << key.name);
         }
@@ -506,246 +478,136 @@ void ManagementAgentImpl::handleConsoleAddedIndication()
     QPID_LOG(trace, "RCVD ConsoleAddedInd");
 }
 
-void ManagementAgentImpl::invokeMethodRequest(const string& body, const string& cid, const string& replyTo)
+void ManagementAgentImpl::invokeMethodRequest(Buffer& inBuffer, uint32_t sequence, string replyTo)
 {
-    string  methodName;
-    bool    failed = false;
-    Variant::Map inMap;
-    Variant::Map outMap;
-    Variant::Map::const_iterator oid, mid;
-    string content;
-
-    MapCodec::decode(body, inMap);
+    string   methodName;
+    string   packageName;
+    string   className;
+    uint8_t  hash[16];
+    Buffer   outBuffer(outputBuffer, MA_BUFFER_SIZE);
+    uint32_t outLen;
+
+    uint64_t oid1, oid2;
+    oid1 = inBuffer.getLongLong();
+    oid2 = inBuffer.getLongLong();
+    ObjectId objId(oid1, oid2);
+    inBuffer.getShortString(packageName);
+    inBuffer.getShortString(className);
+    inBuffer.getBin128(hash);
+    inBuffer.getShortString(methodName);
 
-    outMap["_values"] = Variant::Map();
+    encodeHeader(outBuffer, 'm', sequence);
 
-    if ((oid = inMap.find("_object_id")) == inMap.end() ||
-        (mid = inMap.find("_method_name")) == inMap.end()) {
-        sendException(replyTo, cid, Manageable::StatusText(Manageable::STATUS_PARAMETER_INVALID),
-                      Manageable::STATUS_PARAMETER_INVALID);
-        failed = true;
+    ManagementObjectMap::iterator iter = numericFind(objId);
+    if (iter == managementObjects.end() || iter->second->isDeleted()) {
+        outBuffer.putLong        (Manageable::STATUS_UNKNOWN_OBJECT);
+        outBuffer.putMediumString(Manageable::StatusText(Manageable::STATUS_UNKNOWN_OBJECT));
     } else {
-        string methodName;
-        ObjectId objId;
-        Variant::Map inArgs;
-        Variant::Map callMap;
-
-        try {
-            // conversions will throw if input is invalid.
-            objId = ObjectId(oid->second.asMap());
-            methodName = mid->second.getString();
-
-            mid = inMap.find("_arguments");
-            if (mid != inMap.end()) {
-                inArgs = (mid->second).asMap();
-            }
-
-            ManagementObjectMap::iterator iter = managementObjects.find(objId);
-            if (iter == managementObjects.end() || iter->second->isDeleted()) {
-                sendException(replyTo, cid, Manageable::StatusText(Manageable::STATUS_UNKNOWN_OBJECT),
-                              Manageable::STATUS_UNKNOWN_OBJECT);
-                failed = true;
-            } else {
-                iter->second->doMethod(methodName, inArgs, callMap);
-            }
-
-            if (callMap["_status_code"].asUint32() == 0) {
-                outMap["_arguments"] = Variant::Map();
-                for (Variant::Map::const_iterator iter = callMap.begin();
-                     iter != callMap.end(); iter++)
-                    if (iter->first != "_status_code" && iter->first != "_status_text")
-                        outMap["_arguments"].asMap()[iter->first] = iter->second;
-            } else {
-                sendException(replyTo, cid, callMap["_status_text"], callMap["_status_code"]);
-                failed = true;
-            }
-
-        } catch(types::InvalidConversion& e) {
-            sendException(replyTo, cid, e.what(), Manageable::STATUS_EXCEPTION);
-            failed = true;
+        if ((iter->second->getPackageName() != packageName) ||
+            (iter->second->getClassName()   != className)) {
+            outBuffer.putLong        (Manageable::STATUS_PARAMETER_INVALID);
+            outBuffer.putMediumString(Manageable::StatusText (Manageable::STATUS_PARAMETER_INVALID));
         }
+        else
+            try {
+                string inContent, outContent;
+                inBuffer.getRawData(inContent, inBuffer.available());
+                iter->second->doMethod(methodName, inContent, outContent);
+                outBuffer.putRawData(outContent);
+            } catch(exception& e) {
+                outBuffer.putLong(Manageable::STATUS_EXCEPTION);
+                outBuffer.putMediumString(e.what());
+            }
     }
 
-    if (!failed) {
-        Variant::Map headers;
-        headers["method"] = "response";
-        headers["qmf.agent"] = name_address;
-        headers["qmf.opcode"] = "_method_response";
-        QPID_LOG(trace, "SENT MethodResponse map=" << outMap);
-        MapCodec::encode(outMap, content);
-        connThreadBody.sendBuffer(content, cid, headers, "qmf.default.direct", replyTo);
-    }
+    outLen = MA_BUFFER_SIZE - outBuffer.available();
+    outBuffer.reset();
+    connThreadBody.sendBuffer(outBuffer, outLen, "amq.direct", replyTo);
 }
 
-void ManagementAgentImpl::handleGetQuery(const string& body, const string& cid, const string& replyTo)
+void ManagementAgentImpl::handleGetQuery(Buffer& inBuffer, uint32_t sequence, string replyTo)
 {
-    moveNewObjectsLH();
-
-    Variant::Map inMap;
-    Variant::Map::const_iterator i;
-    Variant::Map headers;
-
-    MapCodec::decode(body, inMap);
-    QPID_LOG(trace, "RCVD GetQuery: map=" << inMap << " cid=" << cid);
-
-    headers["method"] = "response";
-    headers["qmf.opcode"] = "_query_response";
-    headers["qmf.content"] = "_data";
-    headers["qmf.agent"] = name_address;
-    headers["partial"] = Variant();
-
-    Variant::List list_;
-    Variant::Map  map_;
-    Variant::Map values;
-    Variant::Map oidMap;
-    string content;
-
-    /*
-     * Unpack the _what element of the query.  Currently we only support OBJECT queries.
-     */
-    i = inMap.find("_what");
-    if (i == inMap.end()) {
-        sendException(replyTo, cid, "_what element missing in Query");
-        return;
-    }
-
-    if (i->second.getType() != qpid::types::VAR_STRING) {
-        sendException(replyTo, cid, "_what element is not a string");
-        return;
-    }
+    FieldTable           ft;
+    FieldTable::ValuePtr value;
 
-    if (i->second.asString() != "OBJECT") {
-        sendException(replyTo, cid, "Query for _what => '" + i->second.asString() + "' not supported");
-        return;
-    }
-
-    string className;
-    string packageName;
-
-    /*
-     * Handle the _schema_id element, if supplied.
-     */
-    i = inMap.find("_schema_id");
-    if (i != inMap.end() && i->second.getType() == qpid::types::VAR_MAP) {
-        const Variant::Map& schemaIdMap(i->second.asMap());
+    moveNewObjectsLH();
 
-        Variant::Map::const_iterator s_iter = schemaIdMap.find("_class_name");
-        if (s_iter != schemaIdMap.end() && s_iter->second.getType() == qpid::types::VAR_STRING)
-            className = s_iter->second.asString();
+    ft.decode(inBuffer);
 
-        s_iter = schemaIdMap.find("_package_name");
-        if (s_iter != schemaIdMap.end() && s_iter->second.getType() == qpid::types::VAR_STRING)
-            packageName = s_iter->second.asString();
-    }
+    QPID_LOG(trace, "RCVD GetQuery: map=" << ft);
 
-    /*
-     * Unpack the _object_id element of the query if it is present.  If it is present, find that one
-     * object and return it.  If it is not present, send a class-based result.
-     */
-    i = inMap.find("_object_id");
-    if (i != inMap.end() && i->second.getType() == qpid::types::VAR_MAP) {
-        ObjectId objId(i->second.asMap());
+    value = ft.get("_class");
+    if (value.get() == 0 || !value->convertsTo<string>()) {
+        value = ft.get("_objectid");
+        if (value.get() == 0 || !value->convertsTo<string>())
+            return;
 
-        ManagementObjectMap::iterator iter = managementObjects.find(objId);
+        ObjectId selector(value->get<string>());
+        ManagementObjectMap::iterator iter = numericFind(selector);
         if (iter != managementObjects.end()) {
             ManagementObject* object = iter->second;
+            Buffer   outBuffer (outputBuffer, MA_BUFFER_SIZE);
+            uint32_t outLen;
+            string content;
 
             if (object->getConfigChanged() || object->getInstChanged())
                 object->setUpdateTime();
 
-            object->mapEncodeValues(values, true, true); // write both stats and properties
-            objId.mapEncode(oidMap);
-            map_["_values"] = values;
-            map_["_object_id"] = oidMap;
-            object->writeTimestamps(map_);
-            map_["_schema_id"] = mapEncodeSchemaId(object->getPackageName(),
-                                                   object->getClassName(),
-                                                   object->getMd5Sum());
-
-            list_.push_back(map_);
-            headers.erase("partial");
-
-            ListCodec::encode(list_, content);
-            connThreadBody.sendBuffer(content, cid, headers, "qmf.default.direct", replyTo, "amqp/list");
-            QPID_LOG(trace, "SENT QueryResponse (query by object_id) to=" << replyTo);
-            return;
-        }
-    } else {
-        for (ManagementObjectMap::iterator iter = managementObjects.begin();
-             iter != managementObjects.end();
-             iter++) {
-            ManagementObject* object = iter->second;
-            if (object->getClassName() == className &&
-                (packageName.empty() || object->getPackageName() == packageName)) {
-
-                // @todo support multiple object reply per message
-                values.clear();
-                list_.clear();
-                oidMap.clear();
-
-                if (object->getConfigChanged() || object->getInstChanged())
-                    object->setUpdateTime();
+            encodeHeader(outBuffer, 'g', sequence);
+            object->writeProperties(content);
+            outBuffer.putRawData(content);
+            content.clear();
+            object->writeStatistics(content, true);
+            outBuffer.putRawData(content);
+            outLen = MA_BUFFER_SIZE - outBuffer.available ();
+            outBuffer.reset ();
+            connThreadBody.sendBuffer(outBuffer, outLen, "amq.direct", replyTo);
 
-                object->mapEncodeValues(values, true, true); // write both stats and properties
-                iter->first.mapEncode(oidMap);
-                map_["_values"] = values;
-                map_["_object_id"] = oidMap;
-                object->writeTimestamps(map_);
-                map_["_schema_id"] = mapEncodeSchemaId(object->getPackageName(),
-                                                       object->getClassName(),
-                                                       object->getMd5Sum());
-                list_.push_back(map_);
-
-                ListCodec::encode(list_, content);
-                connThreadBody.sendBuffer(content, cid, headers, "qmf.default.direct", replyTo, "amqp/list");
-                QPID_LOG(trace, "SENT QueryResponse (query by schema_id) to=" << replyTo);
-            }
+            QPID_LOG(trace, "SENT ObjectInd");
         }
+        sendCommandComplete(replyTo, sequence);
+        return;
     }
 
-    // Send empty "non-partial" message to indicate CommandComplete
-    list_.clear();
-    headers.erase("partial");
-    ListCodec::encode(list_, content);
-    connThreadBody.sendBuffer(content, cid, headers, "qmf.default.direct", replyTo, "amqp/list");
-    QPID_LOG(trace, "SENT QueryResponse (empty with no 'partial' indicator) to=" << replyTo);
-}
-
-void ManagementAgentImpl::handleLocateRequest(const string&, const string& cid, const string& replyTo)
-{
-    QPID_LOG(trace, "RCVD AgentLocateRequest");
-    static const string addr_exchange("qmf.default.direct");
-
-    Variant::Map map;
-    Variant::Map headers;
-    string content;
+    string className(value->get<string>());
 
-    headers["method"] = "indication";
-    headers["qmf.opcode"] = "_agent_locate_response";
-    headers["qmf.agent"] = name_address;
-
-    map["_values"] = attrMap;
-    map["_values"].asMap()["timestamp"] = uint64_t(Duration(EPOCH, now()));
-    map["_values"].asMap()["heartbeat_interval"] = interval;
-    map["_values"].asMap()["epoch"] = bootSequence;
+    for (ManagementObjectMap::iterator iter = managementObjects.begin();
+         iter != managementObjects.end();
+         iter++) {
+        ManagementObject* object = iter->second;
+        if (object->getClassName() == className) {
+            Buffer   outBuffer(outputBuffer, MA_BUFFER_SIZE);
+            uint32_t outLen;
+            string content;
 
-    MapCodec::encode(map, content);
-    connThreadBody.sendBuffer(content, cid, headers, addr_exchange, replyTo);
+            if (object->getConfigChanged() || object->getInstChanged())
+                object->setUpdateTime();
 
-    QPID_LOG(trace, "SENT AgentLocateResponse replyTo=" << replyTo);
+            encodeHeader(outBuffer, 'g', sequence);
+            object->writeProperties(content);
+            outBuffer.putRawData(content);
+            content.clear();
+            object->writeStatistics(content, true);
+            outBuffer.putRawData(content);
+            outLen = MA_BUFFER_SIZE - outBuffer.available();
+            outBuffer.reset();
+            connThreadBody.sendBuffer(outBuffer, outLen, "amq.direct", replyTo);
 
-    {
-        sys::Mutex::ScopedLock lock(agentLock);
-        clientWasAdded = true;
+            QPID_LOG(trace, "SENT ObjectInd");
+        }
     }
+
+    sendCommandComplete(replyTo, sequence);
 }
 
-void ManagementAgentImpl::handleMethodRequest(const string& body, const string& cid, const string& replyTo)
+void ManagementAgentImpl::handleMethodRequest(Buffer& inBuffer, uint32_t sequence, string replyTo)
 {
     if (extThread) {
         sys::Mutex::ScopedLock lock(agentLock);
+        string body;
 
-        methodQueue.push_back(new QueuedMethod(cid, replyTo, body));
+        inBuffer.getRawData(body, inBuffer.available());
+        methodQueue.push_back(new QueuedMethod(sequence, replyTo, body));
         if (pipeHandle != 0) {
             pipeHandle->write("X", 1);
         } else if (notifyable != 0) {
@@ -764,7 +626,7 @@ void ManagementAgentImpl::handleMethodRequest(const string& body, const string&
             inCallback = false;
         }
     } else {
-        invokeMethodRequest(body, cid, replyTo);
+        invokeMethodRequest(inBuffer, sequence, replyTo);
     }
 
     QPID_LOG(trace, "RCVD MethodRequest");
@@ -772,45 +634,28 @@ void ManagementAgentImpl::handleMethodRequest(const string& body, const string&
 
 void ManagementAgentImpl::received(Message& msg)
 {
-    string   replyToKey;
-    framing::MessageProperties mp = msg.getMessageProperties();
-    if (mp.hasReplyTo()) {
-        const framing::ReplyTo& rt = mp.getReplyTo();
-        replyToKey = rt.getRoutingKey();
-    }
-
-    if (mp.hasAppId() && mp.getAppId() == "qmf2")
-    {
-        string opcode = mp.getApplicationHeaders().getAsString("qmf.opcode");
-        string cid = msg.getMessageProperties().getCorrelationId();
-
-        if      (opcode == "_agent_locate_request") handleLocateRequest(msg.getData(), cid, replyToKey);
-        else if (opcode == "_method_request")       handleMethodRequest(msg.getData(), cid, replyToKey);
-        else if (opcode == "_query_request")        handleGetQuery(msg.getData(), cid, replyToKey);
-        else {
-            QPID_LOG(warning, "Support for QMF V2 Opcode [" << opcode << "] TBD!!!");
-        }
-        return;
-    }
-
-    // old preV2 binary messages
-    
-    uint32_t sequence;
     string   data = msg.getData();
     Buffer   inBuffer(const_cast<char*>(data.c_str()), data.size());
     uint8_t  opcode;
+    uint32_t sequence;
+    string   replyToKey;
 
+    framing::MessageProperties p = msg.getMessageProperties();
+    if (p.hasReplyTo()) {
+        const framing::ReplyTo& rt = p.getReplyTo();
+        replyToKey = rt.getRoutingKey();
+    }
 
     if (checkHeader(inBuffer, &opcode, &sequence))
     {
-        if      (opcode == 'S') handleSchemaRequest(inBuffer, sequence, replyToKey);
+        if      (opcode == 'a') handleAttachResponse(inBuffer);
+        else if (opcode == 'S') handleSchemaRequest(inBuffer, sequence);
         else if (opcode == 'x') handleConsoleAddedIndication();
-        else
-            QPID_LOG(warning, "Ignoring old-format QMF Request! opcode=" << char(opcode));
+        else if (opcode == 'G') handleGetQuery(inBuffer, sequence, replyToKey);
+        else if (opcode == 'M') handleMethodRequest(inBuffer, sequence, replyToKey);
     }
 }
 
-
 void ManagementAgentImpl::encodeHeader(Buffer& buf, uint8_t opcode, uint32_t seq)
 {
     buf.putOctet('A');
@@ -820,19 +665,6 @@ void ManagementAgentImpl::encodeHeader(Buffer& buf, uint8_t opcode, uint32_t seq
     buf.putLong (seq);
 }
 
-Variant::Map ManagementAgentImpl::mapEncodeSchemaId(const string& pname,
-                                                    const string& cname,
-                                                    const uint8_t *md5Sum)
-{
-    Variant::Map map_;
-
-    map_["_package_name"] = pname;
-    map_["_class_name"] = cname;
-    map_["_hash"] = types::Uuid(md5Sum);
-    return map_;
-}
-
-
 bool ManagementAgentImpl::checkHeader(Buffer& buf, uint8_t *opcode, uint32_t *seq)
 {
     if (buf.getSize() < 8)
@@ -887,7 +719,7 @@ void ManagementAgentImpl::addClassLocal(uint8_t               classKind,
                                         PackageMap::iterator  pIter,
                                         const string&         className,
                                         uint8_t*              md5Sum,
-                                        ManagementObject::writeSchemaCall_t schemaCall)
+                                        qpid::management::ManagementObject::writeSchemaCall_t schemaCall)
 {
     SchemaClassKey key;
     ClassMap&      cMap = pIter->second;
@@ -927,7 +759,10 @@ void ManagementAgentImpl::encodeClassIndication(Buffer&              buf,
 
 void ManagementAgentImpl::periodicProcessing()
 {
+#define BUFSIZE   65536
     sys::Mutex::ScopedLock lock(agentLock);
+    char                msgChars[BUFSIZE];
+    uint32_t            contentSize;
     list<pair<ObjectId, ManagementObject*> > deleteList;
 
     if (!connected)
@@ -968,54 +803,47 @@ void ManagementAgentImpl::periodicProcessing()
              !baseObject->isDeleted()))
             continue;
 
-        Variant::List list_;
-
+        Buffer msgBuffer(msgChars, BUFSIZE);
         for (ManagementObjectMap::iterator iter = baseIter;
              iter != managementObjects.end();
              iter++) {
             ManagementObject* object = iter->second;
-            bool send_stats, send_props;
             if (baseObject->isSameClass(*object) && object->getFlags() == 0) {
                 object->setFlags(1);
                 if (object->getConfigChanged() || object->getInstChanged())
                     object->setUpdateTime();
 
-                send_props = (object->getConfigChanged() || object->getForcePublish() || object->isDeleted());
-                send_stats = (object->hasInst() && (object->getInstChanged() || object->getForcePublish()));
-
-                if (send_stats || send_props) {
-                    Variant::Map map_;
-                    Variant::Map values;
-                    Variant::Map oid;
-
-                    object->getObjectId().mapEncode(oid);
-                    map_["_object_id"] = oid;
-                    map_["_schema_id"] = mapEncodeSchemaId(object->getPackageName(),
-                                                           object->getClassName(),
-                                                           object->getMd5Sum());
-                    object->writeTimestamps(map_);
-                    object->mapEncodeValues(values, send_props, send_stats);
-                    map_["_values"] = values;
-                    list_.push_back(map_);
+                if (object->getConfigChanged() || object->getForcePublish() || object->isDeleted()) {
+                    string content;
+                    encodeHeader(msgBuffer, 'c');
+                    object->writeProperties(content);
+                    msgBuffer.putRawData(content);
+                }
+        
+                if (object->hasInst() && (object->getInstChanged() || object->getForcePublish())) {
+                    string content;
+                    encodeHeader(msgBuffer, 'i');
+                    object->writeStatistics(content);
+                    msgBuffer.putRawData(content);
                 }
 
                 if (object->isDeleted())
                     deleteList.push_back(pair<ObjectId, ManagementObject*>(iter->first, object));
                 object->setForcePublish(false);
+
+                if (msgBuffer.available() < (BUFSIZE / 2))
+                    break;
             }
         }
 
-        string content;
-        ListCodec::encode(list_, content);
-        if (content.length()) {
-            Variant::Map  headers;
-            headers["method"] = "indication";
-            headers["qmf.opcode"] = "_data_indication";
-            headers["qmf.content"] = "_data";
-            headers["qmf.agent"] = name_address;
-
-            connThreadBody.sendBuffer(content, "", headers, "qmf.default.topic", "agent.ind.data", "amqp/list");
-            QPID_LOG(trace, "SENT DataIndication");
+        contentSize = BUFSIZE - msgBuffer.available();
+        if (contentSize > 0) {
+            msgBuffer.reset();
+            stringstream key;
+            key << "console.obj." << assignedBrokerBank << "." << assignedAgentBank << "." <<
+                baseObject->getPackageName() << "." << baseObject->getClassName();
+            connThreadBody.sendBuffer(msgBuffer, contentSize, "qpid.management", key.str());
+            QPID_LOG(trace, "SENT PeriodicContent to=" << key.str());
         }
     }
 
@@ -1028,7 +856,18 @@ void ManagementAgentImpl::periodicProcessing()
     }
 
     deleteList.clear();
-    sendHeartbeat();
+
+    {
+        Buffer msgBuffer(msgChars, BUFSIZE);
+        encodeHeader(msgBuffer, 'h');
+        msgBuffer.putLongLong(uint64_t(Duration(EPOCH, now())));
+        stringstream key;
+        key << "console.heartbeat." << assignedBrokerBank << "." << assignedAgentBank;
+
+        contentSize = BUFSIZE - msgBuffer.available();
+        msgBuffer.reset();
+        connThreadBody.sendBuffer(msgBuffer, contentSize, "qpid.management", key.str());
+    }
 }
 
 void ManagementAgentImpl::ConnectionThread::run()
@@ -1055,10 +894,6 @@ void ManagementAgentImpl::ConnectionThread::run()
                                      arg::exclusive=true);
                 session.exchangeBind(arg::exchange="amq.direct", arg::queue=queueName.str(),
                                      arg::bindingKey=queueName.str());
-                session.exchangeBind(arg::exchange="qmf.default.direct", arg::queue=queueName.str(),
-                                     arg::bindingKey=agent.name_address);
-                session.exchangeBind(arg::exchange="qmf.default.topic", arg::queue=queueName.str(),
-                                     arg::bindingKey="console.#");
 
                 subscriptions->subscribe(agent, queueName.str(), dest);
                 QPID_LOG(info, "Connection established with broker");
@@ -1067,7 +902,6 @@ void ManagementAgentImpl::ConnectionThread::run()
                     if (shutdown)
                         return;
                     operational = true;
-                    agent.connected = true;
                     agent.startProtocol();
                     try {
                         sys::Mutex::ScopedUnlock _unlock(connLock);
@@ -1121,48 +955,6 @@ void ManagementAgentImpl::ConnectionThread::sendBuffer(Buffer&  buf,
                                                        const string& exchange,
                                                        const string& routingKey)
 {
-    Message msg;
-    string  data;
-
-    buf.getRawData(data, length);
-    msg.setData(data);
-    sendMessage(msg, exchange, routingKey);
-}
-
-
-
-void ManagementAgentImpl::ConnectionThread::sendBuffer(const string& data,
-                                                       const string& cid,
-                                                       const Variant::Map headers,
-                                                       const string& exchange,
-                                                       const string& routingKey,
-                                                       const string& contentType)
-{
-    Message msg;
-    Variant::Map::const_iterator i;
-
-    if (!cid.empty())
-        msg.getMessageProperties().setCorrelationId(cid);
-
-    if (!contentType.empty())
-        msg.getMessageProperties().setContentType(contentType);
-    for (i = headers.begin(); i != headers.end(); ++i) {
-        msg.getHeaders().setString(i->first, i->second.asString());
-    }
-    msg.getHeaders().setString("app_id", "qmf2");
-
-    msg.setData(data);
-    sendMessage(msg, exchange, routingKey);
-}
-
-
-
-
-
-void ManagementAgentImpl::ConnectionThread::sendMessage(Message msg,
-                                                        const string& exchange,
-                                                        const string& routingKey)
-{
     ConnectionThread::shared_ptr s;
     {
         sys::Mutex::ScopedLock _lock(connLock);
@@ -1171,20 +963,24 @@ void ManagementAgentImpl::ConnectionThread::sendMessage(Message msg,
         s = subscriptions;
     }
 
+    Message msg;
+    string  data;
+
+    buf.getRawData(data, length);
     msg.getDeliveryProperties().setRoutingKey(routingKey);
     msg.getMessageProperties().setReplyTo(ReplyTo("amq.direct", queueName.str()));
-    msg.getMessageProperties().getApplicationHeaders().setString("qmf.agent", agent.name_address);
+    msg.setData(data);
     try {
         session.messageTransfer(arg::content=msg, arg::destination=exchange);
     } catch(exception& e) {
-        QPID_LOG(error, "Exception caught in sendMessage: " << e.what());
+        QPID_LOG(error, "Exception caught in sendBuffer: " << e.what());
         // Bounce the connection
         if (s)
             s->stop();
     }
-}
-
 
+    buf.reset();
+}
 
 void ManagementAgentImpl::ConnectionThread::bindToBank(uint32_t brokerBank, uint32_t agentBank)
 {
@@ -1225,3 +1021,14 @@ void ManagementAgentImpl::PublishThread::run()
         }
     }
 }
+
+ManagementObjectMap::iterator ManagementAgentImpl::numericFind(const ObjectId& oid)
+{
+    ManagementObjectMap::iterator iter = managementObjects.begin();
+    for (; iter != managementObjects.end(); iter++) {
+        if (oid.equalV1(iter->first))
+            break;
+    }
+
+    return iter;
+}
diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
index 4a58807..843f710 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.h
@@ -51,11 +51,13 @@ class ManagementAgentImpl : public ManagementAgent, public client::MessageListen
     // Methods from ManagementAgent
     //
     int getMaxThreads() { return 1; }
-    void setName(const std::string& vendor,
-                 const std::string& product,
-                 const std::string& instance="");
-    void getName(std::string& vendor, std::string& product, std::string& instance);
-    const std::string& getAddress();
+    void setName(const std::string& v,
+                 const std::string& p,
+                 const std::string& i) { vendor = v; product = p; instance = i; label = v + ":" + p + ":" + i; }
+    void getName(std::string& v,
+                 std::string& p,
+                 std::string& i) { v = vendor; p = product; i = instance; }
+    const std::string& getAddress() { return label; }
     void init(const std::string& brokerHost = "localhost",
               uint16_t brokerPort = 5672,
               uint16_t intervalSeconds = 10,
@@ -80,8 +82,7 @@ class ManagementAgentImpl : public ManagementAgent, public client::MessageListen
                        uint8_t*     md5Sum,
                        management::ManagementObject::writeSchemaCall_t schemaCall);
     ObjectId addObject(management::ManagementObject* objectPtr, uint64_t persistId = 0);
-    ObjectId addObject(management::ManagementObject* objectPtr, const std::string& key,
-                       bool persistent);
+    ObjectId addObject(ManagementObject* objectPtr, const std::string& key, bool persistent = true);
     void raiseEvent(const management::ManagementEvent& event, severity_t severity = SEV_DEFAULT);
     uint32_t pollCallbacks(uint32_t callLimit = 0);
     int getSignalFd();
@@ -127,10 +128,10 @@ class ManagementAgentImpl : public ManagementAgent, public client::MessageListen
     };
 
     struct QueuedMethod {
-    QueuedMethod(const std::string& _cid, const std::string& _reply, const std::string& _body) :
-        cid(_cid), replyTo(_reply), body(_body) {}
+        QueuedMethod(uint32_t _seq, std::string _reply, std::string _body) :
+            sequence(_seq), replyTo(_reply), body(_body) {}
 
-        std::string cid;
+        uint32_t    sequence;
         std::string replyTo;
         std::string body;
     };
@@ -147,8 +148,6 @@ class ManagementAgentImpl : public ManagementAgent, public client::MessageListen
 
     void received (client::Message& msg);
 
-    qpid::types::Variant::Map attrMap;
-    std::string       name_address;
     uint16_t          interval;
     bool              extThread;
     sys::PipeHandle*  pipeHandle;
@@ -164,8 +163,11 @@ class ManagementAgentImpl : public ManagementAgent, public client::MessageListen
     client::ConnectionSettings connectionSettings;
     bool              initialized;
     bool              connected;
-    bool              useMapMsg;
     std::string       lastFailure;
+    std::string       vendor;
+    std::string       product;
+    std::string       instance;
+    std::string       label;
 
     bool              clientWasAdded;
     uint32_t          requestedBrokerBank;
@@ -208,15 +210,6 @@ class ManagementAgentImpl : public ManagementAgent, public client::MessageListen
                         uint32_t               length,
                         const std::string&     exchange,
                         const std::string&     routingKey);
-        void sendBuffer(const std::string&     data,
-                        const std::string&     cid,
-                        const qpid::types::Variant::Map headers,
-                        const std::string&     exchange,
-                        const std::string&     routingKey,
-                        const std::string&     contentType="amqp/map");
-        void sendMessage(qpid::client::Message msg,
-                         const std::string&     exchange,
-                         const std::string&     routingKey);
         void bindToBank(uint32_t brokerBank, uint32_t agentBank);
         void close();
         bool isSleeping() const;
@@ -256,23 +249,19 @@ class ManagementAgentImpl : public ManagementAgent, public client::MessageListen
                                 PackageMap::iterator   pIter,
                                 ClassMap::iterator     cIter);
     void encodeHeader (framing::Buffer& buf, uint8_t  opcode, uint32_t  seq = 0);
-    qpid::types::Variant::Map mapEncodeSchemaId(const std::string& pname,
-                                                const std::string& cname,
-                                                const uint8_t *md5Sum);
     bool checkHeader  (framing::Buffer& buf, uint8_t *opcode, uint32_t *seq);
-    void sendHeartbeat();
-    void sendException(const std::string& replyToKey, const std::string& cid,
-                       const std::string& text, uint32_t code=1);
+    void sendCommandComplete  (std::string replyToKey, uint32_t sequence,
+                               uint32_t code = 0, std::string text = std::string("OK"));
+    void handleAttachResponse (qpid::framing::Buffer& inBuffer);
     void handlePackageRequest (qpid::framing::Buffer& inBuffer);
     void handleClassQuery     (qpid::framing::Buffer& inBuffer);
-    void handleSchemaRequest  (qpid::framing::Buffer& inBuffer, uint32_t sequence, const std::string& replyTo);
-    void invokeMethodRequest  (const std::string& body, const std::string& cid, const std::string& replyTo);
-
-    void handleGetQuery       (const std::string& body, const std::string& cid, const std::string& replyTo);
-    void handleLocateRequest  (const std::string& body, const std::string& sequence, const std::string& replyTo);
-    void handleMethodRequest  (const std::string& body, const std::string& sequence, const std::string& replyTo);
+    void handleSchemaRequest  (qpid::framing::Buffer& inBuffer, uint32_t sequence);
+    void invokeMethodRequest  (qpid::framing::Buffer& inBuffer, uint32_t sequence, std::string replyTo);
+    void handleGetQuery       (qpid::framing::Buffer& inBuffer, uint32_t sequence, std::string replyTo);
+    void handleMethodRequest  (qpid::framing::Buffer& inBuffer, uint32_t sequence, std::string replyTo);
     void handleConsoleAddedIndication();
-};
+    ManagementObjectMap::iterator numericFind(const ObjectId& oid);
+ };
 
 }}
 
-- 
1.7.1.1

From aadc5a6981e8a4f07069b4e41860ccac5567f90b Mon Sep 17 00:00:00 2001
From: Ted Ross <tross@redhat.com>
Date: Mon, 26 Jul 2010 16:05:21 -0400
Subject: [PATCH 129/129] Bumped library versions for QMF

---
 qpid/cpp/src/qmf.mk |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/qpid/cpp/src/qmf.mk b/qpid/cpp/src/qmf.mk
index 93f1817..e03381d 100644
--- a/qpid/cpp/src/qmf.mk
+++ b/qpid/cpp/src/qmf.mk
@@ -96,8 +96,8 @@ libqmfengine_la_SOURCES =			\
 libqmf_la_LIBADD = libqmfengine.la
 libqmfengine_la_LIBADD = libqpidclient.la
 
-QMF_VERSION_INFO = 1:0:0
-QMFENGINE_VERSION_INFO  = 1:1:0
+QMF_VERSION_INFO = 2:0:0
+QMFENGINE_VERSION_INFO  = 2:0:0
 
 libqmf_la_LDFLAGS = -version-info $(QMF_VERSION_INFO)
 libqmfengine_la_LDFLAGS = -version-info $(QMFENGINE_VERSION_INFO)
-- 
1.7.1.1

